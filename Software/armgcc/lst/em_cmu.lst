ARM GAS  /tmp/ccnCWsWR.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"em_cmu.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.CMU_FlashWaitStateMax,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	CMU_FlashWaitStateMax:
  24              	.LFB76:
  25              		.file 1 "../emlib/src/em_cmu.c"
   1:../emlib/src/em_cmu.c **** /***************************************************************************//**
   2:../emlib/src/em_cmu.c ****  * @file
   3:../emlib/src/em_cmu.c ****  * @brief Clock management unit (CMU) Peripheral API
   4:../emlib/src/em_cmu.c ****  * @author Energy Micro AS
   5:../emlib/src/em_cmu.c ****  * @version 3.20.2
   6:../emlib/src/em_cmu.c ****  *******************************************************************************
   7:../emlib/src/em_cmu.c ****  * @section License
   8:../emlib/src/em_cmu.c ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
   9:../emlib/src/em_cmu.c ****  *******************************************************************************
  10:../emlib/src/em_cmu.c ****  *
  11:../emlib/src/em_cmu.c ****  * Permission is granted to anyone to use this software for any purpose,
  12:../emlib/src/em_cmu.c ****  * including commercial applications, and to alter it and redistribute it
  13:../emlib/src/em_cmu.c ****  * freely, subject to the following restrictions:
  14:../emlib/src/em_cmu.c ****  *
  15:../emlib/src/em_cmu.c ****  * 1. The origin of this software must not be misrepresented; you must not
  16:../emlib/src/em_cmu.c ****  *    claim that you wrote the original software.
  17:../emlib/src/em_cmu.c ****  * 2. Altered source versions must be plainly marked as such, and must not be
  18:../emlib/src/em_cmu.c ****  *    misrepresented as being the original software.
  19:../emlib/src/em_cmu.c ****  * 3. This notice may not be removed or altered from any source distribution.
  20:../emlib/src/em_cmu.c ****  *
  21:../emlib/src/em_cmu.c ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  22:../emlib/src/em_cmu.c ****  * obligation to support this Software. Energy Micro AS is providing the
  23:../emlib/src/em_cmu.c ****  * Software "AS IS", with no express or implied warranties of any kind,
  24:../emlib/src/em_cmu.c ****  * including, but not limited to, any implied warranties of merchantability
  25:../emlib/src/em_cmu.c ****  * or fitness for any particular purpose or warranties against infringement
  26:../emlib/src/em_cmu.c ****  * of any proprietary rights of a third party.
  27:../emlib/src/em_cmu.c ****  *
  28:../emlib/src/em_cmu.c ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  29:../emlib/src/em_cmu.c ****  * special damages, or any other relief, or for any claim by any third party,
  30:../emlib/src/em_cmu.c ****  * arising from your use of this Software.
  31:../emlib/src/em_cmu.c ****  *
  32:../emlib/src/em_cmu.c ****  ******************************************************************************/
  33:../emlib/src/em_cmu.c **** #include "em_cmu.h"
ARM GAS  /tmp/ccnCWsWR.s 			page 2


  34:../emlib/src/em_cmu.c **** #if defined( CMU_PRESENT )
  35:../emlib/src/em_cmu.c **** 
  36:../emlib/src/em_cmu.c **** #include "em_assert.h"
  37:../emlib/src/em_cmu.c **** #include "em_bitband.h"
  38:../emlib/src/em_cmu.c **** #include "em_emu.h"
  39:../emlib/src/em_cmu.c **** 
  40:../emlib/src/em_cmu.c **** /***************************************************************************//**
  41:../emlib/src/em_cmu.c ****  * @addtogroup EM_Library
  42:../emlib/src/em_cmu.c ****  * @{
  43:../emlib/src/em_cmu.c ****  ******************************************************************************/
  44:../emlib/src/em_cmu.c **** 
  45:../emlib/src/em_cmu.c **** /***************************************************************************//**
  46:../emlib/src/em_cmu.c ****  * @addtogroup CMU
  47:../emlib/src/em_cmu.c ****  * @brief Clock management unit (CMU) Peripheral API
  48:../emlib/src/em_cmu.c ****  * @{
  49:../emlib/src/em_cmu.c ****  ******************************************************************************/
  50:../emlib/src/em_cmu.c **** 
  51:../emlib/src/em_cmu.c **** /*******************************************************************************
  52:../emlib/src/em_cmu.c ****  ******************************   DEFINES   ************************************
  53:../emlib/src/em_cmu.c ****  ******************************************************************************/
  54:../emlib/src/em_cmu.c **** 
  55:../emlib/src/em_cmu.c **** /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
  56:../emlib/src/em_cmu.c **** 
  57:../emlib/src/em_cmu.c **** /** Maximum allowed core frequency when using 0 wait states on flash access. */
  58:../emlib/src/em_cmu.c **** #define CMU_MAX_FREQ_0WS    16000000
  59:../emlib/src/em_cmu.c **** /** Maximum allowed core frequency when using 1 wait states on flash access */
  60:../emlib/src/em_cmu.c **** #define CMU_MAX_FREQ_1WS    32000000
  61:../emlib/src/em_cmu.c **** /** Maximum frequency before HFLE needs to be enabled on Giant Gecko */
  62:../emlib/src/em_cmu.c **** #define CMU_MAX_FREQ_HFLE   32000000
  63:../emlib/src/em_cmu.c **** 
  64:../emlib/src/em_cmu.c **** /** Low frequency A group identifier */
  65:../emlib/src/em_cmu.c **** #define CMU_LFA             0
  66:../emlib/src/em_cmu.c **** 
  67:../emlib/src/em_cmu.c **** /** Low frequency B group identifier */
  68:../emlib/src/em_cmu.c **** #define CMU_LFB             1
  69:../emlib/src/em_cmu.c **** 
  70:../emlib/src/em_cmu.c **** /** @endcond */
  71:../emlib/src/em_cmu.c **** 
  72:../emlib/src/em_cmu.c **** /*******************************************************************************
  73:../emlib/src/em_cmu.c ****  **************************   LOCAL FUNCTIONS   ********************************
  74:../emlib/src/em_cmu.c ****  ******************************************************************************/
  75:../emlib/src/em_cmu.c **** 
  76:../emlib/src/em_cmu.c **** /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
  77:../emlib/src/em_cmu.c **** 
  78:../emlib/src/em_cmu.c **** /***************************************************************************//**
  79:../emlib/src/em_cmu.c ****  * @brief
  80:../emlib/src/em_cmu.c ****  *   Configure flash access wait states to most conservative setting for
  81:../emlib/src/em_cmu.c ****  *   this target. Retain SCBTP setting.
  82:../emlib/src/em_cmu.c ****  ******************************************************************************/
  83:../emlib/src/em_cmu.c **** static void CMU_FlashWaitStateMax(void)
  84:../emlib/src/em_cmu.c **** {
  26              		.loc 1 84 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  85:../emlib/src/em_cmu.c ****   uint32_t cfg;
ARM GAS  /tmp/ccnCWsWR.s 			page 3


  86:../emlib/src/em_cmu.c **** 
  87:../emlib/src/em_cmu.c ****   cfg = MSC->READCTRL;
  31              		.loc 1 87 0
  32 0000 0A49     		ldr	r1, .L7
  33 0002 4B68     		ldr	r3, [r1, #4]
  34              	.LVL0:
  88:../emlib/src/em_cmu.c **** 
  89:../emlib/src/em_cmu.c ****   switch(cfg & _MSC_READCTRL_MODE_MASK)
  35              		.loc 1 89 0
  36 0004 03F00702 		and	r2, r3, #7
  37 0008 032A     		cmp	r2, #3
  38 000a 0CD8     		bhi	.L2
  39 000c DFE802F0 		tbb	[pc, r2]
  40              	.L4:
  41 0010 02       		.byte	(.L3-.L4)/2
  42 0011 02       		.byte	(.L3-.L4)/2
  43 0012 07       		.byte	(.L5-.L4)/2
  44 0013 07       		.byte	(.L5-.L4)/2
  45              		.p2align 1
  46              	.L3:
  90:../emlib/src/em_cmu.c ****   {
  91:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS1:
  92:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS0:
  93:../emlib/src/em_cmu.c **** 
  94:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2 )
  95:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS2:
  96:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2;
  97:../emlib/src/em_cmu.c **** #else
  98:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1;
  47              		.loc 1 98 0
  48 0014 23F00703 		bic	r3, r3, #7
  49              	.LVL1:
  50 0018 43F00103 		orr	r3, r3, #1
  51              	.LVL2:
  99:../emlib/src/em_cmu.c **** #endif
 100:../emlib/src/em_cmu.c ****     break;
  52              		.loc 1 100 0
  53 001c 03E0     		b	.L2
  54              	.L5:
 101:../emlib/src/em_cmu.c **** 
 102:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS1SCBTP )
 103:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS1SCBTP:
 104:../emlib/src/em_cmu.c **** #endif
 105:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS0SCBTP )
 106:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS0SCBTP:
 107:../emlib/src/em_cmu.c **** #endif
 108:../emlib/src/em_cmu.c **** 
 109:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP )
 110:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS2SCBTP:
 111:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2SCBTP;
 112:../emlib/src/em_cmu.c **** #elif defined( MSC_READCTRL_MODE_WS1SCBTP )
 113:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1SCBTP;
  55              		.loc 1 113 0
  56 001e 23F00703 		bic	r3, r3, #7
  57              	.LVL3:
  58 0022 43F00303 		orr	r3, r3, #3
  59              	.LVL4:
ARM GAS  /tmp/ccnCWsWR.s 			page 4


  60              	.L2:
 114:../emlib/src/em_cmu.c **** #endif
 115:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP ) || \
 116:../emlib/src/em_cmu.c ****     defined( MSC_READCTRL_MODE_WS1SCBTP ) || defined( MSC_READCTRL_MODE_WS0SCBTP )
 117:../emlib/src/em_cmu.c ****       break;
 118:../emlib/src/em_cmu.c **** #endif
 119:../emlib/src/em_cmu.c ****   }
 120:../emlib/src/em_cmu.c ****   MSC->READCTRL = cfg;
  61              		.loc 1 120 0
  62 0026 4B60     		str	r3, [r1, #4]
  63 0028 7047     		bx	lr
  64              	.L8:
  65 002a 00BF     		.align	2
  66              	.L7:
  67 002c 00000C40 		.word	1074528256
  68              		.cfi_endproc
  69              	.LFE76:
  71              		.section	.text.CMU_FlashWaitStateControl,"ax",%progbits
  72              		.align	1
  73              		.thumb
  74              		.thumb_func
  76              	CMU_FlashWaitStateControl:
  77              	.LFB79:
 121:../emlib/src/em_cmu.c **** }
 122:../emlib/src/em_cmu.c **** 
 123:../emlib/src/em_cmu.c **** 
 124:../emlib/src/em_cmu.c **** /***************************************************************************//**
 125:../emlib/src/em_cmu.c ****  * @brief Convert dividend to prescaler logarithmic value. Only works for even
 126:../emlib/src/em_cmu.c ****  *        numbers equal to 2^n
 127:../emlib/src/em_cmu.c ****  * @param[in] div Unscaled dividend,
 128:../emlib/src/em_cmu.c ****  * @return Base 2 logarithm of input, as used by fixed prescalers
 129:../emlib/src/em_cmu.c ****  ******************************************************************************/
 130:../emlib/src/em_cmu.c **** __STATIC_INLINE uint32_t CMU_DivToLog2(CMU_ClkDiv_TypeDef div)
 131:../emlib/src/em_cmu.c **** {
 132:../emlib/src/em_cmu.c ****   uint32_t log2;
 133:../emlib/src/em_cmu.c **** 
 134:../emlib/src/em_cmu.c ****   /* Prescalers take argument of 32768 or less */
 135:../emlib/src/em_cmu.c ****   EFM_ASSERT((div>0) && (div <= 32768));
 136:../emlib/src/em_cmu.c **** 
 137:../emlib/src/em_cmu.c ****   /* Count leading zeroes and "reverse" result, Cortex-M3 intrinsic */
 138:../emlib/src/em_cmu.c ****   log2 = (31 - __CLZ(div));
 139:../emlib/src/em_cmu.c **** 
 140:../emlib/src/em_cmu.c ****   return log2;
 141:../emlib/src/em_cmu.c **** }
 142:../emlib/src/em_cmu.c **** 
 143:../emlib/src/em_cmu.c **** 
 144:../emlib/src/em_cmu.c **** /***************************************************************************//**
 145:../emlib/src/em_cmu.c ****  * @brief Convert logarithm of 2 prescaler to division factor
 146:../emlib/src/em_cmu.c ****  * @param[in] log2
 147:../emlib/src/em_cmu.c ****  * @return Dividend
 148:../emlib/src/em_cmu.c ****  ******************************************************************************/
 149:../emlib/src/em_cmu.c **** __STATIC_INLINE uint32_t CMU_Log2ToDiv(uint32_t log2)
 150:../emlib/src/em_cmu.c **** {
 151:../emlib/src/em_cmu.c ****   return 1<<log2;
 152:../emlib/src/em_cmu.c **** }
 153:../emlib/src/em_cmu.c **** 
 154:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 5


 155:../emlib/src/em_cmu.c **** /***************************************************************************//**
 156:../emlib/src/em_cmu.c ****  * @brief
 157:../emlib/src/em_cmu.c ****  *   Configure flash access wait states in order to support given HFCORECLK
 158:../emlib/src/em_cmu.c ****  *   frequency.
 159:../emlib/src/em_cmu.c ****  *
 160:../emlib/src/em_cmu.c ****  * @param[in] hfcoreclk
 161:../emlib/src/em_cmu.c ****  *   HFCORECLK frequency that flash access wait states must be configured for.
 162:../emlib/src/em_cmu.c ****  ******************************************************************************/
 163:../emlib/src/em_cmu.c **** static void CMU_FlashWaitStateControl(uint32_t hfcoreclk)
 164:../emlib/src/em_cmu.c **** {
  78              		.loc 1 164 0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              	.LVL5:
 165:../emlib/src/em_cmu.c ****   uint32_t cfg;
 166:../emlib/src/em_cmu.c **** 
 167:../emlib/src/em_cmu.c ****   cfg = MSC->READCTRL;
 168:../emlib/src/em_cmu.c **** 
 169:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2 )
 170:../emlib/src/em_cmu.c ****   if (hfcoreclk > CMU_MAX_FREQ_1WS)
 171:../emlib/src/em_cmu.c ****   {
 172:../emlib/src/em_cmu.c ****     switch(cfg & _MSC_READCTRL_MODE_MASK)
 173:../emlib/src/em_cmu.c ****     {
 174:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0SCBTP:
 175:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1SCBTP:
 176:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2SCBTP;
 177:../emlib/src/em_cmu.c ****       break;
 178:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0:
 179:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1:
 180:../emlib/src/em_cmu.c ****     default:
 181:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2;
 182:../emlib/src/em_cmu.c ****       break;
 183:../emlib/src/em_cmu.c ****     }
 184:../emlib/src/em_cmu.c ****   }
 185:../emlib/src/em_cmu.c **** #endif
 186:../emlib/src/em_cmu.c **** 
 187:../emlib/src/em_cmu.c ****   if ((hfcoreclk > CMU_MAX_FREQ_0WS) && (hfcoreclk <= CMU_MAX_FREQ_1WS))
  83              		.loc 1 187 0
  84 0000 104A     		ldr	r2, .L17
 164:../emlib/src/em_cmu.c **** {
  85              		.loc 1 164 0
  86 0002 10B5     		push	{r4, lr}
  87              		.cfi_def_cfa_offset 8
  88              		.cfi_offset 4, -8
  89              		.cfi_offset 14, -4
  90              		.loc 1 187 0
  91 0004 104C     		ldr	r4, .L17+4
 167:../emlib/src/em_cmu.c ****   cfg = MSC->READCTRL;
  92              		.loc 1 167 0
  93 0006 1149     		ldr	r1, .L17+8
  94              		.loc 1 187 0
  95 0008 0244     		add	r2, r2, r0
  96 000a A242     		cmp	r2, r4
 167:../emlib/src/em_cmu.c ****   cfg = MSC->READCTRL;
  97              		.loc 1 167 0
  98 000c 4B68     		ldr	r3, [r1, #4]
ARM GAS  /tmp/ccnCWsWR.s 			page 6


  99              	.LVL6:
 100              		.loc 1 187 0
 101 000e 0BD8     		bhi	.L10
 188:../emlib/src/em_cmu.c ****   {
 189:../emlib/src/em_cmu.c ****     switch (cfg & _MSC_READCTRL_MODE_MASK)
 102              		.loc 1 189 0
 103 0010 03F00702 		and	r2, r3, #7
 104 0014 023A     		subs	r2, r2, #2
 105 0016 012A     		cmp	r2, #1
 106 0018 23F00703 		bic	r3, r3, #7
 107              	.LVL7:
 190:../emlib/src/em_cmu.c ****     {
 191:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP )
 192:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS2SCBTP:
 193:../emlib/src/em_cmu.c **** #endif
 194:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS1SCBTP ) && defined( MSC_READCTRL_MODE_WS0SCBTP )
 195:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0SCBTP:
 196:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1SCBTP:
 197:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1SCBTP;
 108              		.loc 1 197 0
 109 001c 94BF     		ite	ls
 110 001e 43F00303 		orrls	r3, r3, #3
 111              	.LVL8:
 198:../emlib/src/em_cmu.c **** #endif
 199:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP ) || \
 200:../emlib/src/em_cmu.c ****     defined( MSC_READCTRL_MODE_WS1SCBTP ) || defined( MSC_READCTRL_MODE_WS0SCBTP )
 201:../emlib/src/em_cmu.c ****       break;
 202:../emlib/src/em_cmu.c **** #endif
 203:../emlib/src/em_cmu.c **** 
 204:../emlib/src/em_cmu.c ****     default:
 205:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1;
 112              		.loc 1 205 0
 113 0022 43F00103 		orrhi	r3, r3, #1
 114              	.LVL9:
 206:../emlib/src/em_cmu.c ****       break;
 115              		.loc 1 206 0
 116 0026 0BE0     		b	.L14
 117              	.L10:
 207:../emlib/src/em_cmu.c ****     }
 208:../emlib/src/em_cmu.c ****   }
 209:../emlib/src/em_cmu.c **** 
 210:../emlib/src/em_cmu.c ****   if (hfcoreclk <= CMU_MAX_FREQ_0WS)
 118              		.loc 1 210 0
 119 0028 094A     		ldr	r2, .L17+12
 120 002a 9042     		cmp	r0, r2
 121 002c 08D8     		bhi	.L14
 211:../emlib/src/em_cmu.c ****   {
 212:../emlib/src/em_cmu.c ****     switch (cfg & _MSC_READCTRL_MODE_MASK)
 122              		.loc 1 212 0
 123 002e 03F00702 		and	r2, r3, #7
 124 0032 023A     		subs	r2, r2, #2
 125 0034 012A     		cmp	r2, #1
 126 0036 23F00703 		bic	r3, r3, #7
 127              	.LVL10:
 213:../emlib/src/em_cmu.c ****     {
 214:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP )
 215:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS2SCBTP:
ARM GAS  /tmp/ccnCWsWR.s 			page 7


 216:../emlib/src/em_cmu.c **** #endif
 217:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS0SCBTP )
 218:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1SCBTP:
 219:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0SCBTP:
 220:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS0SCBTP;
 128              		.loc 1 220 0
 129 003a 98BF     		it	ls
 130 003c 43F00203 		orrls	r3, r3, #2
 131              	.LVL11:
 132              	.L14:
 221:../emlib/src/em_cmu.c **** #endif
 222:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP ) || \
 223:../emlib/src/em_cmu.c ****     defined( MSC_READCTRL_MODE_WS1SCBTP ) || defined( MSC_READCTRL_MODE_WS0SCBTP )
 224:../emlib/src/em_cmu.c ****       break;
 225:../emlib/src/em_cmu.c **** #endif
 226:../emlib/src/em_cmu.c **** 
 227:../emlib/src/em_cmu.c ****     default:
 228:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS0;
 229:../emlib/src/em_cmu.c ****       break;
 230:../emlib/src/em_cmu.c ****     }
 231:../emlib/src/em_cmu.c ****   }
 232:../emlib/src/em_cmu.c **** 
 233:../emlib/src/em_cmu.c ****   MSC->READCTRL = cfg;
 133              		.loc 1 233 0
 134 0040 4B60     		str	r3, [r1, #4]
 135 0042 10BD     		pop	{r4, pc}
 136              	.L18:
 137              		.align	2
 138              	.L17:
 139 0044 FFDB0BFF 		.word	-16000001
 140 0048 FF23F400 		.word	15999999
 141 004c 00000C40 		.word	1074528256
 142 0050 0024F400 		.word	16000000
 143              		.cfi_endproc
 144              	.LFE79:
 146              		.section	.text.CMU_DivToLog2,"ax",%progbits
 147              		.align	1
 148              		.thumb
 149              		.thumb_func
 151              	CMU_DivToLog2:
 152              	.LFB77:
 131:../emlib/src/em_cmu.c **** {
 153              		.loc 1 131 0
 154              		.cfi_startproc
 155              		@ args = 0, pretend = 0, frame = 0
 156              		@ frame_needed = 0, uses_anonymous_args = 0
 157              	.LVL12:
 135:../emlib/src/em_cmu.c ****   EFM_ASSERT((div>0) && (div <= 32768));
 158              		.loc 1 135 0
 159 0000 431E     		subs	r3, r0, #1
 160 0002 B3F5004F 		cmp	r3, #32768
 131:../emlib/src/em_cmu.c **** {
 161              		.loc 1 131 0
 162 0006 10B5     		push	{r4, lr}
 163              		.cfi_def_cfa_offset 8
 164              		.cfi_offset 4, -8
 165              		.cfi_offset 14, -4
ARM GAS  /tmp/ccnCWsWR.s 			page 8


 131:../emlib/src/em_cmu.c **** {
 166              		.loc 1 131 0
 167 0008 0446     		mov	r4, r0
 135:../emlib/src/em_cmu.c ****   EFM_ASSERT((div>0) && (div <= 32768));
 168              		.loc 1 135 0
 169 000a 03D3     		bcc	.L20
 135:../emlib/src/em_cmu.c ****   EFM_ASSERT((div>0) && (div <= 32768));
 170              		.loc 1 135 0 is_stmt 0 discriminator 1
 171 000c 0448     		ldr	r0, .L21
 172              	.LVL13:
 173 000e 8721     		movs	r1, #135
 174 0010 FFF7FEFF 		bl	assertEFM
 175              	.LVL14:
 176              	.L20:
 177              	.LBB20:
 178              	.LBB21:
 179              		.file 2 "../CMSIS/Include/core_cmInstr.h"
   1:../CMSIS/Include/core_cmInstr.h **** /**************************************************************************//**
   2:../CMSIS/Include/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:../CMSIS/Include/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:../CMSIS/Include/core_cmInstr.h ****  * @version  V3.20
   5:../CMSIS/Include/core_cmInstr.h ****  * @date     05. March 2013
   6:../CMSIS/Include/core_cmInstr.h ****  *
   7:../CMSIS/Include/core_cmInstr.h ****  * @note
   8:../CMSIS/Include/core_cmInstr.h ****  *
   9:../CMSIS/Include/core_cmInstr.h ****  ******************************************************************************/
  10:../CMSIS/Include/core_cmInstr.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:../CMSIS/Include/core_cmInstr.h **** 
  12:../CMSIS/Include/core_cmInstr.h ****    All rights reserved.
  13:../CMSIS/Include/core_cmInstr.h ****    Redistribution and use in source and binary forms, with or without
  14:../CMSIS/Include/core_cmInstr.h ****    modification, are permitted provided that the following conditions are met:
  15:../CMSIS/Include/core_cmInstr.h ****    - Redistributions of source code must retain the above copyright
  16:../CMSIS/Include/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer.
  17:../CMSIS/Include/core_cmInstr.h ****    - Redistributions in binary form must reproduce the above copyright
  18:../CMSIS/Include/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer in the
  19:../CMSIS/Include/core_cmInstr.h ****      documentation and/or other materials provided with the distribution.
  20:../CMSIS/Include/core_cmInstr.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:../CMSIS/Include/core_cmInstr.h ****      to endorse or promote products derived from this software without
  22:../CMSIS/Include/core_cmInstr.h ****      specific prior written permission.
  23:../CMSIS/Include/core_cmInstr.h ****    *
  24:../CMSIS/Include/core_cmInstr.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:../CMSIS/Include/core_cmInstr.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:../CMSIS/Include/core_cmInstr.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:../CMSIS/Include/core_cmInstr.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:../CMSIS/Include/core_cmInstr.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:../CMSIS/Include/core_cmInstr.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:../CMSIS/Include/core_cmInstr.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:../CMSIS/Include/core_cmInstr.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:../CMSIS/Include/core_cmInstr.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:../CMSIS/Include/core_cmInstr.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:../CMSIS/Include/core_cmInstr.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:../CMSIS/Include/core_cmInstr.h ****    ---------------------------------------------------------------------------*/
  36:../CMSIS/Include/core_cmInstr.h **** 
  37:../CMSIS/Include/core_cmInstr.h **** 
  38:../CMSIS/Include/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  39:../CMSIS/Include/core_cmInstr.h **** #define __CORE_CMINSTR_H
  40:../CMSIS/Include/core_cmInstr.h **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 9


  41:../CMSIS/Include/core_cmInstr.h **** 
  42:../CMSIS/Include/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  43:../CMSIS/Include/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  44:../CMSIS/Include/core_cmInstr.h ****   Access to dedicated instructions
  45:../CMSIS/Include/core_cmInstr.h ****   @{
  46:../CMSIS/Include/core_cmInstr.h **** */
  47:../CMSIS/Include/core_cmInstr.h **** 
  48:../CMSIS/Include/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:../CMSIS/Include/core_cmInstr.h **** /* ARM armcc specific functions */
  50:../CMSIS/Include/core_cmInstr.h **** 
  51:../CMSIS/Include/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  52:../CMSIS/Include/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:../CMSIS/Include/core_cmInstr.h **** #endif
  54:../CMSIS/Include/core_cmInstr.h **** 
  55:../CMSIS/Include/core_cmInstr.h **** 
  56:../CMSIS/Include/core_cmInstr.h **** /** \brief  No Operation
  57:../CMSIS/Include/core_cmInstr.h **** 
  58:../CMSIS/Include/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  59:../CMSIS/Include/core_cmInstr.h ****  */
  60:../CMSIS/Include/core_cmInstr.h **** #define __NOP                             __nop
  61:../CMSIS/Include/core_cmInstr.h **** 
  62:../CMSIS/Include/core_cmInstr.h **** 
  63:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Interrupt
  64:../CMSIS/Include/core_cmInstr.h **** 
  65:../CMSIS/Include/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  66:../CMSIS/Include/core_cmInstr.h ****     until one of a number of events occurs.
  67:../CMSIS/Include/core_cmInstr.h ****  */
  68:../CMSIS/Include/core_cmInstr.h **** #define __WFI                             __wfi
  69:../CMSIS/Include/core_cmInstr.h **** 
  70:../CMSIS/Include/core_cmInstr.h **** 
  71:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Event
  72:../CMSIS/Include/core_cmInstr.h **** 
  73:../CMSIS/Include/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  74:../CMSIS/Include/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  75:../CMSIS/Include/core_cmInstr.h ****  */
  76:../CMSIS/Include/core_cmInstr.h **** #define __WFE                             __wfe
  77:../CMSIS/Include/core_cmInstr.h **** 
  78:../CMSIS/Include/core_cmInstr.h **** 
  79:../CMSIS/Include/core_cmInstr.h **** /** \brief  Send Event
  80:../CMSIS/Include/core_cmInstr.h **** 
  81:../CMSIS/Include/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  82:../CMSIS/Include/core_cmInstr.h ****  */
  83:../CMSIS/Include/core_cmInstr.h **** #define __SEV                             __sev
  84:../CMSIS/Include/core_cmInstr.h **** 
  85:../CMSIS/Include/core_cmInstr.h **** 
  86:../CMSIS/Include/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  87:../CMSIS/Include/core_cmInstr.h **** 
  88:../CMSIS/Include/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  89:../CMSIS/Include/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  90:../CMSIS/Include/core_cmInstr.h ****     memory, after the instruction has been completed.
  91:../CMSIS/Include/core_cmInstr.h ****  */
  92:../CMSIS/Include/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  93:../CMSIS/Include/core_cmInstr.h **** 
  94:../CMSIS/Include/core_cmInstr.h **** 
  95:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  96:../CMSIS/Include/core_cmInstr.h **** 
  97:../CMSIS/Include/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
ARM GAS  /tmp/ccnCWsWR.s 			page 10


  98:../CMSIS/Include/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  99:../CMSIS/Include/core_cmInstr.h ****  */
 100:../CMSIS/Include/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
 101:../CMSIS/Include/core_cmInstr.h **** 
 102:../CMSIS/Include/core_cmInstr.h **** 
 103:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Memory Barrier
 104:../CMSIS/Include/core_cmInstr.h **** 
 105:../CMSIS/Include/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 106:../CMSIS/Include/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 107:../CMSIS/Include/core_cmInstr.h ****  */
 108:../CMSIS/Include/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
 109:../CMSIS/Include/core_cmInstr.h **** 
 110:../CMSIS/Include/core_cmInstr.h **** 
 111:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 112:../CMSIS/Include/core_cmInstr.h **** 
 113:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in integer value.
 114:../CMSIS/Include/core_cmInstr.h **** 
 115:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 116:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 117:../CMSIS/Include/core_cmInstr.h ****  */
 118:../CMSIS/Include/core_cmInstr.h **** #define __REV                             __rev
 119:../CMSIS/Include/core_cmInstr.h **** 
 120:../CMSIS/Include/core_cmInstr.h **** 
 121:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 122:../CMSIS/Include/core_cmInstr.h **** 
 123:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 124:../CMSIS/Include/core_cmInstr.h **** 
 125:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 127:../CMSIS/Include/core_cmInstr.h ****  */
 128:../CMSIS/Include/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 129:../CMSIS/Include/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 130:../CMSIS/Include/core_cmInstr.h **** {
 131:../CMSIS/Include/core_cmInstr.h ****   rev16 r0, r0
 132:../CMSIS/Include/core_cmInstr.h ****   bx lr
 133:../CMSIS/Include/core_cmInstr.h **** }
 134:../CMSIS/Include/core_cmInstr.h **** #endif
 135:../CMSIS/Include/core_cmInstr.h **** 
 136:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 137:../CMSIS/Include/core_cmInstr.h **** 
 138:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 139:../CMSIS/Include/core_cmInstr.h **** 
 140:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 141:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 142:../CMSIS/Include/core_cmInstr.h ****  */
 143:../CMSIS/Include/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 144:../CMSIS/Include/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
 145:../CMSIS/Include/core_cmInstr.h **** {
 146:../CMSIS/Include/core_cmInstr.h ****   revsh r0, r0
 147:../CMSIS/Include/core_cmInstr.h ****   bx lr
 148:../CMSIS/Include/core_cmInstr.h **** }
 149:../CMSIS/Include/core_cmInstr.h **** #endif
 150:../CMSIS/Include/core_cmInstr.h **** 
 151:../CMSIS/Include/core_cmInstr.h **** 
 152:../CMSIS/Include/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 153:../CMSIS/Include/core_cmInstr.h **** 
 154:../CMSIS/Include/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
ARM GAS  /tmp/ccnCWsWR.s 			page 11


 155:../CMSIS/Include/core_cmInstr.h **** 
 156:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to rotate
 157:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 158:../CMSIS/Include/core_cmInstr.h ****     \return               Rotated value
 159:../CMSIS/Include/core_cmInstr.h ****  */
 160:../CMSIS/Include/core_cmInstr.h **** #define __ROR                             __ror
 161:../CMSIS/Include/core_cmInstr.h **** 
 162:../CMSIS/Include/core_cmInstr.h **** 
 163:../CMSIS/Include/core_cmInstr.h **** /** \brief  Breakpoint
 164:../CMSIS/Include/core_cmInstr.h **** 
 165:../CMSIS/Include/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 166:../CMSIS/Include/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 167:../CMSIS/Include/core_cmInstr.h **** 
 168:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 169:../CMSIS/Include/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 170:../CMSIS/Include/core_cmInstr.h ****  */
 171:../CMSIS/Include/core_cmInstr.h **** #define __BKPT(value)                       __breakpoint(value)
 172:../CMSIS/Include/core_cmInstr.h **** 
 173:../CMSIS/Include/core_cmInstr.h **** 
 174:../CMSIS/Include/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 175:../CMSIS/Include/core_cmInstr.h **** 
 176:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse bit order of value
 177:../CMSIS/Include/core_cmInstr.h **** 
 178:../CMSIS/Include/core_cmInstr.h ****     This function reverses the bit order of the given value.
 179:../CMSIS/Include/core_cmInstr.h **** 
 180:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 181:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 182:../CMSIS/Include/core_cmInstr.h ****  */
 183:../CMSIS/Include/core_cmInstr.h **** #define __RBIT                            __rbit
 184:../CMSIS/Include/core_cmInstr.h **** 
 185:../CMSIS/Include/core_cmInstr.h **** 
 186:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 187:../CMSIS/Include/core_cmInstr.h **** 
 188:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 189:../CMSIS/Include/core_cmInstr.h **** 
 190:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 191:../CMSIS/Include/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 192:../CMSIS/Include/core_cmInstr.h ****  */
 193:../CMSIS/Include/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 194:../CMSIS/Include/core_cmInstr.h **** 
 195:../CMSIS/Include/core_cmInstr.h **** 
 196:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 197:../CMSIS/Include/core_cmInstr.h **** 
 198:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 199:../CMSIS/Include/core_cmInstr.h **** 
 200:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 201:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 202:../CMSIS/Include/core_cmInstr.h ****  */
 203:../CMSIS/Include/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 204:../CMSIS/Include/core_cmInstr.h **** 
 205:../CMSIS/Include/core_cmInstr.h **** 
 206:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 207:../CMSIS/Include/core_cmInstr.h **** 
 208:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 209:../CMSIS/Include/core_cmInstr.h **** 
 210:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 211:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
ARM GAS  /tmp/ccnCWsWR.s 			page 12


 212:../CMSIS/Include/core_cmInstr.h ****  */
 213:../CMSIS/Include/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 214:../CMSIS/Include/core_cmInstr.h **** 
 215:../CMSIS/Include/core_cmInstr.h **** 
 216:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 217:../CMSIS/Include/core_cmInstr.h **** 
 218:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 219:../CMSIS/Include/core_cmInstr.h **** 
 220:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 221:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 222:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 223:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 224:../CMSIS/Include/core_cmInstr.h ****  */
 225:../CMSIS/Include/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 226:../CMSIS/Include/core_cmInstr.h **** 
 227:../CMSIS/Include/core_cmInstr.h **** 
 228:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 229:../CMSIS/Include/core_cmInstr.h **** 
 230:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 231:../CMSIS/Include/core_cmInstr.h **** 
 232:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 233:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 234:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 235:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 236:../CMSIS/Include/core_cmInstr.h ****  */
 237:../CMSIS/Include/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 238:../CMSIS/Include/core_cmInstr.h **** 
 239:../CMSIS/Include/core_cmInstr.h **** 
 240:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 241:../CMSIS/Include/core_cmInstr.h **** 
 242:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 243:../CMSIS/Include/core_cmInstr.h **** 
 244:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 245:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 246:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 247:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 248:../CMSIS/Include/core_cmInstr.h ****  */
 249:../CMSIS/Include/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 250:../CMSIS/Include/core_cmInstr.h **** 
 251:../CMSIS/Include/core_cmInstr.h **** 
 252:../CMSIS/Include/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 253:../CMSIS/Include/core_cmInstr.h **** 
 254:../CMSIS/Include/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 255:../CMSIS/Include/core_cmInstr.h **** 
 256:../CMSIS/Include/core_cmInstr.h ****  */
 257:../CMSIS/Include/core_cmInstr.h **** #define __CLREX                           __clrex
 258:../CMSIS/Include/core_cmInstr.h **** 
 259:../CMSIS/Include/core_cmInstr.h **** 
 260:../CMSIS/Include/core_cmInstr.h **** /** \brief  Signed Saturate
 261:../CMSIS/Include/core_cmInstr.h **** 
 262:../CMSIS/Include/core_cmInstr.h ****     This function saturates a signed value.
 263:../CMSIS/Include/core_cmInstr.h **** 
 264:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 265:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 266:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 267:../CMSIS/Include/core_cmInstr.h ****  */
 268:../CMSIS/Include/core_cmInstr.h **** #define __SSAT                            __ssat
ARM GAS  /tmp/ccnCWsWR.s 			page 13


 269:../CMSIS/Include/core_cmInstr.h **** 
 270:../CMSIS/Include/core_cmInstr.h **** 
 271:../CMSIS/Include/core_cmInstr.h **** /** \brief  Unsigned Saturate
 272:../CMSIS/Include/core_cmInstr.h **** 
 273:../CMSIS/Include/core_cmInstr.h ****     This function saturates an unsigned value.
 274:../CMSIS/Include/core_cmInstr.h **** 
 275:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 276:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 277:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 278:../CMSIS/Include/core_cmInstr.h ****  */
 279:../CMSIS/Include/core_cmInstr.h **** #define __USAT                            __usat
 280:../CMSIS/Include/core_cmInstr.h **** 
 281:../CMSIS/Include/core_cmInstr.h **** 
 282:../CMSIS/Include/core_cmInstr.h **** /** \brief  Count leading zeros
 283:../CMSIS/Include/core_cmInstr.h **** 
 284:../CMSIS/Include/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 285:../CMSIS/Include/core_cmInstr.h **** 
 286:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 287:../CMSIS/Include/core_cmInstr.h ****     \return             number of leading zeros in value
 288:../CMSIS/Include/core_cmInstr.h ****  */
 289:../CMSIS/Include/core_cmInstr.h **** #define __CLZ                             __clz
 290:../CMSIS/Include/core_cmInstr.h **** 
 291:../CMSIS/Include/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 292:../CMSIS/Include/core_cmInstr.h **** 
 293:../CMSIS/Include/core_cmInstr.h **** 
 294:../CMSIS/Include/core_cmInstr.h **** 
 295:../CMSIS/Include/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 296:../CMSIS/Include/core_cmInstr.h **** /* IAR iccarm specific functions */
 297:../CMSIS/Include/core_cmInstr.h **** 
 298:../CMSIS/Include/core_cmInstr.h **** #include <cmsis_iar.h>
 299:../CMSIS/Include/core_cmInstr.h **** 
 300:../CMSIS/Include/core_cmInstr.h **** 
 301:../CMSIS/Include/core_cmInstr.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 302:../CMSIS/Include/core_cmInstr.h **** /* TI CCS specific functions */
 303:../CMSIS/Include/core_cmInstr.h **** 
 304:../CMSIS/Include/core_cmInstr.h **** #include <cmsis_ccs.h>
 305:../CMSIS/Include/core_cmInstr.h **** 
 306:../CMSIS/Include/core_cmInstr.h **** 
 307:../CMSIS/Include/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 308:../CMSIS/Include/core_cmInstr.h **** /* GNU gcc specific functions */
 309:../CMSIS/Include/core_cmInstr.h **** 
 310:../CMSIS/Include/core_cmInstr.h **** /* Define macros for porting to both thumb1 and thumb2.
 311:../CMSIS/Include/core_cmInstr.h ****  * For thumb1, use low register (r0-r7), specified by constrant "l"
 312:../CMSIS/Include/core_cmInstr.h ****  * Otherwise, use general registers, specified by constrant "r" */
 313:../CMSIS/Include/core_cmInstr.h **** #if defined (__thumb__) && !defined (__thumb2__)
 314:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 315:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 316:../CMSIS/Include/core_cmInstr.h **** #else
 317:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 318:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 319:../CMSIS/Include/core_cmInstr.h **** #endif
 320:../CMSIS/Include/core_cmInstr.h **** 
 321:../CMSIS/Include/core_cmInstr.h **** /** \brief  No Operation
 322:../CMSIS/Include/core_cmInstr.h **** 
 323:../CMSIS/Include/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 324:../CMSIS/Include/core_cmInstr.h ****  */
 325:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
ARM GAS  /tmp/ccnCWsWR.s 			page 14


 326:../CMSIS/Include/core_cmInstr.h **** {
 327:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("nop");
 328:../CMSIS/Include/core_cmInstr.h **** }
 329:../CMSIS/Include/core_cmInstr.h **** 
 330:../CMSIS/Include/core_cmInstr.h **** 
 331:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Interrupt
 332:../CMSIS/Include/core_cmInstr.h **** 
 333:../CMSIS/Include/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 334:../CMSIS/Include/core_cmInstr.h ****     until one of a number of events occurs.
 335:../CMSIS/Include/core_cmInstr.h ****  */
 336:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
 337:../CMSIS/Include/core_cmInstr.h **** {
 338:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("wfi");
 339:../CMSIS/Include/core_cmInstr.h **** }
 340:../CMSIS/Include/core_cmInstr.h **** 
 341:../CMSIS/Include/core_cmInstr.h **** 
 342:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Event
 343:../CMSIS/Include/core_cmInstr.h **** 
 344:../CMSIS/Include/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 345:../CMSIS/Include/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 346:../CMSIS/Include/core_cmInstr.h ****  */
 347:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
 348:../CMSIS/Include/core_cmInstr.h **** {
 349:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("wfe");
 350:../CMSIS/Include/core_cmInstr.h **** }
 351:../CMSIS/Include/core_cmInstr.h **** 
 352:../CMSIS/Include/core_cmInstr.h **** 
 353:../CMSIS/Include/core_cmInstr.h **** /** \brief  Send Event
 354:../CMSIS/Include/core_cmInstr.h **** 
 355:../CMSIS/Include/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 356:../CMSIS/Include/core_cmInstr.h ****  */
 357:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
 358:../CMSIS/Include/core_cmInstr.h **** {
 359:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("sev");
 360:../CMSIS/Include/core_cmInstr.h **** }
 361:../CMSIS/Include/core_cmInstr.h **** 
 362:../CMSIS/Include/core_cmInstr.h **** 
 363:../CMSIS/Include/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
 364:../CMSIS/Include/core_cmInstr.h **** 
 365:../CMSIS/Include/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
 366:../CMSIS/Include/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
 367:../CMSIS/Include/core_cmInstr.h ****     memory, after the instruction has been completed.
 368:../CMSIS/Include/core_cmInstr.h ****  */
 369:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
 370:../CMSIS/Include/core_cmInstr.h **** {
 371:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("isb");
 372:../CMSIS/Include/core_cmInstr.h **** }
 373:../CMSIS/Include/core_cmInstr.h **** 
 374:../CMSIS/Include/core_cmInstr.h **** 
 375:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
 376:../CMSIS/Include/core_cmInstr.h **** 
 377:../CMSIS/Include/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
 378:../CMSIS/Include/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
 379:../CMSIS/Include/core_cmInstr.h ****  */
 380:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
 381:../CMSIS/Include/core_cmInstr.h **** {
 382:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("dsb");
ARM GAS  /tmp/ccnCWsWR.s 			page 15


 383:../CMSIS/Include/core_cmInstr.h **** }
 384:../CMSIS/Include/core_cmInstr.h **** 
 385:../CMSIS/Include/core_cmInstr.h **** 
 386:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Memory Barrier
 387:../CMSIS/Include/core_cmInstr.h **** 
 388:../CMSIS/Include/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 389:../CMSIS/Include/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 390:../CMSIS/Include/core_cmInstr.h ****  */
 391:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
 392:../CMSIS/Include/core_cmInstr.h **** {
 393:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("dmb");
 394:../CMSIS/Include/core_cmInstr.h **** }
 395:../CMSIS/Include/core_cmInstr.h **** 
 396:../CMSIS/Include/core_cmInstr.h **** 
 397:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 398:../CMSIS/Include/core_cmInstr.h **** 
 399:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in integer value.
 400:../CMSIS/Include/core_cmInstr.h **** 
 401:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 402:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 403:../CMSIS/Include/core_cmInstr.h ****  */
 404:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
 405:../CMSIS/Include/core_cmInstr.h **** {
 406:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 407:../CMSIS/Include/core_cmInstr.h ****   return __builtin_bswap32(value);
 408:../CMSIS/Include/core_cmInstr.h **** #else
 409:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 410:../CMSIS/Include/core_cmInstr.h **** 
 411:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 412:../CMSIS/Include/core_cmInstr.h ****   return(result);
 413:../CMSIS/Include/core_cmInstr.h **** #endif
 414:../CMSIS/Include/core_cmInstr.h **** }
 415:../CMSIS/Include/core_cmInstr.h **** 
 416:../CMSIS/Include/core_cmInstr.h **** 
 417:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 418:../CMSIS/Include/core_cmInstr.h **** 
 419:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 420:../CMSIS/Include/core_cmInstr.h **** 
 421:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 422:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 423:../CMSIS/Include/core_cmInstr.h ****  */
 424:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
 425:../CMSIS/Include/core_cmInstr.h **** {
 426:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 427:../CMSIS/Include/core_cmInstr.h **** 
 428:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 429:../CMSIS/Include/core_cmInstr.h ****   return(result);
 430:../CMSIS/Include/core_cmInstr.h **** }
 431:../CMSIS/Include/core_cmInstr.h **** 
 432:../CMSIS/Include/core_cmInstr.h **** 
 433:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 434:../CMSIS/Include/core_cmInstr.h **** 
 435:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 436:../CMSIS/Include/core_cmInstr.h **** 
 437:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 438:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 439:../CMSIS/Include/core_cmInstr.h ****  */
ARM GAS  /tmp/ccnCWsWR.s 			page 16


 440:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
 441:../CMSIS/Include/core_cmInstr.h **** {
 442:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 443:../CMSIS/Include/core_cmInstr.h ****   return (short)__builtin_bswap16(value);
 444:../CMSIS/Include/core_cmInstr.h **** #else
 445:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 446:../CMSIS/Include/core_cmInstr.h **** 
 447:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 448:../CMSIS/Include/core_cmInstr.h ****   return(result);
 449:../CMSIS/Include/core_cmInstr.h **** #endif
 450:../CMSIS/Include/core_cmInstr.h **** }
 451:../CMSIS/Include/core_cmInstr.h **** 
 452:../CMSIS/Include/core_cmInstr.h **** 
 453:../CMSIS/Include/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 454:../CMSIS/Include/core_cmInstr.h **** 
 455:../CMSIS/Include/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 456:../CMSIS/Include/core_cmInstr.h **** 
 457:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to rotate
 458:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 459:../CMSIS/Include/core_cmInstr.h ****     \return               Rotated value
 460:../CMSIS/Include/core_cmInstr.h ****  */
 461:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 462:../CMSIS/Include/core_cmInstr.h **** {
 463:../CMSIS/Include/core_cmInstr.h ****   return (op1 >> op2) | (op1 << (32 - op2)); 
 464:../CMSIS/Include/core_cmInstr.h **** }
 465:../CMSIS/Include/core_cmInstr.h **** 
 466:../CMSIS/Include/core_cmInstr.h **** 
 467:../CMSIS/Include/core_cmInstr.h **** /** \brief  Breakpoint
 468:../CMSIS/Include/core_cmInstr.h **** 
 469:../CMSIS/Include/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 470:../CMSIS/Include/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 471:../CMSIS/Include/core_cmInstr.h **** 
 472:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 473:../CMSIS/Include/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 474:../CMSIS/Include/core_cmInstr.h ****  */
 475:../CMSIS/Include/core_cmInstr.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 476:../CMSIS/Include/core_cmInstr.h **** 
 477:../CMSIS/Include/core_cmInstr.h **** 
 478:../CMSIS/Include/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 479:../CMSIS/Include/core_cmInstr.h **** 
 480:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse bit order of value
 481:../CMSIS/Include/core_cmInstr.h **** 
 482:../CMSIS/Include/core_cmInstr.h ****     This function reverses the bit order of the given value.
 483:../CMSIS/Include/core_cmInstr.h **** 
 484:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 485:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 486:../CMSIS/Include/core_cmInstr.h ****  */
 487:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
 488:../CMSIS/Include/core_cmInstr.h **** {
 489:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 490:../CMSIS/Include/core_cmInstr.h **** 
 491:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 492:../CMSIS/Include/core_cmInstr.h ****    return(result);
 493:../CMSIS/Include/core_cmInstr.h **** }
 494:../CMSIS/Include/core_cmInstr.h **** 
 495:../CMSIS/Include/core_cmInstr.h **** 
 496:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
ARM GAS  /tmp/ccnCWsWR.s 			page 17


 497:../CMSIS/Include/core_cmInstr.h **** 
 498:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 499:../CMSIS/Include/core_cmInstr.h **** 
 500:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 501:../CMSIS/Include/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 502:../CMSIS/Include/core_cmInstr.h ****  */
 503:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
 504:../CMSIS/Include/core_cmInstr.h **** {
 505:../CMSIS/Include/core_cmInstr.h ****     uint32_t result;
 506:../CMSIS/Include/core_cmInstr.h **** 
 507:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 508:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 509:../CMSIS/Include/core_cmInstr.h **** #else
 510:../CMSIS/Include/core_cmInstr.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 511:../CMSIS/Include/core_cmInstr.h ****        accepted by assembler. So has to use following less efficient pattern.
 512:../CMSIS/Include/core_cmInstr.h ****     */
 513:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 514:../CMSIS/Include/core_cmInstr.h **** #endif
 515:../CMSIS/Include/core_cmInstr.h ****    return(result);
 516:../CMSIS/Include/core_cmInstr.h **** }
 517:../CMSIS/Include/core_cmInstr.h **** 
 518:../CMSIS/Include/core_cmInstr.h **** 
 519:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 520:../CMSIS/Include/core_cmInstr.h **** 
 521:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 522:../CMSIS/Include/core_cmInstr.h **** 
 523:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 524:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 525:../CMSIS/Include/core_cmInstr.h ****  */
 526:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
 527:../CMSIS/Include/core_cmInstr.h **** {
 528:../CMSIS/Include/core_cmInstr.h ****     uint32_t result;
 529:../CMSIS/Include/core_cmInstr.h **** 
 530:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 531:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
 532:../CMSIS/Include/core_cmInstr.h **** #else
 533:../CMSIS/Include/core_cmInstr.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 534:../CMSIS/Include/core_cmInstr.h ****        accepted by assembler. So has to use following less efficient pattern.
 535:../CMSIS/Include/core_cmInstr.h ****     */
 536:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 537:../CMSIS/Include/core_cmInstr.h **** #endif
 538:../CMSIS/Include/core_cmInstr.h ****    return(result);
 539:../CMSIS/Include/core_cmInstr.h **** }
 540:../CMSIS/Include/core_cmInstr.h **** 
 541:../CMSIS/Include/core_cmInstr.h **** 
 542:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 543:../CMSIS/Include/core_cmInstr.h **** 
 544:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 545:../CMSIS/Include/core_cmInstr.h **** 
 546:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 547:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 548:../CMSIS/Include/core_cmInstr.h ****  */
 549:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
 550:../CMSIS/Include/core_cmInstr.h **** {
 551:../CMSIS/Include/core_cmInstr.h ****     uint32_t result;
 552:../CMSIS/Include/core_cmInstr.h **** 
 553:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
ARM GAS  /tmp/ccnCWsWR.s 			page 18


 554:../CMSIS/Include/core_cmInstr.h ****    return(result);
 555:../CMSIS/Include/core_cmInstr.h **** }
 556:../CMSIS/Include/core_cmInstr.h **** 
 557:../CMSIS/Include/core_cmInstr.h **** 
 558:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 559:../CMSIS/Include/core_cmInstr.h **** 
 560:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 561:../CMSIS/Include/core_cmInstr.h **** 
 562:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 563:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 564:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 565:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 566:../CMSIS/Include/core_cmInstr.h ****  */
 567:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_
 568:../CMSIS/Include/core_cmInstr.h **** {
 569:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 570:../CMSIS/Include/core_cmInstr.h **** 
 571:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 572:../CMSIS/Include/core_cmInstr.h ****    return(result);
 573:../CMSIS/Include/core_cmInstr.h **** }
 574:../CMSIS/Include/core_cmInstr.h **** 
 575:../CMSIS/Include/core_cmInstr.h **** 
 576:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 577:../CMSIS/Include/core_cmInstr.h **** 
 578:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 579:../CMSIS/Include/core_cmInstr.h **** 
 580:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 581:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 582:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 583:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 584:../CMSIS/Include/core_cmInstr.h ****  */
 585:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint1
 586:../CMSIS/Include/core_cmInstr.h **** {
 587:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 588:../CMSIS/Include/core_cmInstr.h **** 
 589:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 590:../CMSIS/Include/core_cmInstr.h ****    return(result);
 591:../CMSIS/Include/core_cmInstr.h **** }
 592:../CMSIS/Include/core_cmInstr.h **** 
 593:../CMSIS/Include/core_cmInstr.h **** 
 594:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 595:../CMSIS/Include/core_cmInstr.h **** 
 596:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 597:../CMSIS/Include/core_cmInstr.h **** 
 598:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 599:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 600:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 601:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 602:../CMSIS/Include/core_cmInstr.h ****  */
 603:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint3
 604:../CMSIS/Include/core_cmInstr.h **** {
 605:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 606:../CMSIS/Include/core_cmInstr.h **** 
 607:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 608:../CMSIS/Include/core_cmInstr.h ****    return(result);
 609:../CMSIS/Include/core_cmInstr.h **** }
 610:../CMSIS/Include/core_cmInstr.h **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 19


 611:../CMSIS/Include/core_cmInstr.h **** 
 612:../CMSIS/Include/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 613:../CMSIS/Include/core_cmInstr.h **** 
 614:../CMSIS/Include/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 615:../CMSIS/Include/core_cmInstr.h **** 
 616:../CMSIS/Include/core_cmInstr.h ****  */
 617:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
 618:../CMSIS/Include/core_cmInstr.h **** {
 619:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("clrex" ::: "memory");
 620:../CMSIS/Include/core_cmInstr.h **** }
 621:../CMSIS/Include/core_cmInstr.h **** 
 622:../CMSIS/Include/core_cmInstr.h **** 
 623:../CMSIS/Include/core_cmInstr.h **** /** \brief  Signed Saturate
 624:../CMSIS/Include/core_cmInstr.h **** 
 625:../CMSIS/Include/core_cmInstr.h ****     This function saturates a signed value.
 626:../CMSIS/Include/core_cmInstr.h **** 
 627:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 628:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 629:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 630:../CMSIS/Include/core_cmInstr.h ****  */
 631:../CMSIS/Include/core_cmInstr.h **** #define __SSAT(ARG1,ARG2) \
 632:../CMSIS/Include/core_cmInstr.h **** ({                          \
 633:../CMSIS/Include/core_cmInstr.h ****   uint32_t __RES, __ARG1 = (ARG1); \
 634:../CMSIS/Include/core_cmInstr.h ****   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
 635:../CMSIS/Include/core_cmInstr.h ****   __RES; \
 636:../CMSIS/Include/core_cmInstr.h ****  })
 637:../CMSIS/Include/core_cmInstr.h **** 
 638:../CMSIS/Include/core_cmInstr.h **** 
 639:../CMSIS/Include/core_cmInstr.h **** /** \brief  Unsigned Saturate
 640:../CMSIS/Include/core_cmInstr.h **** 
 641:../CMSIS/Include/core_cmInstr.h ****     This function saturates an unsigned value.
 642:../CMSIS/Include/core_cmInstr.h **** 
 643:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 644:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 645:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 646:../CMSIS/Include/core_cmInstr.h ****  */
 647:../CMSIS/Include/core_cmInstr.h **** #define __USAT(ARG1,ARG2) \
 648:../CMSIS/Include/core_cmInstr.h **** ({                          \
 649:../CMSIS/Include/core_cmInstr.h ****   uint32_t __RES, __ARG1 = (ARG1); \
 650:../CMSIS/Include/core_cmInstr.h ****   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
 651:../CMSIS/Include/core_cmInstr.h ****   __RES; \
 652:../CMSIS/Include/core_cmInstr.h ****  })
 653:../CMSIS/Include/core_cmInstr.h **** 
 654:../CMSIS/Include/core_cmInstr.h **** 
 655:../CMSIS/Include/core_cmInstr.h **** /** \brief  Count leading zeros
 656:../CMSIS/Include/core_cmInstr.h **** 
 657:../CMSIS/Include/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 658:../CMSIS/Include/core_cmInstr.h **** 
 659:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 660:../CMSIS/Include/core_cmInstr.h ****     \return             number of leading zeros in value
 661:../CMSIS/Include/core_cmInstr.h ****  */
 662:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
 663:../CMSIS/Include/core_cmInstr.h **** {
 664:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 665:../CMSIS/Include/core_cmInstr.h **** 
 666:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 180              		.loc 2 666 0 is_stmt 1
ARM GAS  /tmp/ccnCWsWR.s 			page 20


 181              	@ 666 "../CMSIS/Include/core_cmInstr.h" 1
 182 0014 B4FA84F4 		clz r4, r4
 183              	@ 0 "" 2
 184              	.LVL15:
 185              		.thumb
 186 0018 E0B2     		uxtb	r0, r4
 187              	.LBE21:
 188              	.LBE20:
 141:../emlib/src/em_cmu.c **** }
 189              		.loc 1 141 0
 190 001a C0F11F00 		rsb	r0, r0, #31
 191 001e 10BD     		pop	{r4, pc}
 192              	.LVL16:
 193              	.L22:
 194              		.align	2
 195              	.L21:
 196 0020 00000000 		.word	.LC0
 197              		.cfi_endproc
 198              	.LFE77:
 200              		.section	.text.CMU_Sync,"ax",%progbits
 201              		.align	1
 202              		.thumb
 203              		.thumb_func
 205              	CMU_Sync:
 206              	.LFB83:
 234:../emlib/src/em_cmu.c **** }
 235:../emlib/src/em_cmu.c **** 
 236:../emlib/src/em_cmu.c **** 
 237:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
 238:../emlib/src/em_cmu.c **** /***************************************************************************//**
 239:../emlib/src/em_cmu.c ****  * @brief
 240:../emlib/src/em_cmu.c ****  *   Get the USBC frequency
 241:../emlib/src/em_cmu.c ****  *
 242:../emlib/src/em_cmu.c ****  * @return
 243:../emlib/src/em_cmu.c ****  *   USBC frequency in Hz
 244:../emlib/src/em_cmu.c ****  ******************************************************************************/
 245:../emlib/src/em_cmu.c **** static uint32_t CMU_USBCClkGet(void)
 246:../emlib/src/em_cmu.c **** {
 247:../emlib/src/em_cmu.c ****   uint32_t ret;
 248:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef clk;
 249:../emlib/src/em_cmu.c **** 
 250:../emlib/src/em_cmu.c ****   /* Get selected clock source */
 251:../emlib/src/em_cmu.c ****   clk = CMU_ClockSelectGet(cmuClock_USBC);
 252:../emlib/src/em_cmu.c **** 
 253:../emlib/src/em_cmu.c ****   switch(clk)
 254:../emlib/src/em_cmu.c ****   {
 255:../emlib/src/em_cmu.c ****   case cmuSelect_LFXO:
 256:../emlib/src/em_cmu.c ****     ret = SystemLFXOClockGet();
 257:../emlib/src/em_cmu.c ****     break;
 258:../emlib/src/em_cmu.c ****   case cmuSelect_LFRCO:
 259:../emlib/src/em_cmu.c ****     ret = SystemLFRCOClockGet();
 260:../emlib/src/em_cmu.c ****     break;
 261:../emlib/src/em_cmu.c ****   case cmuSelect_HFCLK:
 262:../emlib/src/em_cmu.c ****     ret = SystemHFClockGet();
 263:../emlib/src/em_cmu.c ****     break;
 264:../emlib/src/em_cmu.c ****   default:
 265:../emlib/src/em_cmu.c ****     /* Clock is not enabled */
ARM GAS  /tmp/ccnCWsWR.s 			page 21


 266:../emlib/src/em_cmu.c ****     ret = 0;
 267:../emlib/src/em_cmu.c ****     break;
 268:../emlib/src/em_cmu.c ****   }
 269:../emlib/src/em_cmu.c ****   return ret;
 270:../emlib/src/em_cmu.c **** }
 271:../emlib/src/em_cmu.c **** #endif
 272:../emlib/src/em_cmu.c **** 
 273:../emlib/src/em_cmu.c **** 
 274:../emlib/src/em_cmu.c **** /***************************************************************************//**
 275:../emlib/src/em_cmu.c ****  * @brief
 276:../emlib/src/em_cmu.c ****  *   Get the AUX clock frequency. Used by MSC flash programming and LESENSE,
 277:../emlib/src/em_cmu.c ****  *   by default also as debug clock.
 278:../emlib/src/em_cmu.c ****  *
 279:../emlib/src/em_cmu.c ****  * @return
 280:../emlib/src/em_cmu.c ****  *   AUX Frequency in Hz
 281:../emlib/src/em_cmu.c ****  ******************************************************************************/
 282:../emlib/src/em_cmu.c **** static uint32_t CMU_AUXClkGet(void)
 283:../emlib/src/em_cmu.c **** {
 284:../emlib/src/em_cmu.c ****   uint32_t ret;
 285:../emlib/src/em_cmu.c **** 
 286:../emlib/src/em_cmu.c **** #if defined(_EFM32_GECKO_FAMILY)
 287:../emlib/src/em_cmu.c ****   /* Gecko has a fixed 14Mhz AUXHFRCO clock */
 288:../emlib/src/em_cmu.c ****   ret = 14000000;
 289:../emlib/src/em_cmu.c **** #else
 290:../emlib/src/em_cmu.c ****   switch(CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_BAND_MASK)
 291:../emlib/src/em_cmu.c ****   {
 292:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_1MHZ:
 293:../emlib/src/em_cmu.c ****     ret = 1000000;
 294:../emlib/src/em_cmu.c ****     break;
 295:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_7MHZ:
 296:../emlib/src/em_cmu.c ****     ret = 7000000;
 297:../emlib/src/em_cmu.c ****     break;
 298:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_11MHZ:
 299:../emlib/src/em_cmu.c ****     ret = 11000000;
 300:../emlib/src/em_cmu.c ****     break;
 301:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_14MHZ:
 302:../emlib/src/em_cmu.c ****     ret = 14000000;
 303:../emlib/src/em_cmu.c ****     break;
 304:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_21MHZ:
 305:../emlib/src/em_cmu.c ****     ret = 21000000;
 306:../emlib/src/em_cmu.c ****     break;
 307:../emlib/src/em_cmu.c **** #if defined( _CMU_AUXHFRCOCTRL_BAND_28MHZ )
 308:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_28MHZ:
 309:../emlib/src/em_cmu.c ****     ret = 28000000;
 310:../emlib/src/em_cmu.c ****     break;
 311:../emlib/src/em_cmu.c **** #endif
 312:../emlib/src/em_cmu.c ****   default:
 313:../emlib/src/em_cmu.c ****     ret = 0;
 314:../emlib/src/em_cmu.c ****     break;
 315:../emlib/src/em_cmu.c ****   }
 316:../emlib/src/em_cmu.c **** #endif
 317:../emlib/src/em_cmu.c ****   return ret;
 318:../emlib/src/em_cmu.c **** }
 319:../emlib/src/em_cmu.c **** 
 320:../emlib/src/em_cmu.c **** 
 321:../emlib/src/em_cmu.c **** /***************************************************************************//**
 322:../emlib/src/em_cmu.c ****  * @brief
ARM GAS  /tmp/ccnCWsWR.s 			page 22


 323:../emlib/src/em_cmu.c ****  *   Get the Debug Trace clock frequency
 324:../emlib/src/em_cmu.c ****  *
 325:../emlib/src/em_cmu.c ****  * @return
 326:../emlib/src/em_cmu.c ****  *   Debug Trace frequency in Hz
 327:../emlib/src/em_cmu.c ****  ******************************************************************************/
 328:../emlib/src/em_cmu.c **** static uint32_t CMU_DBGClkGet(void)
 329:../emlib/src/em_cmu.c **** {
 330:../emlib/src/em_cmu.c ****   uint32_t ret;
 331:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef clk;
 332:../emlib/src/em_cmu.c **** 
 333:../emlib/src/em_cmu.c ****   /* Get selected clock source */
 334:../emlib/src/em_cmu.c ****   clk = CMU_ClockSelectGet(cmuClock_DBG);
 335:../emlib/src/em_cmu.c **** 
 336:../emlib/src/em_cmu.c ****   switch(clk)
 337:../emlib/src/em_cmu.c ****   {
 338:../emlib/src/em_cmu.c ****   case cmuSelect_HFCLK:
 339:../emlib/src/em_cmu.c ****     ret = SystemHFClockGet();
 340:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
 341:../emlib/src/em_cmu.c ****     /* Giant Gecko has an additional divider, not used by USBC */
 342:../emlib/src/em_cmu.c ****     ret = ret / (1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
 343:../emlib/src/em_cmu.c ****                       _CMU_CTRL_HFCLKDIV_SHIFT));
 344:../emlib/src/em_cmu.c **** #endif
 345:../emlib/src/em_cmu.c ****     break;
 346:../emlib/src/em_cmu.c **** 
 347:../emlib/src/em_cmu.c ****   case cmuSelect_AUXHFRCO:
 348:../emlib/src/em_cmu.c ****     ret = CMU_AUXClkGet();
 349:../emlib/src/em_cmu.c ****     break;
 350:../emlib/src/em_cmu.c **** 
 351:../emlib/src/em_cmu.c ****   default:
 352:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 353:../emlib/src/em_cmu.c ****     ret = 0;
 354:../emlib/src/em_cmu.c ****     break;
 355:../emlib/src/em_cmu.c ****   }
 356:../emlib/src/em_cmu.c ****   return ret;
 357:../emlib/src/em_cmu.c **** }
 358:../emlib/src/em_cmu.c **** 
 359:../emlib/src/em_cmu.c **** 
 360:../emlib/src/em_cmu.c **** /***************************************************************************//**
 361:../emlib/src/em_cmu.c ****  * @brief
 362:../emlib/src/em_cmu.c ****  *   Get the LFnCLK frequency based on current configuration.
 363:../emlib/src/em_cmu.c ****  *
 364:../emlib/src/em_cmu.c ****  * @param[in] lfClkBranch
 365:../emlib/src/em_cmu.c ****  *   LF branch, 0 = LFA, 1 = LFB, ...
 366:../emlib/src/em_cmu.c ****  *
 367:../emlib/src/em_cmu.c ****  * @return
 368:../emlib/src/em_cmu.c ****  *   The LFnCLK frequency in Hz. If no LFnCLK is selected (disabled), 0 is
 369:../emlib/src/em_cmu.c ****  *   returned.
 370:../emlib/src/em_cmu.c ****  ******************************************************************************/
 371:../emlib/src/em_cmu.c **** static uint32_t CMU_LFClkGet(unsigned int lfClkBranch)
 372:../emlib/src/em_cmu.c **** {
 373:../emlib/src/em_cmu.c ****   uint32_t ret;
 374:../emlib/src/em_cmu.c **** 
 375:../emlib/src/em_cmu.c ****   EFM_ASSERT(lfClkBranch == CMU_LFA || lfClkBranch == CMU_LFB);
 376:../emlib/src/em_cmu.c **** 
 377:../emlib/src/em_cmu.c ****   switch ((CMU->LFCLKSEL >> (lfClkBranch * 2)) & 0x3)
 378:../emlib/src/em_cmu.c ****   {
 379:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_LFRCO:
ARM GAS  /tmp/ccnCWsWR.s 			page 23


 380:../emlib/src/em_cmu.c ****     ret = SystemLFRCOClockGet();
 381:../emlib/src/em_cmu.c ****     break;
 382:../emlib/src/em_cmu.c **** 
 383:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_LFXO:
 384:../emlib/src/em_cmu.c ****     ret = SystemLFXOClockGet();
 385:../emlib/src/em_cmu.c ****     break;
 386:../emlib/src/em_cmu.c **** 
 387:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
 388:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
 389:../emlib/src/em_cmu.c ****     /* Giant Gecko can use a /4 divider (and must if >32MHz) or HFLE is set */
 390:../emlib/src/em_cmu.c ****     if(((CMU->HFCORECLKDIV & _CMU_HFCORECLKDIV_HFCORECLKLEDIV_MASK) == CMU_HFCORECLKDIV_HFCORECLKLE
 391:../emlib/src/em_cmu.c ****        (CMU->CTRL & CMU_CTRL_HFLE))
 392:../emlib/src/em_cmu.c ****     {
 393:../emlib/src/em_cmu.c ****       ret = SystemCoreClockGet() / 4;
 394:../emlib/src/em_cmu.c ****     }
 395:../emlib/src/em_cmu.c ****     else
 396:../emlib/src/em_cmu.c ****     {
 397:../emlib/src/em_cmu.c ****       ret = SystemCoreClockGet() / 2;
 398:../emlib/src/em_cmu.c ****     }
 399:../emlib/src/em_cmu.c **** #else
 400:../emlib/src/em_cmu.c ****     ret = SystemCoreClockGet() / 2;
 401:../emlib/src/em_cmu.c **** #endif
 402:../emlib/src/em_cmu.c ****     break;
 403:../emlib/src/em_cmu.c **** 
 404:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_DISABLED:
 405:../emlib/src/em_cmu.c **** #if defined( CMU_LFCLKSEL_LFAE )
 406:../emlib/src/em_cmu.c ****     /* Check LF Extended bit setting for ULFRCO clock */
 407:../emlib/src/em_cmu.c ****     if(CMU->LFCLKSEL >> (_CMU_LFCLKSEL_LFAE_SHIFT + lfClkBranch * 4))
 408:../emlib/src/em_cmu.c ****     {
 409:../emlib/src/em_cmu.c ****       ret = SystemULFRCOClockGet();
 410:../emlib/src/em_cmu.c ****     }
 411:../emlib/src/em_cmu.c ****     else
 412:../emlib/src/em_cmu.c ****     {
 413:../emlib/src/em_cmu.c ****       ret = 0;
 414:../emlib/src/em_cmu.c ****     }
 415:../emlib/src/em_cmu.c **** #else
 416:../emlib/src/em_cmu.c ****     ret = 0;
 417:../emlib/src/em_cmu.c **** #endif
 418:../emlib/src/em_cmu.c ****     break;
 419:../emlib/src/em_cmu.c **** 
 420:../emlib/src/em_cmu.c ****   default:
 421:../emlib/src/em_cmu.c ****     ret = 0;
 422:../emlib/src/em_cmu.c ****     break;
 423:../emlib/src/em_cmu.c ****   }
 424:../emlib/src/em_cmu.c **** 
 425:../emlib/src/em_cmu.c ****   return ret;
 426:../emlib/src/em_cmu.c **** }
 427:../emlib/src/em_cmu.c **** 
 428:../emlib/src/em_cmu.c **** 
 429:../emlib/src/em_cmu.c **** /***************************************************************************//**
 430:../emlib/src/em_cmu.c ****  * @brief
 431:../emlib/src/em_cmu.c ****  *   Wait for ongoing sync of register(s) to low frequency domain to complete.
 432:../emlib/src/em_cmu.c ****  *
 433:../emlib/src/em_cmu.c ****  * @param[in] mask
 434:../emlib/src/em_cmu.c ****  *   Bitmask corresponding to SYNCBUSY register defined bits, indicating
 435:../emlib/src/em_cmu.c ****  *   registers that must complete any ongoing synchronization.
 436:../emlib/src/em_cmu.c ****  ******************************************************************************/
ARM GAS  /tmp/ccnCWsWR.s 			page 24


 437:../emlib/src/em_cmu.c **** __STATIC_INLINE void CMU_Sync(uint32_t mask)
 438:../emlib/src/em_cmu.c **** {
 207              		.loc 1 438 0
 208              		.cfi_startproc
 209              		@ args = 0, pretend = 0, frame = 0
 210              		@ frame_needed = 0, uses_anonymous_args = 0
 211              		@ link register save eliminated.
 212              	.LVL17:
 439:../emlib/src/em_cmu.c ****   /* Avoid deadlock if modifying the same register twice when freeze mode is */
 440:../emlib/src/em_cmu.c ****   /* activated. */
 441:../emlib/src/em_cmu.c ****   if (CMU->FREEZE & CMU_FREEZE_REGFREEZE)
 213              		.loc 1 441 0
 214 0000 034B     		ldr	r3, .L29
 215 0002 5A6D     		ldr	r2, [r3, #84]
 216 0004 D207     		lsls	r2, r2, #31
 217 0006 02D4     		bmi	.L23
 218              	.L25:
 219              	.LBB24:
 220              	.LBB25:
 442:../emlib/src/em_cmu.c ****     return;
 443:../emlib/src/em_cmu.c **** 
 444:../emlib/src/em_cmu.c ****   /* Wait for any pending previous write operation to have been completed */
 445:../emlib/src/em_cmu.c ****   /* in low frequency domain */
 446:../emlib/src/em_cmu.c ****   while (CMU->SYNCBUSY & mask)
 221              		.loc 1 446 0
 222 0008 1A6D     		ldr	r2, [r3, #80]
 223 000a 1042     		tst	r0, r2
 224 000c FCD1     		bne	.L25
 225              	.L23:
 226 000e 7047     		bx	lr
 227              	.L30:
 228              		.align	2
 229              	.L29:
 230 0010 00800C40 		.word	1074561024
 231              	.LBE25:
 232              	.LBE24:
 233              		.cfi_endproc
 234              	.LFE83:
 236              		.section	.text.CMU_LFClkGet,"ax",%progbits
 237              		.align	1
 238              		.thumb
 239              		.thumb_func
 241              	CMU_LFClkGet:
 242              	.LFB82:
 372:../emlib/src/em_cmu.c **** {
 243              		.loc 1 372 0
 244              		.cfi_startproc
 245              		@ args = 0, pretend = 0, frame = 0
 246              		@ frame_needed = 0, uses_anonymous_args = 0
 247              	.LVL18:
 375:../emlib/src/em_cmu.c ****   EFM_ASSERT(lfClkBranch == CMU_LFA || lfClkBranch == CMU_LFB);
 248              		.loc 1 375 0
 249 0000 0128     		cmp	r0, #1
 372:../emlib/src/em_cmu.c **** {
 250              		.loc 1 372 0
 251 0002 10B5     		push	{r4, lr}
 252              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccnCWsWR.s 			page 25


 253              		.cfi_offset 4, -8
 254              		.cfi_offset 14, -4
 372:../emlib/src/em_cmu.c **** {
 255              		.loc 1 372 0
 256 0004 0446     		mov	r4, r0
 375:../emlib/src/em_cmu.c ****   EFM_ASSERT(lfClkBranch == CMU_LFA || lfClkBranch == CMU_LFB);
 257              		.loc 1 375 0
 258 0006 04D9     		bls	.L32
 375:../emlib/src/em_cmu.c ****   EFM_ASSERT(lfClkBranch == CMU_LFA || lfClkBranch == CMU_LFB);
 259              		.loc 1 375 0 is_stmt 0 discriminator 1
 260 0008 0F48     		ldr	r0, .L39
 261              	.LVL19:
 262 000a 40F27711 		movw	r1, #375
 263 000e FFF7FEFF 		bl	assertEFM
 264              	.LVL20:
 265              	.L32:
 377:../emlib/src/em_cmu.c ****   switch ((CMU->LFCLKSEL >> (lfClkBranch * 2)) & 0x3)
 266              		.loc 1 377 0 is_stmt 1
 267 0012 0E4B     		ldr	r3, .L39+4
 268 0014 6400     		lsls	r4, r4, #1
 269              	.LVL21:
 270 0016 986A     		ldr	r0, [r3, #40]
 271 0018 E040     		lsrs	r0, r0, r4
 272 001a 00F00300 		and	r0, r0, #3
 273 001e 0228     		cmp	r0, #2
 274 0020 07D0     		beq	.L34
 275 0022 0328     		cmp	r0, #3
 276 0024 09D0     		beq	.L35
 277 0026 0128     		cmp	r0, #1
 278 0028 0BD1     		bne	.L38
 426:../emlib/src/em_cmu.c **** }
 279              		.loc 1 426 0
 280 002a BDE81040 		pop	{r4, lr}
 380:../emlib/src/em_cmu.c ****     ret = SystemLFRCOClockGet();
 281              		.loc 1 380 0
 282 002e FFF7FEBF 		b	SystemLFRCOClockGet
 283              	.LVL22:
 284              	.L34:
 426:../emlib/src/em_cmu.c **** }
 285              		.loc 1 426 0
 286 0032 BDE81040 		pop	{r4, lr}
 384:../emlib/src/em_cmu.c ****     ret = SystemLFXOClockGet();
 287              		.loc 1 384 0
 288 0036 FFF7FEBF 		b	SystemLFXOClockGet
 289              	.LVL23:
 290              	.L35:
 291              	.LBB28:
 292              	.LBB29:
 400:../emlib/src/em_cmu.c ****     ret = SystemCoreClockGet() / 2;
 293              		.loc 1 400 0
 294 003a FFF7FEFF 		bl	SystemCoreClockGet
 295              	.LVL24:
 296 003e 4008     		lsrs	r0, r0, #1
 297              	.LVL25:
 298 0040 10BD     		pop	{r4, pc}
 299              	.LVL26:
 300              	.L38:
ARM GAS  /tmp/ccnCWsWR.s 			page 26


 301              	.LBE29:
 302              	.LBE28:
 416:../emlib/src/em_cmu.c ****     ret = 0;
 303              		.loc 1 416 0
 304 0042 0020     		movs	r0, #0
 305              	.LVL27:
 426:../emlib/src/em_cmu.c **** }
 306              		.loc 1 426 0
 307 0044 10BD     		pop	{r4, pc}
 308              	.L40:
 309 0046 00BF     		.align	2
 310              	.L39:
 311 0048 00000000 		.word	.LC0
 312 004c 00800C40 		.word	1074561024
 313              		.cfi_endproc
 314              	.LFE82:
 316              		.section	.text.CMU_Calibrate,"ax",%progbits
 317              		.align	1
 318              		.global	CMU_Calibrate
 319              		.thumb
 320              		.thumb_func
 322              	CMU_Calibrate:
 323              	.LFB84:
 447:../emlib/src/em_cmu.c ****     ;
 448:../emlib/src/em_cmu.c **** }
 449:../emlib/src/em_cmu.c **** 
 450:../emlib/src/em_cmu.c **** 
 451:../emlib/src/em_cmu.c **** /** @endcond */
 452:../emlib/src/em_cmu.c **** 
 453:../emlib/src/em_cmu.c **** /*******************************************************************************
 454:../emlib/src/em_cmu.c ****  **************************   GLOBAL FUNCTIONS   *******************************
 455:../emlib/src/em_cmu.c ****  ******************************************************************************/
 456:../emlib/src/em_cmu.c **** 
 457:../emlib/src/em_cmu.c **** /***************************************************************************//**
 458:../emlib/src/em_cmu.c ****  * @brief
 459:../emlib/src/em_cmu.c ****  *   Calibrate clock.
 460:../emlib/src/em_cmu.c ****  *
 461:../emlib/src/em_cmu.c ****  * @details
 462:../emlib/src/em_cmu.c ****  *   Run a calibration for HFCLK against a selectable reference clock. Please
 463:../emlib/src/em_cmu.c ****  *   refer to the EFM32 reference manual, CMU chapter, for further details.
 464:../emlib/src/em_cmu.c ****  *
 465:../emlib/src/em_cmu.c ****  * @note
 466:../emlib/src/em_cmu.c ****  *   This function will not return until calibration measurement is completed.
 467:../emlib/src/em_cmu.c ****  *
 468:../emlib/src/em_cmu.c ****  * @param[in] HFCycles
 469:../emlib/src/em_cmu.c ****  *   The number of HFCLK cycles to run calibration. Increasing this number
 470:../emlib/src/em_cmu.c ****  *   increases precision, but the calibration will take more time.
 471:../emlib/src/em_cmu.c ****  *
 472:../emlib/src/em_cmu.c ****  * @param[in] ref
 473:../emlib/src/em_cmu.c ****  *   The reference clock used to compare HFCLK with.
 474:../emlib/src/em_cmu.c ****  *
 475:../emlib/src/em_cmu.c ****  * @return
 476:../emlib/src/em_cmu.c ****  *   The number of ticks the reference clock after HFCycles ticks on the HF
 477:../emlib/src/em_cmu.c ****  *   clock.
 478:../emlib/src/em_cmu.c ****  ******************************************************************************/
 479:../emlib/src/em_cmu.c **** uint32_t CMU_Calibrate(uint32_t HFCycles, CMU_Osc_TypeDef ref)
 480:../emlib/src/em_cmu.c **** {
ARM GAS  /tmp/ccnCWsWR.s 			page 27


 324              		.loc 1 480 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 0
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              	.LVL28:
 481:../emlib/src/em_cmu.c ****   EFM_ASSERT(HFCycles <= (_CMU_CALCNT_CALCNT_MASK >> _CMU_CALCNT_CALCNT_SHIFT));
 329              		.loc 1 481 0
 330 0000 B0F5801F 		cmp	r0, #1048576
 480:../emlib/src/em_cmu.c **** {
 331              		.loc 1 480 0
 332 0004 38B5     		push	{r3, r4, r5, lr}
 333              		.cfi_def_cfa_offset 16
 334              		.cfi_offset 3, -16
 335              		.cfi_offset 4, -12
 336              		.cfi_offset 5, -8
 337              		.cfi_offset 14, -4
 480:../emlib/src/em_cmu.c **** {
 338              		.loc 1 480 0
 339 0006 0446     		mov	r4, r0
 340 0008 0D46     		mov	r5, r1
 341              		.loc 1 481 0
 342 000a 04D3     		bcc	.L42
 343              		.loc 1 481 0 is_stmt 0 discriminator 1
 344 000c 1448     		ldr	r0, .L55
 345              	.LVL29:
 346 000e 40F2E111 		movw	r1, #481
 347              	.LVL30:
 348 0012 FFF7FEFF 		bl	assertEFM
 349              	.LVL31:
 350              	.L42:
 482:../emlib/src/em_cmu.c **** 
 483:../emlib/src/em_cmu.c ****   /* Set reference clock source */
 484:../emlib/src/em_cmu.c ****   switch (ref)
 351              		.loc 1 484 0 is_stmt 1
 352 0016 042D     		cmp	r5, #4
 353 0018 14D8     		bhi	.L43
 354 001a DFE805F0 		tbb	[pc, r5]
 355              	.L45:
 356 001e 03       		.byte	(.L44-.L45)/2
 357 001f 05       		.byte	(.L46-.L45)/2
 358 0020 07       		.byte	(.L47-.L45)/2
 359 0021 09       		.byte	(.L48-.L45)/2
 360 0022 0B       		.byte	(.L49-.L45)/2
 361 0023 00       		.p2align 1
 362              	.L44:
 485:../emlib/src/em_cmu.c ****   {
 486:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
 487:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_LFXO;
 363              		.loc 1 487 0
 364 0024 0122     		movs	r2, #1
 365 0026 06E0     		b	.L54
 366              	.L46:
 488:../emlib/src/em_cmu.c ****     break;
 489:../emlib/src/em_cmu.c **** 
 490:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
 491:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_LFRCO;
 367              		.loc 1 491 0
ARM GAS  /tmp/ccnCWsWR.s 			page 28


 368 0028 0322     		movs	r2, #3
 369 002a 04E0     		b	.L54
 370              	.L47:
 492:../emlib/src/em_cmu.c ****     break;
 493:../emlib/src/em_cmu.c **** 
 494:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
 495:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_HFXO;
 371              		.loc 1 495 0
 372 002c 0022     		movs	r2, #0
 373 002e 02E0     		b	.L54
 374              	.L48:
 496:../emlib/src/em_cmu.c ****     break;
 497:../emlib/src/em_cmu.c **** 
 498:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
 499:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_HFRCO;
 375              		.loc 1 499 0
 376 0030 0222     		movs	r2, #2
 377 0032 00E0     		b	.L54
 378              	.L49:
 500:../emlib/src/em_cmu.c ****     break;
 501:../emlib/src/em_cmu.c **** 
 502:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
 503:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_AUXHFRCO;
 379              		.loc 1 503 0
 380 0034 0422     		movs	r2, #4
 381              	.L54:
 382 0036 0B4B     		ldr	r3, .L55+4
 383 0038 9A61     		str	r2, [r3, #24]
 504:../emlib/src/em_cmu.c ****     break;
 505:../emlib/src/em_cmu.c **** 
 506:../emlib/src/em_cmu.c ****   default:
 507:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 508:../emlib/src/em_cmu.c ****     return 0;
 509:../emlib/src/em_cmu.c ****   }
 510:../emlib/src/em_cmu.c **** 
 511:../emlib/src/em_cmu.c ****   /* Set top value */
 512:../emlib/src/em_cmu.c ****   CMU->CALCNT = HFCycles;
 384              		.loc 1 512 0
 385 003a 0A4B     		ldr	r3, .L55+4
 513:../emlib/src/em_cmu.c **** 
 514:../emlib/src/em_cmu.c ****   /* Start calibration */
 515:../emlib/src/em_cmu.c ****   CMU->CMD = CMU_CMD_CALSTART;
 386              		.loc 1 515 0
 387 003c 0822     		movs	r2, #8
 512:../emlib/src/em_cmu.c ****   CMU->CALCNT = HFCycles;
 388              		.loc 1 512 0
 389 003e DC61     		str	r4, [r3, #28]
 390              		.loc 1 515 0
 391 0040 5A62     		str	r2, [r3, #36]
 516:../emlib/src/em_cmu.c **** 
 517:../emlib/src/em_cmu.c ****   /* Wait until calibration completes */
 518:../emlib/src/em_cmu.c ****   while (CMU->STATUS & CMU_STATUS_CALBSY)
 392              		.loc 1 518 0
 393 0042 06E0     		b	.L53
 394              	.L43:
 507:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 395              		.loc 1 507 0
ARM GAS  /tmp/ccnCWsWR.s 			page 29


 396 0044 0648     		ldr	r0, .L55
 397 0046 40F2FB11 		movw	r1, #507
 398 004a FFF7FEFF 		bl	assertEFM
 399              	.LVL32:
 508:../emlib/src/em_cmu.c ****     return 0;
 400              		.loc 1 508 0
 401 004e 0020     		movs	r0, #0
 402 0050 38BD     		pop	{r3, r4, r5, pc}
 403              	.LVL33:
 404              	.L53:
 405              		.loc 1 518 0 discriminator 1
 406 0052 DA6A     		ldr	r2, [r3, #44]
 407 0054 5204     		lsls	r2, r2, #17
 408 0056 FCD4     		bmi	.L53
 519:../emlib/src/em_cmu.c ****     ;
 520:../emlib/src/em_cmu.c **** 
 521:../emlib/src/em_cmu.c ****   return CMU->CALCNT;
 409              		.loc 1 521 0
 410 0058 024B     		ldr	r3, .L55+4
 411 005a D869     		ldr	r0, [r3, #28]
 522:../emlib/src/em_cmu.c **** }
 412              		.loc 1 522 0
 413 005c 38BD     		pop	{r3, r4, r5, pc}
 414              	.LVL34:
 415              	.L56:
 416 005e 00BF     		.align	2
 417              	.L55:
 418 0060 00000000 		.word	.LC0
 419 0064 00800C40 		.word	1074561024
 420              		.cfi_endproc
 421              	.LFE84:
 423              		.section	.text.CMU_ClockDivGet,"ax",%progbits
 424              		.align	1
 425              		.global	CMU_ClockDivGet
 426              		.thumb
 427              		.thumb_func
 429              	CMU_ClockDivGet:
 430              	.LFB85:
 523:../emlib/src/em_cmu.c **** 
 524:../emlib/src/em_cmu.c **** 
 525:../emlib/src/em_cmu.c **** #if defined( _CMU_CALCTRL_UPSEL_MASK ) && defined( _CMU_CALCTRL_DOWNSEL_MASK )
 526:../emlib/src/em_cmu.c **** /***************************************************************************//**
 527:../emlib/src/em_cmu.c ****  * @brief
 528:../emlib/src/em_cmu.c ****  *   Configure clock calibration
 529:../emlib/src/em_cmu.c ****  *
 530:../emlib/src/em_cmu.c ****  * @details
 531:../emlib/src/em_cmu.c ****  *   Configure a calibration for a selectable clock source against another
 532:../emlib/src/em_cmu.c ****  *   selectable reference clock.
 533:../emlib/src/em_cmu.c ****  *   Refer to the EFM32 reference manual, CMU chapter, for further details.
 534:../emlib/src/em_cmu.c ****  *
 535:../emlib/src/em_cmu.c ****  * @note
 536:../emlib/src/em_cmu.c ****  *   After configuration, a call to CMU_CalibrateStart() is required, and
 537:../emlib/src/em_cmu.c ****  *   the resulting calibration value can be read out with the
 538:../emlib/src/em_cmu.c ****  *   CMU_CalibrateCountGet() function call.
 539:../emlib/src/em_cmu.c ****  *
 540:../emlib/src/em_cmu.c ****  * @param[in] downCycles
 541:../emlib/src/em_cmu.c ****  *   The number of downSel clock cycles to run calibration. Increasing this
ARM GAS  /tmp/ccnCWsWR.s 			page 30


 542:../emlib/src/em_cmu.c ****  *   number increases precision, but the calibration will take more time.
 543:../emlib/src/em_cmu.c ****  *
 544:../emlib/src/em_cmu.c ****  * @param[in] downSel
 545:../emlib/src/em_cmu.c ****  *   The clock which will be counted down downCycles
 546:../emlib/src/em_cmu.c ****  *
 547:../emlib/src/em_cmu.c ****  * @param[in] upSel
 548:../emlib/src/em_cmu.c ****  *   The reference clock, the number of cycles generated by this clock will
 549:../emlib/src/em_cmu.c ****  *   be counted and added up, the result can be given with the
 550:../emlib/src/em_cmu.c ****  *   CMU_CalibrateCountGet() function call.
 551:../emlib/src/em_cmu.c ****  ******************************************************************************/
 552:../emlib/src/em_cmu.c **** void CMU_CalibrateConfig(uint32_t downCycles, CMU_Osc_TypeDef downSel,
 553:../emlib/src/em_cmu.c ****                          CMU_Osc_TypeDef upSel)
 554:../emlib/src/em_cmu.c **** {
 555:../emlib/src/em_cmu.c ****   /* Keep untouched configuration settings */
 556:../emlib/src/em_cmu.c ****   uint32_t calCtrl = CMU->CALCTRL & ~(_CMU_CALCTRL_UPSEL_MASK | _CMU_CALCTRL_DOWNSEL_MASK);
 557:../emlib/src/em_cmu.c **** 
 558:../emlib/src/em_cmu.c ****   /* 20 bits of precision to calibration count register */
 559:../emlib/src/em_cmu.c ****   EFM_ASSERT(downCycles <= (_CMU_CALCNT_CALCNT_MASK >> _CMU_CALCNT_CALCNT_SHIFT));
 560:../emlib/src/em_cmu.c **** 
 561:../emlib/src/em_cmu.c ****   /* Set down counting clock source - down counter */
 562:../emlib/src/em_cmu.c ****   switch (downSel)
 563:../emlib/src/em_cmu.c ****   {
 564:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
 565:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_LFXO;
 566:../emlib/src/em_cmu.c ****     break;
 567:../emlib/src/em_cmu.c **** 
 568:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
 569:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_LFRCO;
 570:../emlib/src/em_cmu.c ****     break;
 571:../emlib/src/em_cmu.c **** 
 572:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
 573:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_HFXO;
 574:../emlib/src/em_cmu.c ****     break;
 575:../emlib/src/em_cmu.c **** 
 576:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
 577:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_HFRCO;
 578:../emlib/src/em_cmu.c ****     break;
 579:../emlib/src/em_cmu.c **** 
 580:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
 581:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_AUXHFRCO;
 582:../emlib/src/em_cmu.c ****     break;
 583:../emlib/src/em_cmu.c **** 
 584:../emlib/src/em_cmu.c ****   default:
 585:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 586:../emlib/src/em_cmu.c ****     break;
 587:../emlib/src/em_cmu.c ****   }
 588:../emlib/src/em_cmu.c **** 
 589:../emlib/src/em_cmu.c ****   /* Set top value to be counted down by the downSel clock */
 590:../emlib/src/em_cmu.c ****   CMU->CALCNT = downCycles;
 591:../emlib/src/em_cmu.c **** 
 592:../emlib/src/em_cmu.c ****   /* Set reference clock source - up counter */
 593:../emlib/src/em_cmu.c ****   switch (upSel)
 594:../emlib/src/em_cmu.c ****   {
 595:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
 596:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_LFXO;
 597:../emlib/src/em_cmu.c ****     break;
 598:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 31


 599:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
 600:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_LFRCO;
 601:../emlib/src/em_cmu.c ****     break;
 602:../emlib/src/em_cmu.c **** 
 603:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
 604:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_HFXO;
 605:../emlib/src/em_cmu.c ****     break;
 606:../emlib/src/em_cmu.c **** 
 607:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
 608:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_HFRCO;
 609:../emlib/src/em_cmu.c ****     break;
 610:../emlib/src/em_cmu.c **** 
 611:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
 612:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_AUXHFRCO;
 613:../emlib/src/em_cmu.c ****     break;
 614:../emlib/src/em_cmu.c **** 
 615:../emlib/src/em_cmu.c ****   default:
 616:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 617:../emlib/src/em_cmu.c ****     break;
 618:../emlib/src/em_cmu.c ****   }
 619:../emlib/src/em_cmu.c **** 
 620:../emlib/src/em_cmu.c ****   CMU->CALCTRL = calCtrl;
 621:../emlib/src/em_cmu.c **** }
 622:../emlib/src/em_cmu.c **** #endif
 623:../emlib/src/em_cmu.c **** 
 624:../emlib/src/em_cmu.c **** 
 625:../emlib/src/em_cmu.c **** /***************************************************************************//**
 626:../emlib/src/em_cmu.c ****  * @brief
 627:../emlib/src/em_cmu.c ****  *   Get clock divisor/prescaler.
 628:../emlib/src/em_cmu.c ****  *
 629:../emlib/src/em_cmu.c ****  * @param[in] clock
 630:../emlib/src/em_cmu.c ****  *   Clock point to get divisor/prescaler for. Notice that not all clock points
 631:../emlib/src/em_cmu.c ****  *   have a divisor/prescaler. Please refer to CMU overview in reference manual.
 632:../emlib/src/em_cmu.c ****  *
 633:../emlib/src/em_cmu.c ****  * @return
 634:../emlib/src/em_cmu.c ****  *   The current clock point divisor/prescaler. 1 is returned
 635:../emlib/src/em_cmu.c ****  *   if @p clock specifies a clock point without a divisor/prescaler.
 636:../emlib/src/em_cmu.c ****  ******************************************************************************/
 637:../emlib/src/em_cmu.c **** CMU_ClkDiv_TypeDef CMU_ClockDivGet(CMU_Clock_TypeDef clock)
 638:../emlib/src/em_cmu.c **** {
 431              		.loc 1 638 0
 432              		.cfi_startproc
 433              		@ args = 0, pretend = 0, frame = 0
 434              		@ frame_needed = 0, uses_anonymous_args = 0
 435              	.LVL35:
 639:../emlib/src/em_cmu.c ****   uint32_t           divReg;
 640:../emlib/src/em_cmu.c ****   CMU_ClkDiv_TypeDef ret;
 641:../emlib/src/em_cmu.c **** 
 642:../emlib/src/em_cmu.c ****   /* Get divisor reg id */
 643:../emlib/src/em_cmu.c ****   divReg = (clock >> CMU_DIV_REG_POS) & CMU_DIV_REG_MASK;
 436              		.loc 1 643 0
 437 0000 C0F30312 		ubfx	r2, r0, #4, #4
 644:../emlib/src/em_cmu.c **** 
 645:../emlib/src/em_cmu.c ****   switch (divReg)
 438              		.loc 1 645 0
 439 0004 013A     		subs	r2, r2, #1
 638:../emlib/src/em_cmu.c **** {
ARM GAS  /tmp/ccnCWsWR.s 			page 32


 440              		.loc 1 638 0
 441 0006 08B5     		push	{r3, lr}
 442              		.cfi_def_cfa_offset 8
 443              		.cfi_offset 3, -8
 444              		.cfi_offset 14, -4
 445 0008 0123     		movs	r3, #1
 446              		.loc 1 645 0
 447 000a 032A     		cmp	r2, #3
 448 000c 38D8     		bhi	.L58
 449 000e DFE802F0 		tbb	[pc, r2]
 450              	.L60:
 451 0012 02       		.byte	(.L59-.L60)/2
 452 0013 05       		.byte	(.L61-.L60)/2
 453 0014 0A       		.byte	(.L62-.L60)/2
 454 0015 1F       		.byte	(.L63-.L60)/2
 455              		.p2align 1
 456              	.L59:
 646:../emlib/src/em_cmu.c ****   {
 647:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
 648:../emlib/src/em_cmu.c ****   case CMU_HFCLKDIV_REG:
 649:../emlib/src/em_cmu.c ****     ret = 1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
 650:../emlib/src/em_cmu.c ****                _CMU_CTRL_HFCLKDIV_SHIFT);
 651:../emlib/src/em_cmu.c ****     break;
 652:../emlib/src/em_cmu.c **** #endif
 653:../emlib/src/em_cmu.c **** 
 654:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKDIV_REG:
 655:../emlib/src/em_cmu.c ****     ret = (CMU_ClkDiv_TypeDef)((CMU->HFPERCLKDIV &
 457              		.loc 1 655 0
 458 0016 1E4A     		ldr	r2, .L79
 459 0018 9068     		ldr	r0, [r2, #8]
 460              	.LVL36:
 461 001a 01E0     		b	.L76
 462              	.LVL37:
 463              	.L61:
 656:../emlib/src/em_cmu.c ****                                 _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK) >>
 657:../emlib/src/em_cmu.c ****                                _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT);
 658:../emlib/src/em_cmu.c ****     ret = CMU_Log2ToDiv(ret);
 659:../emlib/src/em_cmu.c ****     break;
 660:../emlib/src/em_cmu.c **** 
 661:../emlib/src/em_cmu.c ****   case CMU_HFCORECLKDIV_REG:
 662:../emlib/src/em_cmu.c ****     ret = (CMU_ClkDiv_TypeDef)((CMU->HFCORECLKDIV &
 464              		.loc 1 662 0
 465 001c 1C4A     		ldr	r2, .L79
 466 001e 5068     		ldr	r0, [r2, #4]
 467              	.LVL38:
 468              	.L76:
 469 0020 00F00F00 		and	r0, r0, #15
 470              	.LVL39:
 471 0024 25E0     		b	.L73
 472              	.LVL40:
 473              	.L62:
 663:../emlib/src/em_cmu.c ****                                 _CMU_HFCORECLKDIV_HFCORECLKDIV_MASK) >>
 664:../emlib/src/em_cmu.c ****                                _CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT);
 665:../emlib/src/em_cmu.c ****     ret = CMU_Log2ToDiv(ret);
 666:../emlib/src/em_cmu.c ****     break;
 667:../emlib/src/em_cmu.c **** 
 668:../emlib/src/em_cmu.c ****   case CMU_LFAPRESC0_REG:
ARM GAS  /tmp/ccnCWsWR.s 			page 33


 669:../emlib/src/em_cmu.c ****     switch (clock)
 474              		.loc 1 669 0
 475 0026 1B4B     		ldr	r3, .L79+4
 476 0028 9842     		cmp	r0, r3
 477 002a 08D0     		beq	.L66
 478 002c 03F50433 		add	r3, r3, #135168
 479 0030 9842     		cmp	r0, r3
 480 0032 09D1     		bne	.L77
 670:../emlib/src/em_cmu.c ****     {
 671:../emlib/src/em_cmu.c ****     case cmuClock_RTC:
 672:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK) >>
 673:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_RTC_SHIFT));
 674:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 675:../emlib/src/em_cmu.c ****       break;
 676:../emlib/src/em_cmu.c **** 
 677:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
 678:../emlib/src/em_cmu.c ****     case cmuClock_LETIMER0:
 679:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK) >>
 481              		.loc 1 679 0
 482 0034 164B     		ldr	r3, .L79
 483 0036 986E     		ldr	r0, [r3, #104]
 484              	.LVL41:
 485 0038 C0F30310 		ubfx	r0, r0, #4, #4
 486              	.LVL42:
 487 003c 18E0     		b	.L75
 488              	.LVL43:
 489              	.L66:
 672:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK) >>
 490              		.loc 1 672 0
 491 003e 144B     		ldr	r3, .L79
 492 0040 986E     		ldr	r0, [r3, #104]
 493              	.LVL44:
 494 0042 00F00F00 		and	r0, r0, #15
 495              	.LVL45:
 496 0046 13E0     		b	.L75
 497              	.LVL46:
 498              	.L77:
 680:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_LETIMER0_SHIFT));
 681:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 682:../emlib/src/em_cmu.c ****       break;
 683:../emlib/src/em_cmu.c **** #endif
 684:../emlib/src/em_cmu.c **** 
 685:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LCD_MASK)
 686:../emlib/src/em_cmu.c ****     case cmuClock_LCDpre:
 687:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK) >>
 688:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_LCD_SHIFT) + CMU_DivToLog2(cmuClkDiv_16));
 689:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 690:../emlib/src/em_cmu.c ****       break;
 691:../emlib/src/em_cmu.c **** #endif
 692:../emlib/src/em_cmu.c **** 
 693:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LESENSE_MASK)
 694:../emlib/src/em_cmu.c ****     case cmuClock_LESENSE:
 695:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK) >>
 696:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_LESENSE_SHIFT));
 697:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 698:../emlib/src/em_cmu.c ****       break;
 699:../emlib/src/em_cmu.c **** #endif
ARM GAS  /tmp/ccnCWsWR.s 			page 34


 700:../emlib/src/em_cmu.c **** 
 701:../emlib/src/em_cmu.c ****     default:
 702:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 499              		.loc 1 702 0
 500 0048 1348     		ldr	r0, .L79+8
 501              	.LVL47:
 502 004a 40F2BE21 		movw	r1, #702
 503 004e 1AE0     		b	.L74
 504              	.LVL48:
 505              	.L63:
 703:../emlib/src/em_cmu.c ****       ret = cmuClkDiv_1;
 704:../emlib/src/em_cmu.c ****       break;
 705:../emlib/src/em_cmu.c ****     }
 706:../emlib/src/em_cmu.c ****     break;
 707:../emlib/src/em_cmu.c **** 
 708:../emlib/src/em_cmu.c ****   case CMU_LFBPRESC0_REG:
 709:../emlib/src/em_cmu.c ****     switch (clock)
 506              		.loc 1 709 0
 507 0050 124B     		ldr	r3, .L79+12
 508 0052 9842     		cmp	r0, r3
 509 0054 08D0     		beq	.L69
 510 0056 03F50433 		add	r3, r3, #135168
 511 005a 9842     		cmp	r0, r3
 512 005c 0CD1     		bne	.L78
 710:../emlib/src/em_cmu.c ****     {
 711:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
 712:../emlib/src/em_cmu.c ****     case cmuClock_LEUART0:
 713:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK) >>
 714:../emlib/src/em_cmu.c ****                                   _CMU_LFBPRESC0_LEUART0_SHIFT));
 715:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 716:../emlib/src/em_cmu.c ****       break;
 717:../emlib/src/em_cmu.c **** #endif
 718:../emlib/src/em_cmu.c **** 
 719:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
 720:../emlib/src/em_cmu.c ****     case cmuClock_LEUART1:
 721:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK) >>
 513              		.loc 1 721 0
 514 005e 0C4B     		ldr	r3, .L79
 515 0060 186F     		ldr	r0, [r3, #112]
 516              	.LVL49:
 517 0062 C0F30110 		ubfx	r0, r0, #4, #2
 518              	.LVL50:
 519 0066 03E0     		b	.L75
 520              	.LVL51:
 521              	.L69:
 713:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK) >>
 522              		.loc 1 713 0
 523 0068 094B     		ldr	r3, .L79
 524 006a 186F     		ldr	r0, [r3, #112]
 525              	.LVL52:
 526 006c 00F00300 		and	r0, r0, #3
 527              	.LVL53:
 528              	.L75:
 529              	.LBB30:
 530              	.LBB31:
 151:../emlib/src/em_cmu.c ****   return 1<<log2;
 531              		.loc 1 151 0
ARM GAS  /tmp/ccnCWsWR.s 			page 35


 532 0070 0123     		movs	r3, #1
 533              	.L73:
 534 0072 03FA00F0 		lsl	r0, r3, r0
 535              	.LBE31:
 536              	.LBE30:
 722:../emlib/src/em_cmu.c ****                                   _CMU_LFBPRESC0_LEUART1_SHIFT));
 723:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 724:../emlib/src/em_cmu.c ****       break;
 537              		.loc 1 724 0
 538 0076 08BD     		pop	{r3, pc}
 539              	.LVL54:
 540              	.L78:
 725:../emlib/src/em_cmu.c **** #endif
 726:../emlib/src/em_cmu.c **** 
 727:../emlib/src/em_cmu.c ****     default:
 728:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 541              		.loc 1 728 0
 542 0078 0748     		ldr	r0, .L79+8
 543              	.LVL55:
 544 007a 4FF43671 		mov	r1, #728
 545 007e 02E0     		b	.L74
 546              	.LVL56:
 547              	.L58:
 729:../emlib/src/em_cmu.c ****       ret = cmuClkDiv_1;
 730:../emlib/src/em_cmu.c ****       break;
 731:../emlib/src/em_cmu.c ****     }
 732:../emlib/src/em_cmu.c ****     break;
 733:../emlib/src/em_cmu.c **** 
 734:../emlib/src/em_cmu.c ****   default:
 735:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 548              		.loc 1 735 0
 549 0080 0548     		ldr	r0, .L79+8
 550              	.LVL57:
 551 0082 40F2DF21 		movw	r1, #735
 552              	.L74:
 553 0086 FFF7FEFF 		bl	assertEFM
 554              	.LVL58:
 736:../emlib/src/em_cmu.c ****     ret = cmuClkDiv_1;
 555              		.loc 1 736 0
 556 008a 0120     		movs	r0, #1
 557              	.LVL59:
 737:../emlib/src/em_cmu.c ****     break;
 738:../emlib/src/em_cmu.c ****   }
 739:../emlib/src/em_cmu.c **** 
 740:../emlib/src/em_cmu.c ****   return(ret);
 741:../emlib/src/em_cmu.c **** }
 558              		.loc 1 741 0
 559 008c 08BD     		pop	{r3, pc}
 560              	.L80:
 561 008e 00BF     		.align	2
 562              	.L79:
 563 0090 00800C40 		.word	1074561024
 564 0094 30040800 		.word	525360
 565 0098 00000000 		.word	.LC0
 566 009c 40051400 		.word	1312064
 567              		.cfi_endproc
 568              	.LFE85:
ARM GAS  /tmp/ccnCWsWR.s 			page 36


 570              		.section	.text.CMU_ClockDivSet,"ax",%progbits
 571              		.align	1
 572              		.global	CMU_ClockDivSet
 573              		.thumb
 574              		.thumb_func
 576              	CMU_ClockDivSet:
 577              	.LFB86:
 742:../emlib/src/em_cmu.c **** 
 743:../emlib/src/em_cmu.c **** 
 744:../emlib/src/em_cmu.c **** /***************************************************************************//**
 745:../emlib/src/em_cmu.c ****  * @brief
 746:../emlib/src/em_cmu.c ****  *   Set clock divisor/prescaler.
 747:../emlib/src/em_cmu.c ****  *
 748:../emlib/src/em_cmu.c ****  * @note
 749:../emlib/src/em_cmu.c ****  *   If setting a LF clock prescaler, synchronization into the low frequency
 750:../emlib/src/em_cmu.c ****  *   domain is required. If the same register is modified before a previous
 751:../emlib/src/em_cmu.c ****  *   update has completed, this function will stall until the previous
 752:../emlib/src/em_cmu.c ****  *   synchronization has completed. Please refer to CMU_FreezeEnable() for
 753:../emlib/src/em_cmu.c ****  *   a suggestion on how to reduce stalling time in some use cases.
 754:../emlib/src/em_cmu.c ****  *
 755:../emlib/src/em_cmu.c ****  * @param[in] clock
 756:../emlib/src/em_cmu.c ****  *   Clock point to set divisor/prescaler for. Notice that not all clock points
 757:../emlib/src/em_cmu.c ****  *   have a divisor/prescaler, please refer to CMU overview in the reference
 758:../emlib/src/em_cmu.c ****  *   manual.
 759:../emlib/src/em_cmu.c ****  *
 760:../emlib/src/em_cmu.c ****  * @param[in] div
 761:../emlib/src/em_cmu.c ****  *   The clock divisor to use (<= cmuClkDiv_512).
 762:../emlib/src/em_cmu.c ****  ******************************************************************************/
 763:../emlib/src/em_cmu.c **** void CMU_ClockDivSet(CMU_Clock_TypeDef clock, CMU_ClkDiv_TypeDef div)
 764:../emlib/src/em_cmu.c **** {
 578              		.loc 1 764 0
 579              		.cfi_startproc
 580              		@ args = 0, pretend = 0, frame = 0
 581              		@ frame_needed = 0, uses_anonymous_args = 0
 582              	.LVL60:
 765:../emlib/src/em_cmu.c ****   uint32_t freq;
 766:../emlib/src/em_cmu.c ****   uint32_t divReg;
 767:../emlib/src/em_cmu.c **** 
 768:../emlib/src/em_cmu.c ****   /* Get divisor reg id */
 769:../emlib/src/em_cmu.c ****   divReg = (clock >> CMU_DIV_REG_POS) & CMU_DIV_REG_MASK;
 583              		.loc 1 769 0
 584 0000 C0F30313 		ubfx	r3, r0, #4, #4
 770:../emlib/src/em_cmu.c **** 
 771:../emlib/src/em_cmu.c ****   switch (divReg)
 585              		.loc 1 771 0
 586 0004 013B     		subs	r3, r3, #1
 764:../emlib/src/em_cmu.c **** {
 587              		.loc 1 764 0
 588 0006 10B5     		push	{r4, lr}
 589              		.cfi_def_cfa_offset 8
 590              		.cfi_offset 4, -8
 591              		.cfi_offset 14, -4
 764:../emlib/src/em_cmu.c **** {
 592              		.loc 1 764 0
 593 0008 0C46     		mov	r4, r1
 594              		.loc 1 771 0
 595 000a 032B     		cmp	r3, #3
ARM GAS  /tmp/ccnCWsWR.s 			page 37


 596 000c 00F29A80 		bhi	.L82
 597 0010 DFE803F0 		tbb	[pc, r3]
 598              	.L84:
 599 0014 02       		.byte	(.L83-.L84)/2
 600 0015 15       		.byte	(.L85-.L84)/2
 601 0016 2E       		.byte	(.L86-.L84)/2
 602 0017 64       		.byte	(.L87-.L84)/2
 603              		.p2align 1
 604              	.L83:
 772:../emlib/src/em_cmu.c ****   {
 773:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
 774:../emlib/src/em_cmu.c ****   case CMU_HFCLKDIV_REG:
 775:../emlib/src/em_cmu.c ****     EFM_ASSERT((div>=cmuClkDiv_1) && (div<=cmuClkDiv_8));
 776:../emlib/src/em_cmu.c **** 
 777:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before setting divisor */
 778:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 779:../emlib/src/em_cmu.c **** 
 780:../emlib/src/em_cmu.c ****     /* Set divider */
 781:../emlib/src/em_cmu.c ****     CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFCLKDIV_MASK) |
 782:../emlib/src/em_cmu.c ****       ((div-1) << _CMU_CTRL_HFCLKDIV_SHIFT);
 783:../emlib/src/em_cmu.c **** 
 784:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable */
 785:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
 786:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 787:../emlib/src/em_cmu.c **** 
 788:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for current core clk */
 789:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 790:../emlib/src/em_cmu.c ****     break;
 791:../emlib/src/em_cmu.c **** #endif
 792:../emlib/src/em_cmu.c **** 
 793:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKDIV_REG:
 794:../emlib/src/em_cmu.c ****     EFM_ASSERT((div >= cmuClkDiv_1) && (div <= cmuClkDiv_512));
 605              		.loc 1 794 0
 606 0018 4B1E     		subs	r3, r1, #1
 607 001a B3F5007F 		cmp	r3, #512
 608 001e 04D3     		bcc	.L88
 609              		.loc 1 794 0 is_stmt 0 discriminator 1
 610 0020 4C48     		ldr	r0, .L108
 611              	.LVL61:
 612 0022 40F21A31 		movw	r1, #794
 613              	.LVL62:
 614 0026 FFF7FEFF 		bl	assertEFM
 615              	.LVL63:
 616              	.L88:
 795:../emlib/src/em_cmu.c ****     /* Convert to correct scale */
 796:../emlib/src/em_cmu.c ****     div = CMU_DivToLog2(div);
 617              		.loc 1 796 0 is_stmt 1
 618 002a 2046     		mov	r0, r4
 619 002c FFF7FEFF 		bl	CMU_DivToLog2
 620              	.LVL64:
 797:../emlib/src/em_cmu.c ****     CMU->HFPERCLKDIV = (CMU->HFPERCLKDIV & ~_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK) |
 621              		.loc 1 797 0
 622 0030 494B     		ldr	r3, .L108+4
 623 0032 9A68     		ldr	r2, [r3, #8]
 624 0034 22F00F02 		bic	r2, r2, #15
 625 0038 1043     		orrs	r0, r0, r2
 626              	.LVL65:
ARM GAS  /tmp/ccnCWsWR.s 			page 38


 627 003a 9860     		str	r0, [r3, #8]
 798:../emlib/src/em_cmu.c ****                        (div << _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT);
 799:../emlib/src/em_cmu.c ****     break;
 628              		.loc 1 799 0
 629 003c 10BD     		pop	{r4, pc}
 630              	.LVL66:
 631              	.L85:
 800:../emlib/src/em_cmu.c **** 
 801:../emlib/src/em_cmu.c ****   case CMU_HFCORECLKDIV_REG:
 802:../emlib/src/em_cmu.c ****     EFM_ASSERT(div <= cmuClkDiv_512);
 632              		.loc 1 802 0
 633 003e B1F5007F 		cmp	r1, #512
 634 0042 04D9     		bls	.L90
 635              		.loc 1 802 0 is_stmt 0 discriminator 1
 636 0044 4348     		ldr	r0, .L108
 637              	.LVL67:
 638 0046 40F22231 		movw	r1, #802
 639              	.LVL68:
 640 004a FFF7FEFF 		bl	assertEFM
 641              	.LVL69:
 642              	.L90:
 803:../emlib/src/em_cmu.c **** 
 804:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before setting divisor */
 805:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 643              		.loc 1 805 0 is_stmt 1
 644 004e FFF7FEFF 		bl	CMU_FlashWaitStateMax
 645              	.LVL70:
 806:../emlib/src/em_cmu.c **** 
 807:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
 808:../emlib/src/em_cmu.c ****     /* Clear HFLE and set DIV2 factor for peripheral clock
 809:../emlib/src/em_cmu.c ****        when running at frequencies lower than 32 MHz. */
 810:../emlib/src/em_cmu.c ****     if ( (cmuSelect_HFXO != CMU_ClockSelectGet(cmuClock_HF)) ||
 811:../emlib/src/em_cmu.c ****          ((SystemHFXOClockGet()/div) <= CMU_MAX_FREQ_HFLE) )
 812:../emlib/src/em_cmu.c ****     {
 813:../emlib/src/em_cmu.c ****       /* Clear CMU HFLE */
 814:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 0);
 815:../emlib/src/em_cmu.c **** 
 816:../emlib/src/em_cmu.c ****       /* Set DIV2 factor for peripheral clock */
 817:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
 818:../emlib/src/em_cmu.c ****                          _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 0);
 819:../emlib/src/em_cmu.c ****     }
 820:../emlib/src/em_cmu.c ****     else
 821:../emlib/src/em_cmu.c ****     {
 822:../emlib/src/em_cmu.c ****       /* Set CMU HFLE */
 823:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 1);
 824:../emlib/src/em_cmu.c **** 
 825:../emlib/src/em_cmu.c ****       /* Set DIV4 factor for peripheral clock */
 826:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
 827:../emlib/src/em_cmu.c ****                          _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
 828:../emlib/src/em_cmu.c ****     }
 829:../emlib/src/em_cmu.c **** #endif
 830:../emlib/src/em_cmu.c **** 
 831:../emlib/src/em_cmu.c ****     /* Convert to correct scale */
 832:../emlib/src/em_cmu.c ****     div = CMU_DivToLog2(div);
 646              		.loc 1 832 0
 647 0052 2046     		mov	r0, r4
 648 0054 FFF7FEFF 		bl	CMU_DivToLog2
ARM GAS  /tmp/ccnCWsWR.s 			page 39


 649              	.LVL71:
 833:../emlib/src/em_cmu.c **** 
 834:../emlib/src/em_cmu.c ****     CMU->HFCORECLKDIV = (CMU->HFCORECLKDIV & ~_CMU_HFCORECLKDIV_HFCORECLKDIV_MASK) |
 650              		.loc 1 834 0
 651 0058 3F4B     		ldr	r3, .L108+4
 652 005a 5A68     		ldr	r2, [r3, #4]
 653 005c 22F00F02 		bic	r2, r2, #15
 654 0060 1043     		orrs	r0, r0, r2
 655              	.LVL72:
 656 0062 5860     		str	r0, [r3, #4]
 835:../emlib/src/em_cmu.c ****                         (div << _CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT);
 836:../emlib/src/em_cmu.c **** 
 837:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable */
 838:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
 839:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 657              		.loc 1 839 0
 658 0064 FFF7FEFF 		bl	SystemCoreClockGet
 659              	.LVL73:
 840:../emlib/src/em_cmu.c **** 
 841:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for current core clk */
 842:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 843:../emlib/src/em_cmu.c ****     break;
 844:../emlib/src/em_cmu.c **** 
 845:../emlib/src/em_cmu.c ****   case CMU_LFAPRESC0_REG:
 846:../emlib/src/em_cmu.c ****     switch (clock)
 847:../emlib/src/em_cmu.c ****     {
 848:../emlib/src/em_cmu.c ****     case cmuClock_RTC:
 849:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 850:../emlib/src/em_cmu.c **** 
 851:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 852:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 853:../emlib/src/em_cmu.c **** 
 854:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 855:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 856:../emlib/src/em_cmu.c **** 
 857:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_RTC_MASK) |
 858:../emlib/src/em_cmu.c ****                        (div << _CMU_LFAPRESC0_RTC_SHIFT);
 859:../emlib/src/em_cmu.c ****       break;
 860:../emlib/src/em_cmu.c **** 
 861:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
 862:../emlib/src/em_cmu.c ****     case cmuClock_LETIMER0:
 863:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 864:../emlib/src/em_cmu.c **** 
 865:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 866:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 867:../emlib/src/em_cmu.c **** 
 868:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 869:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 870:../emlib/src/em_cmu.c **** 
 871:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LETIMER0_MASK) |
 872:../emlib/src/em_cmu.c ****                        (div << _CMU_LFAPRESC0_LETIMER0_SHIFT);
 873:../emlib/src/em_cmu.c ****       break;
 874:../emlib/src/em_cmu.c **** #endif
 875:../emlib/src/em_cmu.c **** 
 876:../emlib/src/em_cmu.c **** #if defined(LCD_PRESENT)
 877:../emlib/src/em_cmu.c ****     case cmuClock_LCDpre:
 878:../emlib/src/em_cmu.c ****       EFM_ASSERT((div >= cmuClkDiv_16) && (div <= cmuClkDiv_128));
ARM GAS  /tmp/ccnCWsWR.s 			page 40


 879:../emlib/src/em_cmu.c **** 
 880:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 881:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 882:../emlib/src/em_cmu.c **** 
 883:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 884:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 885:../emlib/src/em_cmu.c **** 
 886:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LCD_MASK) |
 887:../emlib/src/em_cmu.c ****                        ((div - CMU_DivToLog2(cmuClkDiv_16)) << _CMU_LFAPRESC0_LCD_SHIFT);
 888:../emlib/src/em_cmu.c ****       break;
 889:../emlib/src/em_cmu.c **** #endif /* defined(LCD_PRESENT) */
 890:../emlib/src/em_cmu.c **** 
 891:../emlib/src/em_cmu.c **** #if defined(LESENSE_PRESENT)
 892:../emlib/src/em_cmu.c ****     case cmuClock_LESENSE:
 893:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 894:../emlib/src/em_cmu.c **** 
 895:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 896:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 897:../emlib/src/em_cmu.c **** 
 898:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 899:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 900:../emlib/src/em_cmu.c **** 
 901:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LESENSE_MASK) |
 902:../emlib/src/em_cmu.c ****                        (div << _CMU_LFAPRESC0_LESENSE_SHIFT);
 903:../emlib/src/em_cmu.c ****       break;
 904:../emlib/src/em_cmu.c **** #endif /* defined(LESENSE_PRESENT) */
 905:../emlib/src/em_cmu.c **** 
 906:../emlib/src/em_cmu.c ****     default:
 907:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 908:../emlib/src/em_cmu.c ****       break;
 909:../emlib/src/em_cmu.c ****     }
 910:../emlib/src/em_cmu.c ****     break;
 911:../emlib/src/em_cmu.c **** 
 912:../emlib/src/em_cmu.c ****   case CMU_LFBPRESC0_REG:
 913:../emlib/src/em_cmu.c ****     switch (clock)
 914:../emlib/src/em_cmu.c ****     {
 915:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
 916:../emlib/src/em_cmu.c ****     case cmuClock_LEUART0:
 917:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 918:../emlib/src/em_cmu.c **** 
 919:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 920:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFBPRESC0);
 921:../emlib/src/em_cmu.c **** 
 922:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 923:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 924:../emlib/src/em_cmu.c **** 
 925:../emlib/src/em_cmu.c ****       CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART0_MASK) |
 926:../emlib/src/em_cmu.c ****                        (((uint32_t)div) << _CMU_LFBPRESC0_LEUART0_SHIFT);
 927:../emlib/src/em_cmu.c ****       break;
 928:../emlib/src/em_cmu.c **** #endif
 929:../emlib/src/em_cmu.c **** 
 930:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
 931:../emlib/src/em_cmu.c ****     case cmuClock_LEUART1:
 932:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 933:../emlib/src/em_cmu.c **** 
 934:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 935:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFBPRESC0);
ARM GAS  /tmp/ccnCWsWR.s 			page 41


 936:../emlib/src/em_cmu.c **** 
 937:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 938:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 939:../emlib/src/em_cmu.c **** 
 940:../emlib/src/em_cmu.c ****       CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART1_MASK) |
 941:../emlib/src/em_cmu.c ****                        (((uint32_t)div) << _CMU_LFBPRESC0_LEUART1_SHIFT);
 942:../emlib/src/em_cmu.c ****       break;
 943:../emlib/src/em_cmu.c **** #endif
 944:../emlib/src/em_cmu.c **** 
 945:../emlib/src/em_cmu.c ****     default:
 946:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 947:../emlib/src/em_cmu.c ****       break;
 948:../emlib/src/em_cmu.c ****     }
 949:../emlib/src/em_cmu.c ****     break;
 950:../emlib/src/em_cmu.c **** 
 951:../emlib/src/em_cmu.c ****   default:
 952:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 953:../emlib/src/em_cmu.c ****     break;
 954:../emlib/src/em_cmu.c ****   }
 955:../emlib/src/em_cmu.c **** }
 660              		.loc 1 955 0
 661 0068 BDE81040 		pop	{r4, lr}
 842:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 662              		.loc 1 842 0
 663 006c FFF7FEBF 		b	CMU_FlashWaitStateControl
 664              	.LVL74:
 665              	.L86:
 846:../emlib/src/em_cmu.c ****     switch (clock)
 666              		.loc 1 846 0
 667 0070 3A4B     		ldr	r3, .L108+8
 668 0072 9842     		cmp	r0, r3
 669 0074 04D0     		beq	.L92
 670 0076 03F50433 		add	r3, r3, #135168
 671 007a 9842     		cmp	r0, r3
 672 007c 14D0     		beq	.L93
 673 007e 29E0     		b	.L106
 674              	.L92:
 849:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 675              		.loc 1 849 0
 676 0080 B1F5004F 		cmp	r1, #32768
 677 0084 04D9     		bls	.L94
 849:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 678              		.loc 1 849 0 is_stmt 0 discriminator 1
 679 0086 3348     		ldr	r0, .L108
 680              	.LVL75:
 681 0088 40F25131 		movw	r1, #849
 682              	.LVL76:
 683 008c FFF7FEFF 		bl	assertEFM
 684              	.LVL77:
 685              	.L94:
 852:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 686              		.loc 1 852 0 is_stmt 1
 687 0090 0420     		movs	r0, #4
 688 0092 FFF7FEFF 		bl	CMU_Sync
 689              	.LVL78:
 855:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 690              		.loc 1 855 0
ARM GAS  /tmp/ccnCWsWR.s 			page 42


 691 0096 2046     		mov	r0, r4
 692 0098 FFF7FEFF 		bl	CMU_DivToLog2
 693              	.LVL79:
 857:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_RTC_MASK) |
 694              		.loc 1 857 0
 695 009c 2E4B     		ldr	r3, .L108+4
 696 009e 9A6E     		ldr	r2, [r3, #104]
 697 00a0 22F00F02 		bic	r2, r2, #15
 698 00a4 1043     		orrs	r0, r0, r2
 699              	.LVL80:
 700 00a6 13E0     		b	.L104
 701              	.LVL81:
 702              	.L93:
 863:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 703              		.loc 1 863 0
 704 00a8 B1F5004F 		cmp	r1, #32768
 705 00ac 04D9     		bls	.L95
 863:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 706              		.loc 1 863 0 is_stmt 0 discriminator 1
 707 00ae 2948     		ldr	r0, .L108
 708              	.LVL82:
 709 00b0 40F25F31 		movw	r1, #863
 710              	.LVL83:
 711 00b4 FFF7FEFF 		bl	assertEFM
 712              	.LVL84:
 713              	.L95:
 866:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 714              		.loc 1 866 0 is_stmt 1
 715 00b8 0420     		movs	r0, #4
 716 00ba FFF7FEFF 		bl	CMU_Sync
 717              	.LVL85:
 869:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 718              		.loc 1 869 0
 719 00be 2046     		mov	r0, r4
 720 00c0 FFF7FEFF 		bl	CMU_DivToLog2
 721              	.LVL86:
 871:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LETIMER0_MASK) |
 722              		.loc 1 871 0
 723 00c4 244B     		ldr	r3, .L108+4
 724 00c6 9A6E     		ldr	r2, [r3, #104]
 725 00c8 22F0F002 		bic	r2, r2, #240
 726 00cc 42EA0010 		orr	r0, r2, r0, lsl #4
 727              	.LVL87:
 728              	.L104:
 729 00d0 9866     		str	r0, [r3, #104]
 873:../emlib/src/em_cmu.c ****       break;
 730              		.loc 1 873 0
 731 00d2 10BD     		pop	{r4, pc}
 732              	.LVL88:
 733              	.L106:
 907:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 734              		.loc 1 907 0
 735 00d4 1F48     		ldr	r0, .L108
 736              	.LVL89:
 737 00d6 40F28B31 		movw	r1, #907
 738              	.LVL90:
 739 00da 36E0     		b	.L103
ARM GAS  /tmp/ccnCWsWR.s 			page 43


 740              	.LVL91:
 741              	.L87:
 913:../emlib/src/em_cmu.c ****     switch (clock)
 742              		.loc 1 913 0
 743 00dc 204B     		ldr	r3, .L108+12
 744 00de 9842     		cmp	r0, r3
 745 00e0 04D0     		beq	.L97
 746 00e2 03F50433 		add	r3, r3, #135168
 747 00e6 9842     		cmp	r0, r3
 748 00e8 13D0     		beq	.L98
 749 00ea 27E0     		b	.L107
 750              	.L97:
 917:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 751              		.loc 1 917 0
 752 00ec 0829     		cmp	r1, #8
 753 00ee 04D9     		bls	.L99
 917:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 754              		.loc 1 917 0 is_stmt 0 discriminator 1
 755 00f0 1848     		ldr	r0, .L108
 756              	.LVL92:
 757 00f2 40F29531 		movw	r1, #917
 758              	.LVL93:
 759 00f6 FFF7FEFF 		bl	assertEFM
 760              	.LVL94:
 761              	.L99:
 920:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFBPRESC0);
 762              		.loc 1 920 0 is_stmt 1
 763 00fa 4020     		movs	r0, #64
 764 00fc FFF7FEFF 		bl	CMU_Sync
 765              	.LVL95:
 923:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 766              		.loc 1 923 0
 767 0100 2046     		mov	r0, r4
 768 0102 FFF7FEFF 		bl	CMU_DivToLog2
 769              	.LVL96:
 925:../emlib/src/em_cmu.c ****       CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART0_MASK) |
 770              		.loc 1 925 0
 771 0106 144B     		ldr	r3, .L108+4
 772 0108 1A6F     		ldr	r2, [r3, #112]
 773 010a 22F00302 		bic	r2, r2, #3
 774 010e 1043     		orrs	r0, r0, r2
 775              	.LVL97:
 776 0110 12E0     		b	.L105
 777              	.LVL98:
 778              	.L98:
 932:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 779              		.loc 1 932 0
 780 0112 0829     		cmp	r1, #8
 781 0114 04D9     		bls	.L100
 932:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 782              		.loc 1 932 0 is_stmt 0 discriminator 1
 783 0116 0F48     		ldr	r0, .L108
 784              	.LVL99:
 785 0118 4FF46971 		mov	r1, #932
 786              	.LVL100:
 787 011c FFF7FEFF 		bl	assertEFM
 788              	.LVL101:
ARM GAS  /tmp/ccnCWsWR.s 			page 44


 789              	.L100:
 935:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFBPRESC0);
 790              		.loc 1 935 0 is_stmt 1
 791 0120 4020     		movs	r0, #64
 792 0122 FFF7FEFF 		bl	CMU_Sync
 793              	.LVL102:
 938:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 794              		.loc 1 938 0
 795 0126 2046     		mov	r0, r4
 796 0128 FFF7FEFF 		bl	CMU_DivToLog2
 797              	.LVL103:
 940:../emlib/src/em_cmu.c ****       CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART1_MASK) |
 798              		.loc 1 940 0
 799 012c 0A4B     		ldr	r3, .L108+4
 800 012e 1A6F     		ldr	r2, [r3, #112]
 801 0130 22F03002 		bic	r2, r2, #48
 802 0134 42EA0010 		orr	r0, r2, r0, lsl #4
 803              	.LVL104:
 804              	.L105:
 805 0138 1867     		str	r0, [r3, #112]
 942:../emlib/src/em_cmu.c ****       break;
 806              		.loc 1 942 0
 807 013a 10BD     		pop	{r4, pc}
 808              	.LVL105:
 809              	.L107:
 946:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 810              		.loc 1 946 0
 811 013c 0548     		ldr	r0, .L108
 812              	.LVL106:
 813 013e 40F2B231 		movw	r1, #946
 814              	.LVL107:
 815 0142 02E0     		b	.L103
 816              	.LVL108:
 817              	.L82:
 952:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 818              		.loc 1 952 0
 819 0144 0348     		ldr	r0, .L108
 820              	.LVL109:
 821 0146 4FF46E71 		mov	r1, #952
 822              	.LVL110:
 823              	.L103:
 824              		.loc 1 955 0
 825 014a BDE81040 		pop	{r4, lr}
 826              	.LVL111:
 952:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 827              		.loc 1 952 0
 828 014e FFF7FEBF 		b	assertEFM
 829              	.LVL112:
 830              	.L109:
 831 0152 00BF     		.align	2
 832              	.L108:
 833 0154 00000000 		.word	.LC0
 834 0158 00800C40 		.word	1074561024
 835 015c 30040800 		.word	525360
 836 0160 40051400 		.word	1312064
 837              		.cfi_endproc
 838              	.LFE86:
ARM GAS  /tmp/ccnCWsWR.s 			page 45


 840              		.section	.text.CMU_ClockEnable,"ax",%progbits
 841              		.align	1
 842              		.global	CMU_ClockEnable
 843              		.thumb
 844              		.thumb_func
 846              	CMU_ClockEnable:
 847              	.LFB87:
 956:../emlib/src/em_cmu.c **** 
 957:../emlib/src/em_cmu.c **** 
 958:../emlib/src/em_cmu.c **** /***************************************************************************//**
 959:../emlib/src/em_cmu.c ****  * @brief
 960:../emlib/src/em_cmu.c ****  *   Enable/disable a clock.
 961:../emlib/src/em_cmu.c ****  *
 962:../emlib/src/em_cmu.c ****  * @details
 963:../emlib/src/em_cmu.c ****  *   In general, module clocking is disabled after a reset. If a module
 964:../emlib/src/em_cmu.c ****  *   clock is disabled, the registers of that module are not accessible and
 965:../emlib/src/em_cmu.c ****  *   reading from such registers may return undefined values. Writing to
 966:../emlib/src/em_cmu.c ****  *   registers of clock disabled modules have no effect. One should normally
 967:../emlib/src/em_cmu.c ****  *   avoid accessing module registers of a module with a disabled clock.
 968:../emlib/src/em_cmu.c ****  *
 969:../emlib/src/em_cmu.c ****  * @note
 970:../emlib/src/em_cmu.c ****  *   If enabling/disabling a LF clock, synchronization into the low frequency
 971:../emlib/src/em_cmu.c ****  *   domain is required. If the same register is modified before a previous
 972:../emlib/src/em_cmu.c ****  *   update has completed, this function will stall until the previous
 973:../emlib/src/em_cmu.c ****  *   synchronization has completed. Please refer to CMU_FreezeEnable() for
 974:../emlib/src/em_cmu.c ****  *   a suggestion on how to reduce stalling time in some use cases.
 975:../emlib/src/em_cmu.c ****  *
 976:../emlib/src/em_cmu.c ****  * @param[in] clock
 977:../emlib/src/em_cmu.c ****  *   The clock to enable/disable. Notice that not all defined clock
 978:../emlib/src/em_cmu.c ****  *   points have separate enable/disable control, please refer to CMU overview
 979:../emlib/src/em_cmu.c ****  *   in reference manual.
 980:../emlib/src/em_cmu.c ****  *
 981:../emlib/src/em_cmu.c ****  * @param[in] enable
 982:../emlib/src/em_cmu.c ****  *   @li true - enable specified clock.
 983:../emlib/src/em_cmu.c ****  *   @li false - disable specified clock.
 984:../emlib/src/em_cmu.c ****  ******************************************************************************/
 985:../emlib/src/em_cmu.c **** void CMU_ClockEnable(CMU_Clock_TypeDef clock, bool enable)
 986:../emlib/src/em_cmu.c **** {
 848              		.loc 1 986 0
 849              		.cfi_startproc
 850              		@ args = 0, pretend = 0, frame = 0
 851              		@ frame_needed = 0, uses_anonymous_args = 0
 852              	.LVL113:
 987:../emlib/src/em_cmu.c ****   volatile uint32_t *reg;
 988:../emlib/src/em_cmu.c ****   uint32_t          bit;
 989:../emlib/src/em_cmu.c ****   uint32_t          sync = 0;
 990:../emlib/src/em_cmu.c **** 
 991:../emlib/src/em_cmu.c ****   /* Identify enable register */
 992:../emlib/src/em_cmu.c ****   switch ((clock >> CMU_EN_REG_POS) & CMU_EN_REG_MASK)
 853              		.loc 1 992 0
 854 0000 C0F30323 		ubfx	r3, r0, #8, #4
 855 0004 013B     		subs	r3, r3, #1
 986:../emlib/src/em_cmu.c **** {
 856              		.loc 1 986 0
 857 0006 70B5     		push	{r4, r5, r6, lr}
 858              		.cfi_def_cfa_offset 16
 859              		.cfi_offset 4, -16
ARM GAS  /tmp/ccnCWsWR.s 			page 46


 860              		.cfi_offset 5, -12
 861              		.cfi_offset 6, -8
 862              		.cfi_offset 14, -4
 986:../emlib/src/em_cmu.c **** {
 863              		.loc 1 986 0
 864 0008 0D46     		mov	r5, r1
 865              		.loc 1 992 0
 866 000a 052B     		cmp	r3, #5
 867 000c 10D8     		bhi	.L111
 868 000e DFE803F0 		tbb	[pc, r3]
 869              	.L113:
 870 0012 16       		.byte	(.L112-.L113)/2
 871 0013 19       		.byte	(.L120-.L113)/2
 872 0014 03       		.byte	(.L115-.L113)/2
 873 0015 06       		.byte	(.L116-.L113)/2
 874 0016 09       		.byte	(.L117-.L113)/2
 875 0017 0C       		.byte	(.L118-.L113)/2
 876              		.p2align 1
 877              	.L115:
 878              	.LVL114:
 989:../emlib/src/em_cmu.c ****   uint32_t          sync = 0;
 879              		.loc 1 989 0
 880 0018 0023     		movs	r3, #0
 993:../emlib/src/em_cmu.c ****   {
 994:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKDIV_EN_REG:
 995:../emlib/src/em_cmu.c ****     reg = &(CMU->HFPERCLKDIV);
 996:../emlib/src/em_cmu.c ****     break;
 997:../emlib/src/em_cmu.c **** 
 998:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKEN0_EN_REG:
 999:../emlib/src/em_cmu.c ****     reg = &(CMU->HFPERCLKEN0);
1000:../emlib/src/em_cmu.c ****     break;
1001:../emlib/src/em_cmu.c **** 
1002:../emlib/src/em_cmu.c ****   case CMU_HFCORECLKEN0_EN_REG:
1003:../emlib/src/em_cmu.c ****     reg = &(CMU->HFCORECLKEN0);
 881              		.loc 1 1003 0
 882 001a 124C     		ldr	r4, .L124
1004:../emlib/src/em_cmu.c **** 
1005:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
1006:../emlib/src/em_cmu.c ****     /* Set HFLE and DIV4 factor for peripheral clock
1007:../emlib/src/em_cmu.c ****        when running at frequencies higher than 32 MHz. */
1008:../emlib/src/em_cmu.c ****     if ( (cmuSelect_HFXO == CMU_ClockSelectGet(cmuClock_HF)) &&
1009:../emlib/src/em_cmu.c ****          ((SystemHFXOClockGet()/CMU_ClockDivGet(cmuClock_CORE)) >
1010:../emlib/src/em_cmu.c ****           CMU_MAX_FREQ_HFLE) )
1011:../emlib/src/em_cmu.c ****     {
1012:../emlib/src/em_cmu.c ****       /* Enable CMU HFLE */
1013:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 1);
1014:../emlib/src/em_cmu.c **** 
1015:../emlib/src/em_cmu.c ****       /* Set DIV4 factor for peripheral clock */
1016:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
1017:../emlib/src/em_cmu.c ****                          _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
1018:../emlib/src/em_cmu.c ****     }
1019:../emlib/src/em_cmu.c **** #endif
1020:../emlib/src/em_cmu.c ****     break;
 883              		.loc 1 1020 0
 884 001c 14E0     		b	.L114
 885              	.LVL115:
 886              	.L116:
ARM GAS  /tmp/ccnCWsWR.s 			page 47


1021:../emlib/src/em_cmu.c **** 
1022:../emlib/src/em_cmu.c ****   case CMU_LFACLKEN0_EN_REG:
1023:../emlib/src/em_cmu.c ****     reg  = &(CMU->LFACLKEN0);
1024:../emlib/src/em_cmu.c ****     sync = CMU_SYNCBUSY_LFACLKEN0;
 887              		.loc 1 1024 0
 888 001e 0123     		movs	r3, #1
1023:../emlib/src/em_cmu.c ****     reg  = &(CMU->LFACLKEN0);
 889              		.loc 1 1023 0
 890 0020 114C     		ldr	r4, .L124+4
1025:../emlib/src/em_cmu.c ****     break;
 891              		.loc 1 1025 0
 892 0022 11E0     		b	.L114
 893              	.LVL116:
 894              	.L117:
1026:../emlib/src/em_cmu.c **** 
1027:../emlib/src/em_cmu.c ****   case CMU_LFBCLKEN0_EN_REG:
1028:../emlib/src/em_cmu.c ****     reg  = &(CMU->LFBCLKEN0);
1029:../emlib/src/em_cmu.c ****     sync = CMU_SYNCBUSY_LFBCLKEN0;
 895              		.loc 1 1029 0
 896 0024 1023     		movs	r3, #16
1028:../emlib/src/em_cmu.c ****     reg  = &(CMU->LFBCLKEN0);
 897              		.loc 1 1028 0
 898 0026 114C     		ldr	r4, .L124+8
1030:../emlib/src/em_cmu.c ****     break;
 899              		.loc 1 1030 0
 900 0028 0EE0     		b	.L114
 901              	.LVL117:
 902              	.L118:
 989:../emlib/src/em_cmu.c ****   uint32_t          sync = 0;
 903              		.loc 1 989 0
 904 002a 0023     		movs	r3, #0
1031:../emlib/src/em_cmu.c **** 
1032:../emlib/src/em_cmu.c ****   case CMU_PCNT_EN_REG:
1033:../emlib/src/em_cmu.c ****     reg = &(CMU->PCNTCTRL);
 905              		.loc 1 1033 0
 906 002c 104C     		ldr	r4, .L124+12
1034:../emlib/src/em_cmu.c ****     break;
 907              		.loc 1 1034 0
 908 002e 0BE0     		b	.L114
 909              	.LVL118:
 910              	.L111:
1035:../emlib/src/em_cmu.c **** 
1036:../emlib/src/em_cmu.c ****   default: /* Cannot enable/disable clock point */
1037:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 911              		.loc 1 1037 0
 912 0030 1048     		ldr	r0, .L124+16
 913              	.LVL119:
 914 0032 40F20D41 		movw	r1, #1037
 915              	.LVL120:
1038:../emlib/src/em_cmu.c ****     return;
1039:../emlib/src/em_cmu.c ****   }
1040:../emlib/src/em_cmu.c **** 
1041:../emlib/src/em_cmu.c ****   /* Get bit position used to enable/disable */
1042:../emlib/src/em_cmu.c ****   bit = (clock >> CMU_EN_BIT_POS) & CMU_EN_BIT_MASK;
1043:../emlib/src/em_cmu.c **** 
1044:../emlib/src/em_cmu.c ****   /* LF synchronization required? */
1045:../emlib/src/em_cmu.c ****   if (sync)
ARM GAS  /tmp/ccnCWsWR.s 			page 48


1046:../emlib/src/em_cmu.c ****   {
1047:../emlib/src/em_cmu.c ****     CMU_Sync(sync);
1048:../emlib/src/em_cmu.c ****   }
1049:../emlib/src/em_cmu.c **** 
1050:../emlib/src/em_cmu.c ****   /* Set/clear bit as requested */
1051:../emlib/src/em_cmu.c ****   BITBAND_Peripheral(reg, bit, (unsigned int)enable);
1052:../emlib/src/em_cmu.c **** }
 916              		.loc 1 1052 0
 917 0036 BDE87040 		pop	{r4, r5, r6, lr}
1037:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 918              		.loc 1 1037 0
 919 003a FFF7FEBF 		b	assertEFM
 920              	.LVL121:
 921              	.L112:
 989:../emlib/src/em_cmu.c ****   uint32_t          sync = 0;
 922              		.loc 1 989 0
 923 003e 0023     		movs	r3, #0
 995:../emlib/src/em_cmu.c ****     reg = &(CMU->HFPERCLKDIV);
 924              		.loc 1 995 0
 925 0040 0D4C     		ldr	r4, .L124+20
 926 0042 01E0     		b	.L114
 927              	.L120:
 999:../emlib/src/em_cmu.c ****     reg = &(CMU->HFPERCLKEN0);
 928              		.loc 1 999 0
 929 0044 0D4C     		ldr	r4, .L124+24
 989:../emlib/src/em_cmu.c ****   uint32_t          sync = 0;
 930              		.loc 1 989 0
 931 0046 0023     		movs	r3, #0
 932              	.LVL122:
 933              	.L114:
1042:../emlib/src/em_cmu.c ****   bit = (clock >> CMU_EN_BIT_POS) & CMU_EN_BIT_MASK;
 934              		.loc 1 1042 0
 935 0048 C0F30436 		ubfx	r6, r0, #12, #5
 936              	.LVL123:
1045:../emlib/src/em_cmu.c ****   if (sync)
 937              		.loc 1 1045 0
 938 004c 13B1     		cbz	r3, .L119
1047:../emlib/src/em_cmu.c ****     CMU_Sync(sync);
 939              		.loc 1 1047 0
 940 004e 1846     		mov	r0, r3
 941              	.LVL124:
 942 0050 FFF7FEFF 		bl	CMU_Sync
 943              	.LVL125:
 944              	.L119:
 945              	.LBB34:
 946              	.LBB35:
 947              		.file 3 "../emlib/inc/em_bitband.h"
   1:../emlib/inc/em_bitband.h **** /***************************************************************************//**
   2:../emlib/inc/em_bitband.h ****  * @file
   3:../emlib/inc/em_bitband.h ****  * @brief Bitband Peripheral API
   4:../emlib/inc/em_bitband.h ****  * @author Energy Micro AS
   5:../emlib/inc/em_bitband.h ****  * @version 3.20.2
   6:../emlib/inc/em_bitband.h ****  *******************************************************************************
   7:../emlib/inc/em_bitband.h ****  * @section License
   8:../emlib/inc/em_bitband.h ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
   9:../emlib/inc/em_bitband.h ****  *******************************************************************************
  10:../emlib/inc/em_bitband.h ****  *
ARM GAS  /tmp/ccnCWsWR.s 			page 49


  11:../emlib/inc/em_bitband.h ****  * Permission is granted to anyone to use this software for any purpose,
  12:../emlib/inc/em_bitband.h ****  * including commercial applications, and to alter it and redistribute it
  13:../emlib/inc/em_bitband.h ****  * freely, subject to the following restrictions:
  14:../emlib/inc/em_bitband.h ****  *
  15:../emlib/inc/em_bitband.h ****  * 1. The origin of this software must not be misrepresented; you must not
  16:../emlib/inc/em_bitband.h ****  *    claim that you wrote the original software.
  17:../emlib/inc/em_bitband.h ****  * 2. Altered source versions must be plainly marked as such, and must not be
  18:../emlib/inc/em_bitband.h ****  *    misrepresented as being the original software.
  19:../emlib/inc/em_bitband.h ****  * 3. This notice may not be removed or altered from any source distribution.
  20:../emlib/inc/em_bitband.h ****  *
  21:../emlib/inc/em_bitband.h ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  22:../emlib/inc/em_bitband.h ****  * obligation to support this Software. Energy Micro AS is providing the
  23:../emlib/inc/em_bitband.h ****  * Software "AS IS", with no express or implied warranties of any kind,
  24:../emlib/inc/em_bitband.h ****  * including, but not limited to, any implied warranties of merchantability
  25:../emlib/inc/em_bitband.h ****  * or fitness for any particular purpose or warranties against infringement
  26:../emlib/inc/em_bitband.h ****  * of any proprietary rights of a third party.
  27:../emlib/inc/em_bitband.h ****  *
  28:../emlib/inc/em_bitband.h ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  29:../emlib/inc/em_bitband.h ****  * special damages, or any other relief, or for any claim by any third party,
  30:../emlib/inc/em_bitband.h ****  * arising from your use of this Software.
  31:../emlib/inc/em_bitband.h ****  *
  32:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  33:../emlib/inc/em_bitband.h **** #ifndef __EM_BITBAND_H
  34:../emlib/inc/em_bitband.h **** #define __EM_BITBAND_H
  35:../emlib/inc/em_bitband.h **** 
  36:../emlib/inc/em_bitband.h **** #include "em_device.h"
  37:../emlib/inc/em_bitband.h **** #ifdef __cplusplus
  38:../emlib/inc/em_bitband.h **** extern "C" {
  39:../emlib/inc/em_bitband.h **** #endif
  40:../emlib/inc/em_bitband.h **** 
  41:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  42:../emlib/inc/em_bitband.h ****  * @addtogroup EM_Library
  43:../emlib/inc/em_bitband.h ****  * @{
  44:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  45:../emlib/inc/em_bitband.h **** 
  46:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  47:../emlib/inc/em_bitband.h ****  * @addtogroup BITBAND
  48:../emlib/inc/em_bitband.h ****  * @brief BITBAND Peripheral API
  49:../emlib/inc/em_bitband.h ****  * @{
  50:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  51:../emlib/inc/em_bitband.h **** 
  52:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  53:../emlib/inc/em_bitband.h ****  * @brief
  54:../emlib/inc/em_bitband.h ****  *   Perform bit-band operation on peripheral memory location.
  55:../emlib/inc/em_bitband.h ****  *
  56:../emlib/inc/em_bitband.h ****  * @details
  57:../emlib/inc/em_bitband.h ****  *   Bit-banding provides atomic read-modify-write cycle for single bit
  58:../emlib/inc/em_bitband.h ****  *   modification. Please refer to the reference manual for further details
  59:../emlib/inc/em_bitband.h ****  *   about bit-banding.
  60:../emlib/inc/em_bitband.h ****  *
  61:../emlib/inc/em_bitband.h ****  * @note
  62:../emlib/inc/em_bitband.h ****  *   This function is only atomic on cores which fully support bitbanding.
  63:../emlib/inc/em_bitband.h ****  *
  64:../emlib/inc/em_bitband.h ****  * @param[in] addr Peripheral address location to modify bit in.
  65:../emlib/inc/em_bitband.h ****  *
  66:../emlib/inc/em_bitband.h ****  * @param[in] bit Bit position to modify, 0-31.
  67:../emlib/inc/em_bitband.h ****  *
ARM GAS  /tmp/ccnCWsWR.s 			page 50


  68:../emlib/inc/em_bitband.h ****  * @param[in] val Value to set bit to, 0 or 1.
  69:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  70:../emlib/inc/em_bitband.h **** __STATIC_INLINE void BITBAND_Peripheral(volatile uint32_t *addr,
  71:../emlib/inc/em_bitband.h ****                                         uint32_t bit,
  72:../emlib/inc/em_bitband.h ****                                         uint32_t val)
  73:../emlib/inc/em_bitband.h **** {
  74:../emlib/inc/em_bitband.h **** #if defined(BITBAND_PER_BASE)
  75:../emlib/inc/em_bitband.h ****   uint32_t tmp =
  76:../emlib/inc/em_bitband.h ****     BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);
 948              		.loc 3 76 0
 949 0054 04F10474 		add	r4, r4, #34603008
 950              	.LVL126:
 951 0058 06EBC406 		add	r6, r6, r4, lsl #3
 952              	.LVL127:
  75:../emlib/inc/em_bitband.h ****   uint32_t tmp =
 953              		.loc 3 75 0
 954 005c B600     		lsls	r6, r6, #2
  77:../emlib/inc/em_bitband.h **** 
  78:../emlib/inc/em_bitband.h ****   *((volatile uint32_t *)tmp) = (uint32_t)val;
 955              		.loc 3 78 0
 956 005e 3560     		str	r5, [r6]
 957 0060 70BD     		pop	{r4, r5, r6, pc}
 958              	.LVL128:
 959              	.L125:
 960 0062 00BF     		.align	2
 961              	.L124:
 962 0064 40800C40 		.word	1074561088
 963 0068 58800C40 		.word	1074561112
 964 006c 60800C40 		.word	1074561120
 965 0070 78800C40 		.word	1074561144
 966 0074 00000000 		.word	.LC0
 967 0078 08800C40 		.word	1074561032
 968 007c 44800C40 		.word	1074561092
 969              	.LBE35:
 970              	.LBE34:
 971              		.cfi_endproc
 972              	.LFE87:
 974              		.section	.text.CMU_ClockSelectGet,"ax",%progbits
 975              		.align	1
 976              		.global	CMU_ClockSelectGet
 977              		.thumb
 978              		.thumb_func
 980              	CMU_ClockSelectGet:
 981              	.LFB89:
1053:../emlib/src/em_cmu.c **** 
1054:../emlib/src/em_cmu.c **** 
1055:../emlib/src/em_cmu.c **** /***************************************************************************//**
1056:../emlib/src/em_cmu.c ****  * @brief
1057:../emlib/src/em_cmu.c ****  *   Get clock frequency for a clock point.
1058:../emlib/src/em_cmu.c ****  *
1059:../emlib/src/em_cmu.c ****  * @param[in] clock
1060:../emlib/src/em_cmu.c ****  *   Clock point to fetch frequency for.
1061:../emlib/src/em_cmu.c ****  *
1062:../emlib/src/em_cmu.c ****  * @return
1063:../emlib/src/em_cmu.c ****  *   The current frequency in Hz.
1064:../emlib/src/em_cmu.c ****  ******************************************************************************/
1065:../emlib/src/em_cmu.c **** uint32_t CMU_ClockFreqGet(CMU_Clock_TypeDef clock)
ARM GAS  /tmp/ccnCWsWR.s 			page 51


1066:../emlib/src/em_cmu.c **** {
1067:../emlib/src/em_cmu.c ****   uint32_t ret;
1068:../emlib/src/em_cmu.c **** 
1069:../emlib/src/em_cmu.c ****   switch(clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS))
1070:../emlib/src/em_cmu.c ****   {
1071:../emlib/src/em_cmu.c ****     case (CMU_HF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1072:../emlib/src/em_cmu.c ****     {
1073:../emlib/src/em_cmu.c ****       ret = SystemHFClockGet();
1074:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
1075:../emlib/src/em_cmu.c ****       /* Giant Gecko has an additional divider, not used by USBC */
1076:../emlib/src/em_cmu.c ****       ret = ret / (1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
1077:../emlib/src/em_cmu.c ****                    _CMU_CTRL_HFCLKDIV_SHIFT));
1078:../emlib/src/em_cmu.c **** #endif
1079:../emlib/src/em_cmu.c ****     } break;
1080:../emlib/src/em_cmu.c **** 
1081:../emlib/src/em_cmu.c **** #if defined(_CMU_HFPERCLKEN0_USART0_MASK) || \
1082:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_USART1_MASK) || \
1083:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_USART2_MASK) || \
1084:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_UART0_MASK) || \
1085:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_UART1_MASK) || \
1086:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER0_MASK) || \
1087:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER1_MASK) || \
1088:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER2_MASK) || \
1089:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER3_MASK) || \
1090:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_ACMP0_MASK) || \
1091:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_ACMP1_MASK) || \
1092:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_DAC0_MASK) || \
1093:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_IDAC0_MASK) || \
1094:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_ADC0_MASK) || \
1095:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_I2C0_MASK) || \
1096:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_I2C1_MASK) || \
1097:../emlib/src/em_cmu.c ****     defined(PRS_PRESENT) || \
1098:../emlib/src/em_cmu.c ****     defined(VCMP_PRESENT)|| \
1099:../emlib/src/em_cmu.c ****     defined(GPIO_PRESENT)
1100:../emlib/src/em_cmu.c ****     case (CMU_HFPER_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1101:../emlib/src/em_cmu.c ****     {
1102:../emlib/src/em_cmu.c ****       ret   = SystemHFClockGet();
1103:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
1104:../emlib/src/em_cmu.c ****       /* Leopard/Giant Gecko has an additional divider */
1105:../emlib/src/em_cmu.c ****       ret = ret / (1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
1106:../emlib/src/em_cmu.c ****                         _CMU_CTRL_HFCLKDIV_SHIFT));
1107:../emlib/src/em_cmu.c **** #endif
1108:../emlib/src/em_cmu.c ****       ret >>= (CMU->HFPERCLKDIV & _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK) >>
1109:../emlib/src/em_cmu.c ****               _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT;
1110:../emlib/src/em_cmu.c ****     } break;
1111:../emlib/src/em_cmu.c **** #endif
1112:../emlib/src/em_cmu.c **** 
1113:../emlib/src/em_cmu.c **** #if defined(AES_PRESENT) || \
1114:../emlib/src/em_cmu.c ****     defined(DMA_PRESENT) || \
1115:../emlib/src/em_cmu.c ****     defined(EBI_PRESENT) || \
1116:../emlib/src/em_cmu.c ****     defined(USB_PRESENT)
1117:../emlib/src/em_cmu.c ****     case (CMU_HFCORE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1118:../emlib/src/em_cmu.c ****     {
1119:../emlib/src/em_cmu.c ****       ret = SystemCoreClockGet();
1120:../emlib/src/em_cmu.c ****     } break;
1121:../emlib/src/em_cmu.c **** #endif
1122:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 52


1123:../emlib/src/em_cmu.c ****     case (CMU_LFA_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1124:../emlib/src/em_cmu.c ****     {
1125:../emlib/src/em_cmu.c ****       ret = CMU_LFClkGet(CMU_LFA);
1126:../emlib/src/em_cmu.c ****     } break;
1127:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_RTC_MASK)
1128:../emlib/src/em_cmu.c ****     case (CMU_RTC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1129:../emlib/src/em_cmu.c ****     {
1130:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1131:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK) >>
1132:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_RTC_SHIFT;
1133:../emlib/src/em_cmu.c ****     } break;
1134:../emlib/src/em_cmu.c **** #endif
1135:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_LETIMER0_MASK)
1136:../emlib/src/em_cmu.c ****     case (CMU_LETIMER_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1137:../emlib/src/em_cmu.c ****     {
1138:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1139:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK) >>
1140:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LETIMER0_SHIFT;
1141:../emlib/src/em_cmu.c ****     } break;
1142:../emlib/src/em_cmu.c **** #endif
1143:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_LCD_MASK)
1144:../emlib/src/em_cmu.c ****     case (CMU_LCDPRE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1145:../emlib/src/em_cmu.c ****     {
1146:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1147:../emlib/src/em_cmu.c ****       ret >>= ((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK) >>
1148:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LCD_SHIFT) + CMU_DivToLog2(cmuClkDiv_16);
1149:../emlib/src/em_cmu.c ****     } break;
1150:../emlib/src/em_cmu.c **** 
1151:../emlib/src/em_cmu.c ****     case (CMU_LCD_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1152:../emlib/src/em_cmu.c ****     {
1153:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1154:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK) >>
1155:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LCD_SHIFT;
1156:../emlib/src/em_cmu.c ****       ret /= (1 + ((CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK) >>
1157:../emlib/src/em_cmu.c ****                    _CMU_LCDCTRL_FDIV_SHIFT));
1158:../emlib/src/em_cmu.c ****     } break;
1159:../emlib/src/em_cmu.c **** #endif
1160:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_LESENSE_MASK)
1161:../emlib/src/em_cmu.c ****     case (CMU_LESENSE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1162:../emlib/src/em_cmu.c ****     {
1163:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1164:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK) >>
1165:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LESENSE_SHIFT;
1166:../emlib/src/em_cmu.c ****     } break;
1167:../emlib/src/em_cmu.c **** #endif
1168:../emlib/src/em_cmu.c ****     case (CMU_LFB_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1169:../emlib/src/em_cmu.c ****     {
1170:../emlib/src/em_cmu.c ****       ret = CMU_LFClkGet(CMU_LFB);
1171:../emlib/src/em_cmu.c ****     } break;
1172:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBCLKEN0_LEUART0_MASK)
1173:../emlib/src/em_cmu.c ****     case (CMU_LEUART0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1174:../emlib/src/em_cmu.c ****     {
1175:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFB);
1176:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK) >>
1177:../emlib/src/em_cmu.c ****               _CMU_LFBPRESC0_LEUART0_SHIFT;
1178:../emlib/src/em_cmu.c ****     } break;
1179:../emlib/src/em_cmu.c **** #endif
ARM GAS  /tmp/ccnCWsWR.s 			page 53


1180:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBCLKEN0_LEUART1_MASK)
1181:../emlib/src/em_cmu.c ****     case (CMU_LEUART1_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1182:../emlib/src/em_cmu.c ****     {
1183:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFB);
1184:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK) >>
1185:../emlib/src/em_cmu.c ****         _CMU_LFBPRESC0_LEUART1_SHIFT;
1186:../emlib/src/em_cmu.c ****     } break;
1187:../emlib/src/em_cmu.c **** #endif
1188:../emlib/src/em_cmu.c **** 
1189:../emlib/src/em_cmu.c ****     case (CMU_DBG_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1190:../emlib/src/em_cmu.c ****     {
1191:../emlib/src/em_cmu.c ****       ret  = CMU_DBGClkGet();
1192:../emlib/src/em_cmu.c ****     } break;
1193:../emlib/src/em_cmu.c **** 
1194:../emlib/src/em_cmu.c ****     case (CMU_AUX_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1195:../emlib/src/em_cmu.c ****     {
1196:../emlib/src/em_cmu.c ****       ret  = CMU_AUXClkGet();
1197:../emlib/src/em_cmu.c ****     } break;
1198:../emlib/src/em_cmu.c **** 
1199:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
1200:../emlib/src/em_cmu.c ****     case (CMU_USBC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1201:../emlib/src/em_cmu.c ****     {
1202:../emlib/src/em_cmu.c ****       ret = CMU_USBCClkGet();
1203:../emlib/src/em_cmu.c ****     } break;
1204:../emlib/src/em_cmu.c **** #endif
1205:../emlib/src/em_cmu.c ****     default:
1206:../emlib/src/em_cmu.c ****     {
1207:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1208:../emlib/src/em_cmu.c ****       ret = 0;
1209:../emlib/src/em_cmu.c ****     } break;
1210:../emlib/src/em_cmu.c ****   }
1211:../emlib/src/em_cmu.c ****   return ret;
1212:../emlib/src/em_cmu.c **** }
1213:../emlib/src/em_cmu.c **** 
1214:../emlib/src/em_cmu.c **** 
1215:../emlib/src/em_cmu.c **** /**************************************************************************//**
1216:../emlib/src/em_cmu.c ****  * @brief
1217:../emlib/src/em_cmu.c ****  *   Get currently selected reference clock used for a clock branch.
1218:../emlib/src/em_cmu.c ****  *
1219:../emlib/src/em_cmu.c ****  * @param[in] clock
1220:../emlib/src/em_cmu.c ****  *   Clock branch to fetch selected ref. clock for. One of:
1221:../emlib/src/em_cmu.c ****  *   @li #cmuClock_HF
1222:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFA
1223:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFB
1224:../emlib/src/em_cmu.c ****  *   @li #cmuClock_USBC
1225:../emlib/src/em_cmu.c ****  *   @li #cmuClock_DBG
1226:../emlib/src/em_cmu.c ****  *
1227:../emlib/src/em_cmu.c ****  * @return
1228:../emlib/src/em_cmu.c ****  *   Reference clock used for clocking selected branch, #cmuSelect_Error if
1229:../emlib/src/em_cmu.c ****  *   invalid @p clock provided.
1230:../emlib/src/em_cmu.c ****  *****************************************************************************/
1231:../emlib/src/em_cmu.c **** CMU_Select_TypeDef CMU_ClockSelectGet(CMU_Clock_TypeDef clock)
1232:../emlib/src/em_cmu.c **** {
 982              		.loc 1 1232 0
 983              		.cfi_startproc
 984              		@ args = 0, pretend = 0, frame = 0
 985              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccnCWsWR.s 			page 54


 986              	.LVL129:
1233:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef ret = cmuSelect_Disabled;
1234:../emlib/src/em_cmu.c ****   uint32_t           selReg;
1235:../emlib/src/em_cmu.c **** 
1236:../emlib/src/em_cmu.c ****   selReg = (clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
 987              		.loc 1 1236 0
 988 0000 00F00F00 		and	r0, r0, #15
 989              	.LVL130:
1237:../emlib/src/em_cmu.c **** 
1238:../emlib/src/em_cmu.c ****   switch (selReg)
 990              		.loc 1 1238 0
 991 0004 0138     		subs	r0, r0, #1
1232:../emlib/src/em_cmu.c **** {
 992              		.loc 1 1232 0
 993 0006 08B5     		push	{r3, lr}
 994              		.cfi_def_cfa_offset 8
 995              		.cfi_offset 3, -8
 996              		.cfi_offset 14, -4
 997              		.loc 1 1238 0
 998 0008 0328     		cmp	r0, #3
 999 000a 2ED8     		bhi	.L127
 1000 000c DFE800F0 		tbb	[pc, r0]
 1001              	.L129:
 1002 0010 02       		.byte	(.L128-.L129)/2
 1003 0011 14       		.byte	(.L130-.L129)/2
 1004 0012 1E       		.byte	(.L131-.L129)/2
 1005 0013 34       		.byte	(.L143-.L129)/2
 1006              		.p2align 1
 1007              	.L128:
 1008              	.LVL131:
 1009              	.LBB38:
 1010              	.LBB39:
1239:../emlib/src/em_cmu.c ****   {
1240:../emlib/src/em_cmu.c ****   case CMU_HFCLKSEL_REG:
1241:../emlib/src/em_cmu.c ****     switch (CMU->STATUS & (CMU_STATUS_HFRCOSEL | CMU_STATUS_HFXOSEL |
 1011              		.loc 1 1241 0
 1012 0014 1A4B     		ldr	r3, .L148
 1013 0016 DB6A     		ldr	r3, [r3, #44]
 1014 0018 03F47053 		and	r3, r3, #15360
 1015 001c B3F5805F 		cmp	r3, #4096
 1016 0020 08D0     		beq	.L144
 1017 0022 B3F5005F 		cmp	r3, #8192
 1018 0026 29D0     		beq	.L146
 1019 0028 B3F5006F 		cmp	r3, #2048
1242:../emlib/src/em_cmu.c ****                            CMU_STATUS_LFRCOSEL | CMU_STATUS_LFXOSEL))
1243:../emlib/src/em_cmu.c ****     {
1244:../emlib/src/em_cmu.c ****     case CMU_STATUS_LFXOSEL:
1245:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
1246:../emlib/src/em_cmu.c ****       break;
1247:../emlib/src/em_cmu.c **** 
1248:../emlib/src/em_cmu.c ****     case CMU_STATUS_LFRCOSEL:
1249:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
1250:../emlib/src/em_cmu.c ****       break;
1251:../emlib/src/em_cmu.c **** 
1252:../emlib/src/em_cmu.c ****     case CMU_STATUS_HFXOSEL:
1253:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFXO;
1254:../emlib/src/em_cmu.c ****       break;
ARM GAS  /tmp/ccnCWsWR.s 			page 55


1255:../emlib/src/em_cmu.c **** 
1256:../emlib/src/em_cmu.c ****     default:
1257:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFRCO;
 1020              		.loc 1 1257 0
 1021 002c 0CBF     		ite	eq
 1022 002e 0420     		moveq	r0, #4
 1023 0030 0520     		movne	r0, #5
 1024 0032 08BD     		pop	{r3, pc}
 1025              	.L144:
1249:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
 1026              		.loc 1 1249 0
 1027 0034 0320     		movs	r0, #3
 1028              	.LVL132:
 1029 0036 08BD     		pop	{r3, pc}
 1030              	.LVL133:
 1031              	.L130:
 1032              	.LBE39:
 1033              	.LBE38:
1258:../emlib/src/em_cmu.c ****       break;
1259:../emlib/src/em_cmu.c ****     }
1260:../emlib/src/em_cmu.c ****     break;
1261:../emlib/src/em_cmu.c **** 
1262:../emlib/src/em_cmu.c ****   case CMU_LFACLKSEL_REG:
1263:../emlib/src/em_cmu.c ****     switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFA_MASK)
 1034              		.loc 1 1263 0
 1035 0038 114B     		ldr	r3, .L148
 1036 003a 986A     		ldr	r0, [r3, #40]
 1037 003c 00F00300 		and	r0, r0, #3
 1038 0040 0228     		cmp	r0, #2
 1039 0042 1CD0     		beq	.L132
 1040 0044 0328     		cmp	r0, #3
 1041 0046 0ED0     		beq	.L141
 1042 0048 0128     		cmp	r0, #1
 1043 004a 08E0     		b	.L147
 1044              	.L131:
1264:../emlib/src/em_cmu.c ****     {
1265:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFA_LFRCO:
1266:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
1267:../emlib/src/em_cmu.c ****       break;
1268:../emlib/src/em_cmu.c **** 
1269:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFA_LFXO:
1270:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
1271:../emlib/src/em_cmu.c ****       break;
1272:../emlib/src/em_cmu.c **** 
1273:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
1274:../emlib/src/em_cmu.c ****       ret = cmuSelect_CORELEDIV2;
1275:../emlib/src/em_cmu.c ****       break;
1276:../emlib/src/em_cmu.c **** 
1277:../emlib/src/em_cmu.c ****     default:
1278:../emlib/src/em_cmu.c **** #if defined( CMU_LFCLKSEL_LFAE )
1279:../emlib/src/em_cmu.c ****       if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFAE_MASK)
1280:../emlib/src/em_cmu.c ****       {
1281:../emlib/src/em_cmu.c ****         ret = cmuSelect_ULFRCO;
1282:../emlib/src/em_cmu.c ****         break;
1283:../emlib/src/em_cmu.c ****       }
1284:../emlib/src/em_cmu.c **** #else
1285:../emlib/src/em_cmu.c ****       ret = cmuSelect_Disabled;
ARM GAS  /tmp/ccnCWsWR.s 			page 56


1286:../emlib/src/em_cmu.c **** #endif
1287:../emlib/src/em_cmu.c ****       break;
1288:../emlib/src/em_cmu.c ****     }
1289:../emlib/src/em_cmu.c ****     break;
1290:../emlib/src/em_cmu.c **** 
1291:../emlib/src/em_cmu.c ****   case CMU_LFBCLKSEL_REG:
1292:../emlib/src/em_cmu.c ****     switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFB_MASK)
 1045              		.loc 1 1292 0
 1046 004c 0C4B     		ldr	r3, .L148
 1047 004e 9B6A     		ldr	r3, [r3, #40]
 1048 0050 03F00C03 		and	r3, r3, #12
 1049 0054 082B     		cmp	r3, #8
 1050 0056 11D0     		beq	.L146
 1051 0058 0C2B     		cmp	r3, #12
 1052 005a 04D0     		beq	.L141
 1053 005c 042B     		cmp	r3, #4
 1054              	.L147:
1293:../emlib/src/em_cmu.c ****     {
1294:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFB_LFRCO:
1295:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
1296:../emlib/src/em_cmu.c ****       break;
1297:../emlib/src/em_cmu.c **** 
1298:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFB_LFXO:
1299:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
1300:../emlib/src/em_cmu.c ****       break;
1301:../emlib/src/em_cmu.c **** 
1302:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2:
1303:../emlib/src/em_cmu.c ****       ret = cmuSelect_CORELEDIV2;
1304:../emlib/src/em_cmu.c ****       break;
1305:../emlib/src/em_cmu.c **** 
1306:../emlib/src/em_cmu.c ****     default:
1307:../emlib/src/em_cmu.c **** #if defined( CMU_LFCLKSEL_LFBE )
1308:../emlib/src/em_cmu.c ****       if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFBE_MASK)
1309:../emlib/src/em_cmu.c ****       {
1310:../emlib/src/em_cmu.c ****         ret = cmuSelect_ULFRCO;
1311:../emlib/src/em_cmu.c ****         break;
1312:../emlib/src/em_cmu.c ****       }
1313:../emlib/src/em_cmu.c **** #else
1314:../emlib/src/em_cmu.c ****       ret = cmuSelect_Disabled;
 1055              		.loc 1 1314 0
 1056 005e 0CBF     		ite	eq
 1057 0060 0320     		moveq	r0, #3
 1058 0062 0120     		movne	r0, #1
 1059 0064 08BD     		pop	{r3, pc}
 1060              	.L141:
 1061              	.LVL134:
1303:../emlib/src/em_cmu.c ****       ret = cmuSelect_CORELEDIV2;
 1062              		.loc 1 1303 0
 1063 0066 0620     		movs	r0, #6
1304:../emlib/src/em_cmu.c ****       break;
 1064              		.loc 1 1304 0
 1065 0068 08BD     		pop	{r3, pc}
 1066              	.LVL135:
 1067              	.L127:
1315:../emlib/src/em_cmu.c **** #endif
1316:../emlib/src/em_cmu.c ****       break;
1317:../emlib/src/em_cmu.c ****     }
ARM GAS  /tmp/ccnCWsWR.s 			page 57


1318:../emlib/src/em_cmu.c ****     break;
1319:../emlib/src/em_cmu.c **** 
1320:../emlib/src/em_cmu.c ****   case CMU_DBGCLKSEL_REG:
1321:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_DBGCLK )
1322:../emlib/src/em_cmu.c ****     switch(CMU->CTRL & _CMU_CTRL_DBGCLK_MASK)
1323:../emlib/src/em_cmu.c ****     {
1324:../emlib/src/em_cmu.c ****     case CMU_CTRL_DBGCLK_AUXHFRCO:
1325:../emlib/src/em_cmu.c ****       ret = cmuSelect_AUXHFRCO;
1326:../emlib/src/em_cmu.c ****       break;
1327:../emlib/src/em_cmu.c **** 
1328:../emlib/src/em_cmu.c ****     case CMU_CTRL_DBGCLK_HFCLK:
1329:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFCLK;
1330:../emlib/src/em_cmu.c ****       break;
1331:../emlib/src/em_cmu.c ****     }
1332:../emlib/src/em_cmu.c **** #endif
1333:../emlib/src/em_cmu.c **** #if defined(_EFM32_GECKO_FAMILY)
1334:../emlib/src/em_cmu.c ****     ret = cmuSelect_AUXHFRCO;
1335:../emlib/src/em_cmu.c **** #endif
1336:../emlib/src/em_cmu.c ****     break;
1337:../emlib/src/em_cmu.c **** 
1338:../emlib/src/em_cmu.c **** 
1339:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
1340:../emlib/src/em_cmu.c ****   case CMU_USBCCLKSEL_REG:
1341:../emlib/src/em_cmu.c ****     switch(CMU->STATUS & (CMU_STATUS_USBCHFCLKSEL |
1342:../emlib/src/em_cmu.c ****                           CMU_STATUS_USBCLFXOSEL |
1343:../emlib/src/em_cmu.c ****                           CMU_STATUS_USBCLFRCOSEL))
1344:../emlib/src/em_cmu.c ****     {
1345:../emlib/src/em_cmu.c ****     case CMU_STATUS_USBCHFCLKSEL:
1346:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFCLK;
1347:../emlib/src/em_cmu.c ****       break;
1348:../emlib/src/em_cmu.c **** 
1349:../emlib/src/em_cmu.c ****     case CMU_STATUS_USBCLFXOSEL:
1350:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
1351:../emlib/src/em_cmu.c ****       break;
1352:../emlib/src/em_cmu.c **** 
1353:../emlib/src/em_cmu.c ****     case CMU_STATUS_USBCLFRCOSEL:
1354:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
1355:../emlib/src/em_cmu.c ****       break;
1356:../emlib/src/em_cmu.c **** 
1357:../emlib/src/em_cmu.c ****     default:
1358:../emlib/src/em_cmu.c ****       ret = cmuSelect_Disabled;
1359:../emlib/src/em_cmu.c ****       break;
1360:../emlib/src/em_cmu.c ****     }
1361:../emlib/src/em_cmu.c ****     break;
1362:../emlib/src/em_cmu.c **** #endif
1363:../emlib/src/em_cmu.c **** 
1364:../emlib/src/em_cmu.c ****   default:
1365:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1068              		.loc 1 1365 0
 1069 006a 0648     		ldr	r0, .L148+4
 1070 006c 40F25551 		movw	r1, #1365
 1071 0070 FFF7FEFF 		bl	assertEFM
 1072              	.LVL136:
1366:../emlib/src/em_cmu.c ****     ret = cmuSelect_Error;
 1073              		.loc 1 1366 0
 1074 0074 0020     		movs	r0, #0
1367:../emlib/src/em_cmu.c ****     break;
ARM GAS  /tmp/ccnCWsWR.s 			page 58


 1075              		.loc 1 1367 0
 1076 0076 08BD     		pop	{r3, pc}
 1077              	.LVL137:
 1078              	.L143:
1334:../emlib/src/em_cmu.c ****     ret = cmuSelect_AUXHFRCO;
 1079              		.loc 1 1334 0
 1080 0078 0720     		movs	r0, #7
 1081 007a 08BD     		pop	{r3, pc}
 1082              	.L146:
1299:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
 1083              		.loc 1 1299 0
 1084 007c 0220     		movs	r0, #2
 1085              	.L132:
 1086              	.LVL138:
1368:../emlib/src/em_cmu.c ****   }
1369:../emlib/src/em_cmu.c **** 
1370:../emlib/src/em_cmu.c ****   return ret;
1371:../emlib/src/em_cmu.c **** }
 1087              		.loc 1 1371 0
 1088 007e 08BD     		pop	{r3, pc}
 1089              	.L149:
 1090              		.align	2
 1091              	.L148:
 1092 0080 00800C40 		.word	1074561024
 1093 0084 00000000 		.word	.LC0
 1094              		.cfi_endproc
 1095              	.LFE89:
 1097              		.section	.text.CMU_ClockFreqGet,"ax",%progbits
 1098              		.align	1
 1099              		.global	CMU_ClockFreqGet
 1100              		.thumb
 1101              		.thumb_func
 1103              	CMU_ClockFreqGet:
 1104              	.LFB88:
1066:../emlib/src/em_cmu.c **** {
 1105              		.loc 1 1066 0
 1106              		.cfi_startproc
 1107              		@ args = 0, pretend = 0, frame = 0
 1108              		@ frame_needed = 0, uses_anonymous_args = 0
 1109              	.LVL139:
1069:../emlib/src/em_cmu.c ****   switch(clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS))
 1110              		.loc 1 1069 0
 1111 0000 00F47810 		and	r0, r0, #4063232
 1112              	.LVL140:
 1113 0004 B0F5202F 		cmp	r0, #655360
1066:../emlib/src/em_cmu.c **** {
 1114              		.loc 1 1066 0
 1115 0008 08B5     		push	{r3, lr}
 1116              		.cfi_def_cfa_offset 8
 1117              		.cfi_offset 3, -8
 1118              		.cfi_offset 14, -4
1069:../emlib/src/em_cmu.c ****   switch(clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS))
 1119              		.loc 1 1069 0
 1120 000a 3CD0     		beq	.L152
 1121 000c 19D8     		bhi	.L153
 1122 000e B0F5802F 		cmp	r0, #262144
 1123 0012 2FD0     		beq	.L154
ARM GAS  /tmp/ccnCWsWR.s 			page 59


 1124 0014 09D8     		bhi	.L155
 1125 0016 0028     		cmp	r0, #0
 1126 0018 52D0     		beq	.L172
 1127 001a B0F5003F 		cmp	r0, #131072
 1128 001e 57D1     		bne	.L151
1102:../emlib/src/em_cmu.c ****       ret   = SystemHFClockGet();
 1129              		.loc 1 1102 0
 1130 0020 FFF7FEFF 		bl	SystemHFClockGet
 1131              	.LVL141:
1108:../emlib/src/em_cmu.c ****       ret >>= (CMU->HFPERCLKDIV & _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK) >>
 1132              		.loc 1 1108 0
 1133 0024 2F4B     		ldr	r3, .L178
 1134 0026 9B68     		ldr	r3, [r3, #8]
 1135 0028 2AE0     		b	.L177
 1136              	.LVL142:
 1137              	.L155:
1069:../emlib/src/em_cmu.c ****   switch(clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS))
 1138              		.loc 1 1069 0
 1139 002a B0F5C02F 		cmp	r0, #393216
 1140 002e 25D0     		beq	.L158
 1141 0030 B0F5002F 		cmp	r0, #524288
 1142 0034 4CD1     		bne	.L151
1130:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
 1143              		.loc 1 1130 0
 1144 0036 0020     		movs	r0, #0
 1145 0038 FFF7FEFF 		bl	CMU_LFClkGet
 1146              	.LVL143:
1131:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK) >>
 1147              		.loc 1 1131 0
 1148 003c 294B     		ldr	r3, .L178
 1149 003e 9B6E     		ldr	r3, [r3, #104]
 1150 0040 1EE0     		b	.L177
 1151              	.LVL144:
 1152              	.L153:
1069:../emlib/src/em_cmu.c ****   switch(clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS))
 1153              		.loc 1 1069 0
 1154 0042 B0F5B01F 		cmp	r0, #1441792
 1155 0046 2CD0     		beq	.L160
 1156 0048 0DD8     		bhi	.L161
 1157 004a B0F5901F 		cmp	r0, #1179648
 1158 004e 23D0     		beq	.L162
 1159 0050 B0F5A01F 		cmp	r0, #1310720
 1160 0054 3CD1     		bne	.L151
1175:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFB);
 1161              		.loc 1 1175 0
 1162 0056 0120     		movs	r0, #1
 1163 0058 FFF7FEFF 		bl	CMU_LFClkGet
 1164              	.LVL145:
1176:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK) >>
 1165              		.loc 1 1176 0
 1166 005c 214B     		ldr	r3, .L178
 1167 005e 1B6F     		ldr	r3, [r3, #112]
 1168 0060 03F00303 		and	r3, r3, #3
 1169 0064 16E0     		b	.L175
 1170              	.LVL146:
 1171              	.L161:
1069:../emlib/src/em_cmu.c ****   switch(clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS))
ARM GAS  /tmp/ccnCWsWR.s 			page 60


 1172              		.loc 1 1069 0
 1173 0066 B0F5C01F 		cmp	r0, #1572864
 1174 006a 22D0     		beq	.L164
 1175 006c B0F5D01F 		cmp	r0, #1703936
 1176 0070 35D0     		beq	.L169
 1177 0072 2DE0     		b	.L151
 1178              	.L154:
1212:../emlib/src/em_cmu.c **** }
 1179              		.loc 1 1212 0
 1180 0074 BDE80840 		pop	{r3, lr}
1119:../emlib/src/em_cmu.c ****       ret = SystemCoreClockGet();
 1181              		.loc 1 1119 0
 1182 0078 FFF7FEBF 		b	SystemCoreClockGet
 1183              	.LVL147:
 1184              	.L158:
1125:../emlib/src/em_cmu.c ****       ret = CMU_LFClkGet(CMU_LFA);
 1185              		.loc 1 1125 0
 1186 007c 0020     		movs	r0, #0
 1187 007e 0CE0     		b	.L173
 1188              	.LVL148:
 1189              	.L177:
1131:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK) >>
 1190              		.loc 1 1131 0
 1191 0080 03F00F03 		and	r3, r3, #15
 1192 0084 06E0     		b	.L175
 1193              	.LVL149:
 1194              	.L152:
1138:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
 1195              		.loc 1 1138 0
 1196 0086 0020     		movs	r0, #0
 1197 0088 FFF7FEFF 		bl	CMU_LFClkGet
 1198              	.LVL150:
1139:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK) >>
 1199              		.loc 1 1139 0
 1200 008c 154B     		ldr	r3, .L178
 1201 008e 9B6E     		ldr	r3, [r3, #104]
 1202 0090 C3F30313 		ubfx	r3, r3, #4, #4
 1203              	.L175:
 1204 0094 D840     		lsrs	r0, r0, r3
 1205              	.LVL151:
1141:../emlib/src/em_cmu.c ****     } break;
 1206              		.loc 1 1141 0
 1207 0096 08BD     		pop	{r3, pc}
 1208              	.LVL152:
 1209              	.L162:
1170:../emlib/src/em_cmu.c ****       ret = CMU_LFClkGet(CMU_LFB);
 1210              		.loc 1 1170 0
 1211 0098 0120     		movs	r0, #1
 1212              	.L173:
1212:../emlib/src/em_cmu.c **** }
 1213              		.loc 1 1212 0
 1214 009a BDE80840 		pop	{r3, lr}
1170:../emlib/src/em_cmu.c ****       ret = CMU_LFClkGet(CMU_LFB);
 1215              		.loc 1 1170 0
 1216 009e FFF7FEBF 		b	CMU_LFClkGet
 1217              	.LVL153:
 1218              	.L160:
ARM GAS  /tmp/ccnCWsWR.s 			page 61


1183:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFB);
 1219              		.loc 1 1183 0
 1220 00a2 0120     		movs	r0, #1
 1221 00a4 FFF7FEFF 		bl	CMU_LFClkGet
 1222              	.LVL154:
1184:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK) >>
 1223              		.loc 1 1184 0
 1224 00a8 0E4B     		ldr	r3, .L178
 1225 00aa 1B6F     		ldr	r3, [r3, #112]
 1226 00ac C3F30113 		ubfx	r3, r3, #4, #2
 1227 00b0 F0E7     		b	.L175
 1228              	.LVL155:
 1229              	.L164:
 1230              	.LBB42:
 1231              	.LBB43:
 334:../emlib/src/em_cmu.c ****   clk = CMU_ClockSelectGet(cmuClock_DBG);
 1232              		.loc 1 334 0
 1233 00b2 0D48     		ldr	r0, .L178+4
 1234 00b4 FFF7FEFF 		bl	CMU_ClockSelectGet
 1235              	.LVL156:
 336:../emlib/src/em_cmu.c ****   switch(clk)
 1236              		.loc 1 336 0
 1237 00b8 0728     		cmp	r0, #7
 1238 00ba 10D0     		beq	.L169
 1239 00bc 0828     		cmp	r0, #8
 1240 00be 03D1     		bne	.L171
 1241              	.LVL157:
 1242              	.L172:
 1243              	.LBE43:
 1244              	.LBE42:
1212:../emlib/src/em_cmu.c **** }
 1245              		.loc 1 1212 0
 1246 00c0 BDE80840 		pop	{r3, lr}
 1247              	.LBB45:
 1248              	.LBB44:
 339:../emlib/src/em_cmu.c ****     ret = SystemHFClockGet();
 1249              		.loc 1 339 0
 1250 00c4 FFF7FEBF 		b	SystemHFClockGet
 1251              	.LVL158:
 1252              	.L171:
 352:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1253              		.loc 1 352 0
 1254 00c8 0848     		ldr	r0, .L178+8
 1255              	.LVL159:
 1256 00ca 4FF4B071 		mov	r1, #352
 1257 00ce 02E0     		b	.L176
 1258              	.L151:
 1259              	.LBE44:
 1260              	.LBE45:
1207:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1261              		.loc 1 1207 0
 1262 00d0 0648     		ldr	r0, .L178+8
 1263 00d2 40F2B741 		movw	r1, #1207
 1264              	.L176:
 1265 00d6 FFF7FEFF 		bl	assertEFM
 1266              	.LVL160:
1208:../emlib/src/em_cmu.c ****       ret = 0;
ARM GAS  /tmp/ccnCWsWR.s 			page 62


 1267              		.loc 1 1208 0
 1268 00da 0020     		movs	r0, #0
1209:../emlib/src/em_cmu.c ****     } break;
 1269              		.loc 1 1209 0
 1270 00dc 08BD     		pop	{r3, pc}
 1271              	.LVL161:
 1272              	.L169:
1196:../emlib/src/em_cmu.c ****       ret  = CMU_AUXClkGet();
 1273              		.loc 1 1196 0
 1274 00de 0448     		ldr	r0, .L178+12
 1275              	.LVL162:
1212:../emlib/src/em_cmu.c **** }
 1276              		.loc 1 1212 0
 1277 00e0 08BD     		pop	{r3, pc}
 1278              	.L179:
 1279 00e2 00BF     		.align	2
 1280              	.L178:
 1281 00e4 00800C40 		.word	1074561024
 1282 00e8 04001800 		.word	1572868
 1283 00ec 00000000 		.word	.LC0
 1284 00f0 809FD500 		.word	14000000
 1285              		.cfi_endproc
 1286              	.LFE88:
 1288              		.section	.text.CMU_FreezeEnable,"ax",%progbits
 1289              		.align	1
 1290              		.global	CMU_FreezeEnable
 1291              		.thumb
 1292              		.thumb_func
 1294              	CMU_FreezeEnable:
 1295              	.LFB91:
1372:../emlib/src/em_cmu.c **** 
1373:../emlib/src/em_cmu.c **** 
1374:../emlib/src/em_cmu.c **** /**************************************************************************//**
1375:../emlib/src/em_cmu.c ****  * @brief
1376:../emlib/src/em_cmu.c ****  *   Select reference clock/oscillator used for a clock branch.
1377:../emlib/src/em_cmu.c ****  *
1378:../emlib/src/em_cmu.c ****  * @details
1379:../emlib/src/em_cmu.c ****  *   Notice that if a selected reference is not enabled prior to selecting its
1380:../emlib/src/em_cmu.c ****  *   use, it will be enabled, and this function will wait for the selected
1381:../emlib/src/em_cmu.c ****  *   oscillator to be stable. It will however NOT be disabled if another
1382:../emlib/src/em_cmu.c ****  *   reference clock is selected later.
1383:../emlib/src/em_cmu.c ****  *
1384:../emlib/src/em_cmu.c ****  *   This feature is particularly important if selecting a new reference
1385:../emlib/src/em_cmu.c ****  *   clock for the clock branch clocking the core, otherwise the system
1386:../emlib/src/em_cmu.c ****  *   may halt.
1387:../emlib/src/em_cmu.c ****  *
1388:../emlib/src/em_cmu.c ****  * @param[in] clock
1389:../emlib/src/em_cmu.c ****  *   Clock branch to select reference clock for. One of:
1390:../emlib/src/em_cmu.c ****  *   @li #cmuClock_HF
1391:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFA
1392:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFB
1393:../emlib/src/em_cmu.c ****  *   @li #cmuClock_USBC
1394:../emlib/src/em_cmu.c ****  *   @li #cmuClock_DBG
1395:../emlib/src/em_cmu.c ****  *
1396:../emlib/src/em_cmu.c ****  * @param[in] ref
1397:../emlib/src/em_cmu.c ****  *   Reference selected for clocking, please refer to reference manual for
1398:../emlib/src/em_cmu.c ****  *   for details on which reference is available for a specific clock branch.
ARM GAS  /tmp/ccnCWsWR.s 			page 63


1399:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_HFRCO
1400:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_LFRCO
1401:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_HFXO
1402:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_LFXO
1403:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_CORELEDIV2
1404:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_AUXHFRC
1405:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_HFCLK
1406:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_ULFRCO
1407:../emlib/src/em_cmu.c ****  *****************************************************************************/
1408:../emlib/src/em_cmu.c **** void CMU_ClockSelectSet(CMU_Clock_TypeDef clock, CMU_Select_TypeDef ref)
1409:../emlib/src/em_cmu.c **** {
1410:../emlib/src/em_cmu.c ****   uint32_t        select = cmuOsc_HFRCO;
1411:../emlib/src/em_cmu.c ****   CMU_Osc_TypeDef osc    = cmuOsc_HFRCO;
1412:../emlib/src/em_cmu.c ****   uint32_t        freq;
1413:../emlib/src/em_cmu.c ****   uint32_t        selReg;
1414:../emlib/src/em_cmu.c **** #if !defined(_EFM32_GECKO_FAMILY)
1415:../emlib/src/em_cmu.c ****   uint32_t        lfExtended = 0;
1416:../emlib/src/em_cmu.c **** #endif
1417:../emlib/src/em_cmu.c ****   uint32_t        tmp;
1418:../emlib/src/em_cmu.c **** 
1419:../emlib/src/em_cmu.c ****   selReg = (clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
1420:../emlib/src/em_cmu.c **** 
1421:../emlib/src/em_cmu.c ****   switch (selReg)
1422:../emlib/src/em_cmu.c ****   {
1423:../emlib/src/em_cmu.c ****   case CMU_HFCLKSEL_REG:
1424:../emlib/src/em_cmu.c ****     switch (ref)
1425:../emlib/src/em_cmu.c ****     {
1426:../emlib/src/em_cmu.c ****     case cmuSelect_LFXO:
1427:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_LFXO;
1428:../emlib/src/em_cmu.c ****       osc    = cmuOsc_LFXO;
1429:../emlib/src/em_cmu.c ****       break;
1430:../emlib/src/em_cmu.c **** 
1431:../emlib/src/em_cmu.c ****     case cmuSelect_LFRCO:
1432:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_LFRCO;
1433:../emlib/src/em_cmu.c ****       osc    = cmuOsc_LFRCO;
1434:../emlib/src/em_cmu.c ****       break;
1435:../emlib/src/em_cmu.c **** 
1436:../emlib/src/em_cmu.c ****     case cmuSelect_HFXO:
1437:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_HFXO;
1438:../emlib/src/em_cmu.c ****       osc    = cmuOsc_HFXO;
1439:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
1440:../emlib/src/em_cmu.c ****       /* Adjust HFXO buffer current for high frequencies, enable HFLE for */
1441:../emlib/src/em_cmu.c ****       /* frequencies above 32MHz */
1442:../emlib/src/em_cmu.c ****       if(SystemHFXOClockGet() > CMU_MAX_FREQ_HFLE)
1443:../emlib/src/em_cmu.c ****       {
1444:../emlib/src/em_cmu.c ****         CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOBUFCUR_MASK) |
1445:../emlib/src/em_cmu.c ****           CMU_CTRL_HFXOBUFCUR_BOOSTABOVE32MHZ |
1446:../emlib/src/em_cmu.c ****           /* Must have HFLE enabled to access some LE peripherals >=32MHz */
1447:../emlib/src/em_cmu.c ****           CMU_CTRL_HFLE;
1448:../emlib/src/em_cmu.c **** 
1449:../emlib/src/em_cmu.c ****         /* Set HFLE and DIV4 factor for peripheral clock if HFCORE clock for
1450:../emlib/src/em_cmu.c ****            LE is enabled. */
1451:../emlib/src/em_cmu.c ****         if (CMU->HFCORECLKEN0 & CMU_HFCORECLKEN0_LE)
1452:../emlib/src/em_cmu.c ****         {
1453:../emlib/src/em_cmu.c ****           BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
1454:../emlib/src/em_cmu.c ****                              _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
1455:../emlib/src/em_cmu.c ****         }
ARM GAS  /tmp/ccnCWsWR.s 			page 64


1456:../emlib/src/em_cmu.c ****       } else {
1457:../emlib/src/em_cmu.c ****         /* This can happen if the user configures the EFM32_HFXO_FREQ to */
1458:../emlib/src/em_cmu.c ****         /* use another oscillator frequency */
1459:../emlib/src/em_cmu.c ****         CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOBUFCUR_MASK) |
1460:../emlib/src/em_cmu.c ****           CMU_CTRL_HFXOBUFCUR_BOOSTUPTO32MHZ;
1461:../emlib/src/em_cmu.c ****       }
1462:../emlib/src/em_cmu.c **** #endif
1463:../emlib/src/em_cmu.c ****       break;
1464:../emlib/src/em_cmu.c **** 
1465:../emlib/src/em_cmu.c ****     case cmuSelect_HFRCO:
1466:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_HFRCO;
1467:../emlib/src/em_cmu.c ****       osc    = cmuOsc_HFRCO;
1468:../emlib/src/em_cmu.c ****       break;
1469:../emlib/src/em_cmu.c **** 
1470:../emlib/src/em_cmu.c **** #if !defined(_EFM32_GECKO_FAMILY)
1471:../emlib/src/em_cmu.c ****     case cmuSelect_ULFRCO:
1472:../emlib/src/em_cmu.c ****       /* ULFRCO cannot be used as HFCLK  */
1473:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1474:../emlib/src/em_cmu.c ****       break;
1475:../emlib/src/em_cmu.c **** #endif
1476:../emlib/src/em_cmu.c **** 
1477:../emlib/src/em_cmu.c ****     default:
1478:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1479:../emlib/src/em_cmu.c ****       return;
1480:../emlib/src/em_cmu.c ****     }
1481:../emlib/src/em_cmu.c **** 
1482:../emlib/src/em_cmu.c ****     /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1483:../emlib/src/em_cmu.c ****     CMU_OscillatorEnable(osc, true, true);
1484:../emlib/src/em_cmu.c **** 
1485:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before selecting */
1486:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
1487:../emlib/src/em_cmu.c **** 
1488:../emlib/src/em_cmu.c ****     /* Switch to selected oscillator */
1489:../emlib/src/em_cmu.c ****     CMU->CMD = select;
1490:../emlib/src/em_cmu.c **** 
1491:../emlib/src/em_cmu.c ****     /* Keep EMU module informed */
1492:../emlib/src/em_cmu.c ****     EMU_UpdateOscConfig();
1493:../emlib/src/em_cmu.c **** 
1494:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable */
1495:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
1496:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
1497:../emlib/src/em_cmu.c **** 
1498:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for currently selected core clk */
1499:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
1500:../emlib/src/em_cmu.c ****     break;
1501:../emlib/src/em_cmu.c **** 
1502:../emlib/src/em_cmu.c ****   case CMU_LFACLKSEL_REG:
1503:../emlib/src/em_cmu.c ****   case CMU_LFBCLKSEL_REG:
1504:../emlib/src/em_cmu.c **** 
1505:../emlib/src/em_cmu.c ****     switch (ref)
1506:../emlib/src/em_cmu.c ****     {
1507:../emlib/src/em_cmu.c ****     case cmuSelect_Disabled:
1508:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_DISABLED;
1509:../emlib/src/em_cmu.c ****       break;
1510:../emlib/src/em_cmu.c **** 
1511:../emlib/src/em_cmu.c ****     case cmuSelect_LFXO:
1512:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
ARM GAS  /tmp/ccnCWsWR.s 			page 65


1513:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
1514:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_LFXO;
1515:../emlib/src/em_cmu.c ****       break;
1516:../emlib/src/em_cmu.c **** 
1517:../emlib/src/em_cmu.c ****     case cmuSelect_LFRCO:
1518:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1519:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
1520:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_LFRCO;
1521:../emlib/src/em_cmu.c ****       break;
1522:../emlib/src/em_cmu.c **** 
1523:../emlib/src/em_cmu.c ****     case cmuSelect_CORELEDIV2:
1524:../emlib/src/em_cmu.c ****       /* Ensure HFCORE to LE clocking is enabled */
1525:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKEN0), _CMU_HFCORECLKEN0_LE_SHIFT, 1);
1526:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2;
1527:../emlib/src/em_cmu.c **** #if defined(_EFM32_GIANT_FAMILY) || defined(_EFM32_WONDER_FAMILY)
1528:../emlib/src/em_cmu.c ****       /* If core frequency is > 32MHz on Giant/Leopard, enable HFLE and DIV4 */
1529:../emlib/src/em_cmu.c ****       freq = SystemCoreClockGet();
1530:../emlib/src/em_cmu.c ****       if(freq > CMU_MAX_FREQ_HFLE)
1531:../emlib/src/em_cmu.c ****       {
1532:../emlib/src/em_cmu.c ****         /* Enable CMU HFLE */
1533:../emlib/src/em_cmu.c ****         BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 1);
1534:../emlib/src/em_cmu.c **** 
1535:../emlib/src/em_cmu.c ****         /* Enable DIV4 factor for peripheral clock */
1536:../emlib/src/em_cmu.c ****         BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
1537:../emlib/src/em_cmu.c ****                            _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
1538:../emlib/src/em_cmu.c ****       }
1539:../emlib/src/em_cmu.c **** #endif
1540:../emlib/src/em_cmu.c ****       break;
1541:../emlib/src/em_cmu.c **** 
1542:../emlib/src/em_cmu.c **** #if !defined(_EFM32_GECKO_FAMILY)
1543:../emlib/src/em_cmu.c ****     case cmuSelect_ULFRCO:
1544:../emlib/src/em_cmu.c ****       /* ULFRCO is always enabled */
1545:../emlib/src/em_cmu.c ****       tmp        = _CMU_LFCLKSEL_LFA_DISABLED;
1546:../emlib/src/em_cmu.c ****       lfExtended = 1;
1547:../emlib/src/em_cmu.c ****       break;
1548:../emlib/src/em_cmu.c **** #endif
1549:../emlib/src/em_cmu.c **** 
1550:../emlib/src/em_cmu.c ****     default:
1551:../emlib/src/em_cmu.c ****       /* Illegal clock source for LFA/LFB selected */
1552:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1553:../emlib/src/em_cmu.c ****       return;
1554:../emlib/src/em_cmu.c ****     }
1555:../emlib/src/em_cmu.c **** 
1556:../emlib/src/em_cmu.c **** 
1557:../emlib/src/em_cmu.c ****     if (selReg == CMU_LFACLKSEL_REG)
1558:../emlib/src/em_cmu.c ****     {
1559:../emlib/src/em_cmu.c ****       #if !defined(_EFM32_GECKO_FAMILY)
1560:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~(_CMU_LFCLKSEL_LFA_MASK | _CMU_LFCLKSEL_LFAE_MASK) ) |
1561:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFA_SHIFT) | (lfExtended << _CMU_LFCLKSEL_LFAE_SHIFT);
1562:../emlib/src/em_cmu.c ****       #else
1563:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFA_MASK) |
1564:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFA_SHIFT);
1565:../emlib/src/em_cmu.c ****       #endif
1566:../emlib/src/em_cmu.c ****     }
1567:../emlib/src/em_cmu.c ****     else
1568:../emlib/src/em_cmu.c ****     {
1569:../emlib/src/em_cmu.c ****       #if !defined(_EFM32_GECKO_FAMILY)
ARM GAS  /tmp/ccnCWsWR.s 			page 66


1570:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~(_CMU_LFCLKSEL_LFB_MASK | _CMU_LFCLKSEL_LFBE_MASK) ) |
1571:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFB_SHIFT) | (lfExtended << _CMU_LFCLKSEL_LFBE_SHIFT);
1572:../emlib/src/em_cmu.c ****       #else
1573:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFB_MASK) |
1574:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFB_SHIFT);
1575:../emlib/src/em_cmu.c ****       #endif
1576:../emlib/src/em_cmu.c ****     }
1577:../emlib/src/em_cmu.c ****     break;
1578:../emlib/src/em_cmu.c **** 
1579:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_DBGCLK )
1580:../emlib/src/em_cmu.c ****   case CMU_DBGCLKSEL_REG:
1581:../emlib/src/em_cmu.c ****     switch(ref)
1582:../emlib/src/em_cmu.c ****     {
1583:../emlib/src/em_cmu.c ****     case cmuSelect_AUXHFRCO:
1584:../emlib/src/em_cmu.c ****       /* Select AUXHFRCO as debug clock */
1585:../emlib/src/em_cmu.c ****       CMU->CTRL = (CMU->CTRL & ~(_CMU_CTRL_DBGCLK_MASK))| CMU_CTRL_DBGCLK_AUXHFRCO;
1586:../emlib/src/em_cmu.c ****       break;
1587:../emlib/src/em_cmu.c **** 
1588:../emlib/src/em_cmu.c ****     case cmuSelect_HFCLK:
1589:../emlib/src/em_cmu.c ****       /* Select divided HFCLK as debug clock */
1590:../emlib/src/em_cmu.c ****       CMU->CTRL = (CMU->CTRL & ~(_CMU_CTRL_DBGCLK_MASK))| CMU_CTRL_DBGCLK_HFCLK;
1591:../emlib/src/em_cmu.c ****       break;
1592:../emlib/src/em_cmu.c **** 
1593:../emlib/src/em_cmu.c ****     default:
1594:../emlib/src/em_cmu.c ****       /* Illegal clock source for debug selected */
1595:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1596:../emlib/src/em_cmu.c ****       return;
1597:../emlib/src/em_cmu.c ****     }
1598:../emlib/src/em_cmu.c ****     break;
1599:../emlib/src/em_cmu.c **** #endif
1600:../emlib/src/em_cmu.c **** 
1601:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
1602:../emlib/src/em_cmu.c ****   case CMU_USBCCLKSEL_REG:
1603:../emlib/src/em_cmu.c ****     switch(ref)
1604:../emlib/src/em_cmu.c ****     {
1605:../emlib/src/em_cmu.c **** 
1606:../emlib/src/em_cmu.c ****     case cmuSelect_HFCLK:
1607:../emlib/src/em_cmu.c ****       /* Select undivided HFCLK as clock source for USB */
1608:../emlib/src/em_cmu.c ****       /* Oscillator must already be enabled, if not the core had stopped */
1609:../emlib/src/em_cmu.c ****       CMU->CMD = CMU_CMD_USBCCLKSEL_HFCLKNODIV;
1610:../emlib/src/em_cmu.c ****       /* Wait until clock is activated */
1611:../emlib/src/em_cmu.c ****       while((CMU->STATUS & CMU_STATUS_USBCHFCLKSEL)==0);
1612:../emlib/src/em_cmu.c ****       break;
1613:../emlib/src/em_cmu.c **** 
1614:../emlib/src/em_cmu.c ****     case cmuSelect_LFXO:
1615:../emlib/src/em_cmu.c ****       /* Select LFXO as clock source for USB, can only be used in sleep mode */
1616:../emlib/src/em_cmu.c **** 
1617:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1618:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
1619:../emlib/src/em_cmu.c **** 
1620:../emlib/src/em_cmu.c ****       /* Switch oscillator */
1621:../emlib/src/em_cmu.c ****       CMU->CMD = CMU_CMD_USBCCLKSEL_LFXO;
1622:../emlib/src/em_cmu.c **** 
1623:../emlib/src/em_cmu.c ****       /* Wait until clock is activated */
1624:../emlib/src/em_cmu.c ****       while((CMU->STATUS & CMU_STATUS_USBCLFXOSEL)==0);
1625:../emlib/src/em_cmu.c ****       break;
1626:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 67


1627:../emlib/src/em_cmu.c ****     case cmuSelect_LFRCO:
1628:../emlib/src/em_cmu.c ****       /* Select LFRCO as clock source for USB, can only be used in sleep mode */
1629:../emlib/src/em_cmu.c **** 
1630:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1631:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
1632:../emlib/src/em_cmu.c **** 
1633:../emlib/src/em_cmu.c ****       /* Switch oscillator */
1634:../emlib/src/em_cmu.c ****       CMU->CMD = CMU_CMD_USBCCLKSEL_LFRCO;
1635:../emlib/src/em_cmu.c **** 
1636:../emlib/src/em_cmu.c ****       /* Wait until clock is activated */
1637:../emlib/src/em_cmu.c ****       while((CMU->STATUS & CMU_STATUS_USBCLFRCOSEL)==0);
1638:../emlib/src/em_cmu.c ****       break;
1639:../emlib/src/em_cmu.c **** 
1640:../emlib/src/em_cmu.c ****     default:
1641:../emlib/src/em_cmu.c ****       /* Illegal clock source for USB */
1642:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1643:../emlib/src/em_cmu.c ****       return;
1644:../emlib/src/em_cmu.c ****     }
1645:../emlib/src/em_cmu.c ****     /* Wait until clock has been activated */
1646:../emlib/src/em_cmu.c ****     break;
1647:../emlib/src/em_cmu.c **** #endif
1648:../emlib/src/em_cmu.c **** 
1649:../emlib/src/em_cmu.c ****   default:
1650:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
1651:../emlib/src/em_cmu.c ****     break;
1652:../emlib/src/em_cmu.c ****   }
1653:../emlib/src/em_cmu.c **** }
1654:../emlib/src/em_cmu.c **** 
1655:../emlib/src/em_cmu.c **** 
1656:../emlib/src/em_cmu.c **** /**************************************************************************//**
1657:../emlib/src/em_cmu.c ****  * @brief
1658:../emlib/src/em_cmu.c ****  *   CMU low frequency register synchronization freeze control.
1659:../emlib/src/em_cmu.c ****  *
1660:../emlib/src/em_cmu.c ****  * @details
1661:../emlib/src/em_cmu.c ****  *   Some CMU registers requires synchronization into the low frequency (LF)
1662:../emlib/src/em_cmu.c ****  *   domain. The freeze feature allows for several such registers to be
1663:../emlib/src/em_cmu.c ****  *   modified before passing them to the LF domain simultaneously (which
1664:../emlib/src/em_cmu.c ****  *   takes place when the freeze mode is disabled).
1665:../emlib/src/em_cmu.c ****  *
1666:../emlib/src/em_cmu.c ****  *   Another usage scenario of this feature, is when using an API (such
1667:../emlib/src/em_cmu.c ****  *   as the CMU API) for modifying several bit fields consecutively in the
1668:../emlib/src/em_cmu.c ****  *   same register. If freeze mode is enabled during this sequence, stalling
1669:../emlib/src/em_cmu.c ****  *   can be avoided.
1670:../emlib/src/em_cmu.c ****  *
1671:../emlib/src/em_cmu.c ****  * @note
1672:../emlib/src/em_cmu.c ****  *   When enabling freeze mode, this function will wait for all current
1673:../emlib/src/em_cmu.c ****  *   ongoing CMU synchronization to LF domain to complete (Normally
1674:../emlib/src/em_cmu.c ****  *   synchronization will not be in progress.) However for this reason, when
1675:../emlib/src/em_cmu.c ****  *   using freeze mode, modifications of registers requiring LF synchronization
1676:../emlib/src/em_cmu.c ****  *   should be done within one freeze enable/disable block to avoid unecessary
1677:../emlib/src/em_cmu.c ****  *   stalling.
1678:../emlib/src/em_cmu.c ****  *
1679:../emlib/src/em_cmu.c ****  * @param[in] enable
1680:../emlib/src/em_cmu.c ****  *   @li true - enable freeze, modified registers are not propagated to the
1681:../emlib/src/em_cmu.c ****  *       LF domain
1682:../emlib/src/em_cmu.c ****  *   @li false - disable freeze, modified registers are propagated to LF
1683:../emlib/src/em_cmu.c ****  *       domain
ARM GAS  /tmp/ccnCWsWR.s 			page 68


1684:../emlib/src/em_cmu.c ****  *****************************************************************************/
1685:../emlib/src/em_cmu.c **** void CMU_FreezeEnable(bool enable)
1686:../emlib/src/em_cmu.c **** {
 1296              		.loc 1 1686 0
 1297              		.cfi_startproc
 1298              		@ args = 0, pretend = 0, frame = 0
 1299              		@ frame_needed = 0, uses_anonymous_args = 0
 1300              		@ link register save eliminated.
 1301              	.LVL163:
 1302 0000 054B     		ldr	r3, .L185
1687:../emlib/src/em_cmu.c ****   if (enable)
 1303              		.loc 1 1687 0
 1304 0002 30B1     		cbz	r0, .L181
 1305              	.L183:
1688:../emlib/src/em_cmu.c ****   {
1689:../emlib/src/em_cmu.c ****     /* Wait for any ongoing LF synchronization to complete. This is just to */
1690:../emlib/src/em_cmu.c ****     /* protect against the rare case when a user                            */
1691:../emlib/src/em_cmu.c ****     /* - modifies a register requiring LF sync                              */
1692:../emlib/src/em_cmu.c ****     /* - then enables freeze before LF sync completed                       */
1693:../emlib/src/em_cmu.c ****     /* - then modifies the same register again                              */
1694:../emlib/src/em_cmu.c ****     /* since modifying a register while it is in sync progress should be    */
1695:../emlib/src/em_cmu.c ****     /* avoided.                                                             */
1696:../emlib/src/em_cmu.c ****     while (CMU->SYNCBUSY)
 1306              		.loc 1 1696 0
 1307 0004 1A6D     		ldr	r2, [r3, #80]
 1308 0006 002A     		cmp	r2, #0
 1309 0008 FCD1     		bne	.L183
1697:../emlib/src/em_cmu.c ****       ;
1698:../emlib/src/em_cmu.c **** 
1699:../emlib/src/em_cmu.c ****     CMU->FREEZE = CMU_FREEZE_REGFREEZE;
 1310              		.loc 1 1699 0
 1311 000a 034B     		ldr	r3, .L185
 1312 000c 0122     		movs	r2, #1
 1313 000e 5A65     		str	r2, [r3, #84]
 1314 0010 7047     		bx	lr
 1315              	.L181:
1700:../emlib/src/em_cmu.c ****   }
1701:../emlib/src/em_cmu.c ****   else
1702:../emlib/src/em_cmu.c ****   {
1703:../emlib/src/em_cmu.c ****     CMU->FREEZE = 0;
 1316              		.loc 1 1703 0
 1317 0012 5865     		str	r0, [r3, #84]
 1318 0014 7047     		bx	lr
 1319              	.L186:
 1320 0016 00BF     		.align	2
 1321              	.L185:
 1322 0018 00800C40 		.word	1074561024
 1323              		.cfi_endproc
 1324              	.LFE91:
 1326              		.section	.text.CMU_HFRCOBandGet,"ax",%progbits
 1327              		.align	1
 1328              		.global	CMU_HFRCOBandGet
 1329              		.thumb
 1330              		.thumb_func
 1332              	CMU_HFRCOBandGet:
 1333              	.LFB92:
1704:../emlib/src/em_cmu.c ****   }
ARM GAS  /tmp/ccnCWsWR.s 			page 69


1705:../emlib/src/em_cmu.c **** }
1706:../emlib/src/em_cmu.c **** 
1707:../emlib/src/em_cmu.c **** 
1708:../emlib/src/em_cmu.c **** #if defined( _CMU_AUXHFRCOCTRL_BAND_MASK )
1709:../emlib/src/em_cmu.c **** /***************************************************************************//**
1710:../emlib/src/em_cmu.c ****  * @brief
1711:../emlib/src/em_cmu.c ****  *   Get AUXHFRCO band in use.
1712:../emlib/src/em_cmu.c ****  *
1713:../emlib/src/em_cmu.c ****  * @return
1714:../emlib/src/em_cmu.c ****  *   AUXHFRCO band in use.
1715:../emlib/src/em_cmu.c ****  ******************************************************************************/
1716:../emlib/src/em_cmu.c **** CMU_AUXHFRCOBand_TypeDef CMU_AUXHFRCOBandGet(void)
1717:../emlib/src/em_cmu.c **** {
1718:../emlib/src/em_cmu.c ****   return (CMU_AUXHFRCOBand_TypeDef)((CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_BAND_MASK) >>
1719:../emlib/src/em_cmu.c ****                                  _CMU_AUXHFRCOCTRL_BAND_SHIFT);
1720:../emlib/src/em_cmu.c **** }
1721:../emlib/src/em_cmu.c **** 
1722:../emlib/src/em_cmu.c **** /***************************************************************************//**
1723:../emlib/src/em_cmu.c ****  * @brief
1724:../emlib/src/em_cmu.c ****  *   Set AUIXHFRCO band and the tuning value based on the value in the
1725:../emlib/src/em_cmu.c ****  *   calibration table made during production.
1726:../emlib/src/em_cmu.c ****  *
1727:../emlib/src/em_cmu.c ****  * @param[in] band
1728:../emlib/src/em_cmu.c ****  *   AUXHFRCO band to activate.
1729:../emlib/src/em_cmu.c ****  ******************************************************************************/
1730:../emlib/src/em_cmu.c **** void CMU_AUXHFRCOBandSet(CMU_AUXHFRCOBand_TypeDef band)
1731:../emlib/src/em_cmu.c **** {
1732:../emlib/src/em_cmu.c ****   uint32_t           tuning;
1733:../emlib/src/em_cmu.c **** 
1734:../emlib/src/em_cmu.c ****   /* Read tuning value from calibration table */
1735:../emlib/src/em_cmu.c ****   switch (band)
1736:../emlib/src/em_cmu.c ****   {
1737:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_1MHz:
1738:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND1_MASK) >>
1739:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND1_SHIFT;
1740:../emlib/src/em_cmu.c ****     break;
1741:../emlib/src/em_cmu.c **** 
1742:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_7MHz:
1743:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND7_MASK) >>
1744:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND7_SHIFT;
1745:../emlib/src/em_cmu.c ****     break;
1746:../emlib/src/em_cmu.c **** 
1747:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_11MHz:
1748:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND11_MASK) >>
1749:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND11_SHIFT;
1750:../emlib/src/em_cmu.c ****     break;
1751:../emlib/src/em_cmu.c **** 
1752:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_14MHz:
1753:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND14_MASK) >>
1754:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND14_SHIFT;
1755:../emlib/src/em_cmu.c ****     break;
1756:../emlib/src/em_cmu.c **** 
1757:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_21MHz:
1758:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL1 & _DEVINFO_AUXHFRCOCAL1_BAND21_MASK) >>
1759:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL1_BAND21_SHIFT;
1760:../emlib/src/em_cmu.c ****     break;
1761:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 70


1762:../emlib/src/em_cmu.c **** #if defined( _CMU_AUXHFRCOCTRL_BAND_28MHZ )
1763:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_28MHz:
1764:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL1 & _DEVINFO_AUXHFRCOCAL1_BAND28_MASK) >>
1765:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL1_BAND28_SHIFT;
1766:../emlib/src/em_cmu.c ****     break;
1767:../emlib/src/em_cmu.c **** #endif
1768:../emlib/src/em_cmu.c **** 
1769:../emlib/src/em_cmu.c ****   default:
1770:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
1771:../emlib/src/em_cmu.c ****     return;
1772:../emlib/src/em_cmu.c ****   }
1773:../emlib/src/em_cmu.c **** 
1774:../emlib/src/em_cmu.c ****   /* Set band/tuning */
1775:../emlib/src/em_cmu.c ****   CMU->AUXHFRCOCTRL = (CMU->AUXHFRCOCTRL &
1776:../emlib/src/em_cmu.c ****                     ~(_CMU_AUXHFRCOCTRL_BAND_MASK | _CMU_AUXHFRCOCTRL_TUNING_MASK)) |
1777:../emlib/src/em_cmu.c ****                    (band << _CMU_AUXHFRCOCTRL_BAND_SHIFT) |
1778:../emlib/src/em_cmu.c ****                    (tuning << _CMU_AUXHFRCOCTRL_TUNING_SHIFT);
1779:../emlib/src/em_cmu.c **** 
1780:../emlib/src/em_cmu.c **** }
1781:../emlib/src/em_cmu.c **** #endif
1782:../emlib/src/em_cmu.c **** 
1783:../emlib/src/em_cmu.c **** 
1784:../emlib/src/em_cmu.c **** /***************************************************************************//**
1785:../emlib/src/em_cmu.c ****  * @brief
1786:../emlib/src/em_cmu.c ****  *   Get HFRCO band in use.
1787:../emlib/src/em_cmu.c ****  *
1788:../emlib/src/em_cmu.c ****  * @return
1789:../emlib/src/em_cmu.c ****  *   HFRCO band in use.
1790:../emlib/src/em_cmu.c ****  ******************************************************************************/
1791:../emlib/src/em_cmu.c **** CMU_HFRCOBand_TypeDef CMU_HFRCOBandGet(void)
1792:../emlib/src/em_cmu.c **** {
 1334              		.loc 1 1792 0
 1335              		.cfi_startproc
 1336              		@ args = 0, pretend = 0, frame = 0
 1337              		@ frame_needed = 0, uses_anonymous_args = 0
 1338              		@ link register save eliminated.
1793:../emlib/src/em_cmu.c ****   return (CMU_HFRCOBand_TypeDef)((CMU->HFRCOCTRL & _CMU_HFRCOCTRL_BAND_MASK) >>
 1339              		.loc 1 1793 0
 1340 0000 024B     		ldr	r3, .L188
 1341 0002 D868     		ldr	r0, [r3, #12]
1794:../emlib/src/em_cmu.c ****                                  _CMU_HFRCOCTRL_BAND_SHIFT);
1795:../emlib/src/em_cmu.c **** }
 1342              		.loc 1 1795 0
 1343 0004 C0F30220 		ubfx	r0, r0, #8, #3
 1344 0008 7047     		bx	lr
 1345              	.L189:
 1346 000a 00BF     		.align	2
 1347              	.L188:
 1348 000c 00800C40 		.word	1074561024
 1349              		.cfi_endproc
 1350              	.LFE92:
 1352              		.section	.text.CMU_HFRCOBandSet,"ax",%progbits
 1353              		.align	1
 1354              		.global	CMU_HFRCOBandSet
 1355              		.thumb
 1356              		.thumb_func
 1358              	CMU_HFRCOBandSet:
ARM GAS  /tmp/ccnCWsWR.s 			page 71


 1359              	.LFB93:
1796:../emlib/src/em_cmu.c **** 
1797:../emlib/src/em_cmu.c **** 
1798:../emlib/src/em_cmu.c **** /***************************************************************************//**
1799:../emlib/src/em_cmu.c ****  * @brief
1800:../emlib/src/em_cmu.c ****  *   Set HFRCO band and the tuning value based on the value in the calibration
1801:../emlib/src/em_cmu.c ****  *   table made during production.
1802:../emlib/src/em_cmu.c ****  *
1803:../emlib/src/em_cmu.c ****  * @param[in] band
1804:../emlib/src/em_cmu.c ****  *   HFRCO band to activate.
1805:../emlib/src/em_cmu.c ****  ******************************************************************************/
1806:../emlib/src/em_cmu.c **** void CMU_HFRCOBandSet(CMU_HFRCOBand_TypeDef band)
1807:../emlib/src/em_cmu.c **** {
 1360              		.loc 1 1807 0
 1361              		.cfi_startproc
 1362              		@ args = 0, pretend = 0, frame = 0
 1363              		@ frame_needed = 0, uses_anonymous_args = 0
 1364              	.LVL164:
 1365 0000 70B5     		push	{r4, r5, r6, lr}
 1366              		.cfi_def_cfa_offset 16
 1367              		.cfi_offset 4, -16
 1368              		.cfi_offset 5, -12
 1369              		.cfi_offset 6, -8
 1370              		.cfi_offset 14, -4
 1371              		.loc 1 1807 0
 1372 0002 0546     		mov	r5, r0
1808:../emlib/src/em_cmu.c ****   uint32_t           tuning;
1809:../emlib/src/em_cmu.c ****   uint32_t           freq;
1810:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef osc;
1811:../emlib/src/em_cmu.c **** 
1812:../emlib/src/em_cmu.c ****   /* Read tuning value from calibration table */
1813:../emlib/src/em_cmu.c ****   switch (band)
 1373              		.loc 1 1813 0
 1374 0004 0528     		cmp	r0, #5
 1375 0006 1CD8     		bhi	.L191
 1376 0008 DFE800F0 		tbb	[pc, r0]
 1377              	.L193:
 1378 000c 03       		.byte	(.L192-.L193)/2
 1379 000d 06       		.byte	(.L194-.L193)/2
 1380 000e 09       		.byte	(.L195-.L193)/2
 1381 000f 0E       		.byte	(.L196-.L193)/2
 1382 0010 12       		.byte	(.L197-.L193)/2
 1383 0011 16       		.byte	(.L198-.L193)/2
 1384              		.p2align 1
 1385              	.L192:
1814:../emlib/src/em_cmu.c ****   {
1815:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_1MHz:
1816:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND1_MASK) >>
 1386              		.loc 1 1816 0
 1387 0012 1D4B     		ldr	r3, .L204
 1388 0014 DC6A     		ldr	r4, [r3, #44]
 1389 0016 0DE0     		b	.L202
 1390              	.L194:
1817:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND1_SHIFT;
1818:../emlib/src/em_cmu.c ****     break;
1819:../emlib/src/em_cmu.c **** 
1820:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_7MHz:
ARM GAS  /tmp/ccnCWsWR.s 			page 72


1821:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND7_MASK) >>
 1391              		.loc 1 1821 0
 1392 0018 1B4B     		ldr	r3, .L204
 1393 001a DC6A     		ldr	r4, [r3, #44]
 1394 001c 0EE0     		b	.L203
 1395              	.L195:
1822:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND7_SHIFT;
1823:../emlib/src/em_cmu.c ****     break;
1824:../emlib/src/em_cmu.c **** 
1825:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_11MHz:
1826:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND11_MASK) >>
 1396              		.loc 1 1826 0
 1397 001e 1A4B     		ldr	r3, .L204
 1398 0020 DC6A     		ldr	r4, [r3, #44]
 1399 0022 C4F30744 		ubfx	r4, r4, #16, #8
 1400              	.LVL165:
1827:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND11_SHIFT;
1828:../emlib/src/em_cmu.c ****     break;
 1401              		.loc 1 1828 0
 1402 0026 13E0     		b	.L199
 1403              	.LVL166:
 1404              	.L196:
1829:../emlib/src/em_cmu.c **** 
1830:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_14MHz:
1831:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND14_MASK) >>
 1405              		.loc 1 1831 0
 1406 0028 174B     		ldr	r3, .L204
 1407 002a DC6A     		ldr	r4, [r3, #44]
 1408 002c 240E     		lsrs	r4, r4, #24
 1409              	.LVL167:
1832:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND14_SHIFT;
1833:../emlib/src/em_cmu.c ****     break;
 1410              		.loc 1 1833 0
 1411 002e 0FE0     		b	.L199
 1412              	.LVL168:
 1413              	.L197:
1834:../emlib/src/em_cmu.c **** 
1835:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_21MHz:
1836:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL1 & _DEVINFO_HFRCOCAL1_BAND21_MASK) >>
 1414              		.loc 1 1836 0
 1415 0030 154B     		ldr	r3, .L204
 1416 0032 1C6B     		ldr	r4, [r3, #48]
 1417              	.L202:
 1418 0034 E4B2     		uxtb	r4, r4
 1419              	.LVL169:
1837:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL1_BAND21_SHIFT;
1838:../emlib/src/em_cmu.c ****     break;
 1420              		.loc 1 1838 0
 1421 0036 0BE0     		b	.L199
 1422              	.LVL170:
 1423              	.L198:
1839:../emlib/src/em_cmu.c **** 
1840:../emlib/src/em_cmu.c **** #if defined( _CMU_HFRCOCTRL_BAND_28MHZ )
1841:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_28MHz:
1842:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL1 & _DEVINFO_HFRCOCAL1_BAND28_MASK) >>
 1424              		.loc 1 1842 0
 1425 0038 134B     		ldr	r3, .L204
ARM GAS  /tmp/ccnCWsWR.s 			page 73


 1426 003a 1C6B     		ldr	r4, [r3, #48]
 1427              	.L203:
 1428 003c C4F30724 		ubfx	r4, r4, #8, #8
 1429              	.LVL171:
1843:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL1_BAND28_SHIFT;
1844:../emlib/src/em_cmu.c ****     break;
 1430              		.loc 1 1844 0
 1431 0040 06E0     		b	.L199
 1432              	.LVL172:
 1433              	.L191:
1845:../emlib/src/em_cmu.c **** #endif
1846:../emlib/src/em_cmu.c **** 
1847:../emlib/src/em_cmu.c ****   default:
1848:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1434              		.loc 1 1848 0
 1435 0042 1248     		ldr	r0, .L204+4
 1436              	.LVL173:
 1437 0044 4FF4E761 		mov	r1, #1848
1849:../emlib/src/em_cmu.c ****     return;
1850:../emlib/src/em_cmu.c ****   }
1851:../emlib/src/em_cmu.c **** 
1852:../emlib/src/em_cmu.c ****   /* If HFRCO is used for core clock, we have to consider flash access WS. */
1853:../emlib/src/em_cmu.c ****   osc = CMU_ClockSelectGet(cmuClock_HF);
1854:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
1855:../emlib/src/em_cmu.c ****   {
1856:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before setting divider */
1857:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
1858:../emlib/src/em_cmu.c ****   }
1859:../emlib/src/em_cmu.c **** 
1860:../emlib/src/em_cmu.c ****   /* Set band/tuning */
1861:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL &
1862:../emlib/src/em_cmu.c ****                     ~(_CMU_HFRCOCTRL_BAND_MASK | _CMU_HFRCOCTRL_TUNING_MASK)) |
1863:../emlib/src/em_cmu.c ****                    (band << _CMU_HFRCOCTRL_BAND_SHIFT) |
1864:../emlib/src/em_cmu.c ****                    (tuning << _CMU_HFRCOCTRL_TUNING_SHIFT);
1865:../emlib/src/em_cmu.c **** 
1866:../emlib/src/em_cmu.c ****   /* If HFRCO is used for core clock, optimize flash WS */
1867:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
1868:../emlib/src/em_cmu.c ****   {
1869:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable and get current core clock */
1870:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
1871:../emlib/src/em_cmu.c ****     /* NOTE! We need at least 21 cycles before setting zero wait state to flash */
1872:../emlib/src/em_cmu.c ****     /* (i.e. WS0) when going from the 28MHz to 1MHz in the HFRCO band */
1873:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
1874:../emlib/src/em_cmu.c **** 
1875:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for current core clk */
1876:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
1877:../emlib/src/em_cmu.c ****   }
1878:../emlib/src/em_cmu.c **** }
 1438              		.loc 1 1878 0
 1439 0048 BDE87040 		pop	{r4, r5, r6, lr}
1848:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1440              		.loc 1 1848 0
 1441 004c FFF7FEBF 		b	assertEFM
 1442              	.LVL174:
 1443              	.L199:
1853:../emlib/src/em_cmu.c ****   osc = CMU_ClockSelectGet(cmuClock_HF);
 1444              		.loc 1 1853 0
ARM GAS  /tmp/ccnCWsWR.s 			page 74


 1445 0050 0120     		movs	r0, #1
 1446              	.LVL175:
 1447 0052 FFF7FEFF 		bl	CMU_ClockSelectGet
 1448              	.LVL176:
1854:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
 1449              		.loc 1 1854 0
 1450 0056 0528     		cmp	r0, #5
1853:../emlib/src/em_cmu.c ****   osc = CMU_ClockSelectGet(cmuClock_HF);
 1451              		.loc 1 1853 0
 1452 0058 0646     		mov	r6, r0
 1453              	.LVL177:
1854:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
 1454              		.loc 1 1854 0
 1455 005a 01D1     		bne	.L200
1857:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 1456              		.loc 1 1857 0
 1457 005c FFF7FEFF 		bl	CMU_FlashWaitStateMax
 1458              	.LVL178:
 1459              	.L200:
1861:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL &
 1460              		.loc 1 1861 0
 1461 0060 0B4A     		ldr	r2, .L204+8
1867:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
 1462              		.loc 1 1867 0
 1463 0062 052E     		cmp	r6, #5
1861:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL &
 1464              		.loc 1 1861 0
 1465 0064 D368     		ldr	r3, [r2, #12]
 1466 0066 23F4FF63 		bic	r3, r3, #2040
 1467 006a 23F00703 		bic	r3, r3, #7
1862:../emlib/src/em_cmu.c ****                     ~(_CMU_HFRCOCTRL_BAND_MASK | _CMU_HFRCOCTRL_TUNING_MASK)) |
 1468              		.loc 1 1862 0
 1469 006e 43EA0525 		orr	r5, r3, r5, lsl #8
1863:../emlib/src/em_cmu.c ****                    (band << _CMU_HFRCOCTRL_BAND_SHIFT) |
 1470              		.loc 1 1863 0
 1471 0072 45EA0404 		orr	r4, r5, r4
 1472              	.LVL179:
1861:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL &
 1473              		.loc 1 1861 0
 1474 0076 D460     		str	r4, [r2, #12]
1867:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
 1475              		.loc 1 1867 0
 1476 0078 05D1     		bne	.L190
1873:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 1477              		.loc 1 1873 0
 1478 007a FFF7FEFF 		bl	SystemCoreClockGet
 1479              	.LVL180:
 1480              		.loc 1 1878 0
 1481 007e BDE87040 		pop	{r4, r5, r6, lr}
 1482              	.LVL181:
1876:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 1483              		.loc 1 1876 0
 1484 0082 FFF7FEBF 		b	CMU_FlashWaitStateControl
 1485              	.LVL182:
 1486              	.L190:
 1487 0086 70BD     		pop	{r4, r5, r6, pc}
 1488              	.LVL183:
ARM GAS  /tmp/ccnCWsWR.s 			page 75


 1489              	.L205:
 1490              		.align	2
 1491              	.L204:
 1492 0088 B081E00F 		.word	266371504
 1493 008c 00000000 		.word	.LC0
 1494 0090 00800C40 		.word	1074561024
 1495              		.cfi_endproc
 1496              	.LFE93:
 1498              		.section	.text.CMU_HFRCOStartupDelayGet,"ax",%progbits
 1499              		.align	1
 1500              		.global	CMU_HFRCOStartupDelayGet
 1501              		.thumb
 1502              		.thumb_func
 1504              	CMU_HFRCOStartupDelayGet:
 1505              	.LFB94:
1879:../emlib/src/em_cmu.c **** 
1880:../emlib/src/em_cmu.c **** 
1881:../emlib/src/em_cmu.c **** /***************************************************************************//**
1882:../emlib/src/em_cmu.c ****  * @brief
1883:../emlib/src/em_cmu.c ****  *   Get the HFRCO startup delay.
1884:../emlib/src/em_cmu.c ****  *
1885:../emlib/src/em_cmu.c ****  * @details
1886:../emlib/src/em_cmu.c ****  *   Please refer to the reference manual for further details.
1887:../emlib/src/em_cmu.c ****  *
1888:../emlib/src/em_cmu.c ****  * @return
1889:../emlib/src/em_cmu.c ****  *   The startup delay in use.
1890:../emlib/src/em_cmu.c ****  ******************************************************************************/
1891:../emlib/src/em_cmu.c **** uint32_t CMU_HFRCOStartupDelayGet(void)
1892:../emlib/src/em_cmu.c **** {
 1506              		.loc 1 1892 0
 1507              		.cfi_startproc
 1508              		@ args = 0, pretend = 0, frame = 0
 1509              		@ frame_needed = 0, uses_anonymous_args = 0
 1510              		@ link register save eliminated.
1893:../emlib/src/em_cmu.c ****   return((CMU->HFRCOCTRL & _CMU_HFRCOCTRL_SUDELAY_MASK) >>
 1511              		.loc 1 1893 0
 1512 0000 024B     		ldr	r3, .L207
 1513 0002 D868     		ldr	r0, [r3, #12]
1894:../emlib/src/em_cmu.c ****          _CMU_HFRCOCTRL_SUDELAY_SHIFT);
1895:../emlib/src/em_cmu.c **** }
 1514              		.loc 1 1895 0
 1515 0004 C0F30430 		ubfx	r0, r0, #12, #5
 1516 0008 7047     		bx	lr
 1517              	.L208:
 1518 000a 00BF     		.align	2
 1519              	.L207:
 1520 000c 00800C40 		.word	1074561024
 1521              		.cfi_endproc
 1522              	.LFE94:
 1524              		.section	.text.CMU_HFRCOStartupDelaySet,"ax",%progbits
 1525              		.align	1
 1526              		.global	CMU_HFRCOStartupDelaySet
 1527              		.thumb
 1528              		.thumb_func
 1530              	CMU_HFRCOStartupDelaySet:
 1531              	.LFB95:
1896:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccnCWsWR.s 			page 76


1897:../emlib/src/em_cmu.c **** 
1898:../emlib/src/em_cmu.c **** /***************************************************************************//**
1899:../emlib/src/em_cmu.c ****  * @brief
1900:../emlib/src/em_cmu.c ****  *   Set the HFRCO startup delay.
1901:../emlib/src/em_cmu.c ****  *
1902:../emlib/src/em_cmu.c ****  * @details
1903:../emlib/src/em_cmu.c ****  *   Please refer to the reference manual for further details.
1904:../emlib/src/em_cmu.c ****  *
1905:../emlib/src/em_cmu.c ****  * @param[in] delay
1906:../emlib/src/em_cmu.c ****  *   The startup delay to set (<= 31).
1907:../emlib/src/em_cmu.c ****  ******************************************************************************/
1908:../emlib/src/em_cmu.c **** void CMU_HFRCOStartupDelaySet(uint32_t delay)
1909:../emlib/src/em_cmu.c **** {
 1532              		.loc 1 1909 0
 1533              		.cfi_startproc
 1534              		@ args = 0, pretend = 0, frame = 0
 1535              		@ frame_needed = 0, uses_anonymous_args = 0
 1536              	.LVL184:
1910:../emlib/src/em_cmu.c ****   EFM_ASSERT(delay <= 31);
 1537              		.loc 1 1910 0
 1538 0000 1F28     		cmp	r0, #31
1909:../emlib/src/em_cmu.c **** {
 1539              		.loc 1 1909 0
 1540 0002 10B5     		push	{r4, lr}
 1541              		.cfi_def_cfa_offset 8
 1542              		.cfi_offset 4, -8
 1543              		.cfi_offset 14, -4
1909:../emlib/src/em_cmu.c **** {
 1544              		.loc 1 1909 0
 1545 0004 0446     		mov	r4, r0
 1546              		.loc 1 1910 0
 1547 0006 04D9     		bls	.L210
 1548              		.loc 1 1910 0 is_stmt 0 discriminator 1
 1549 0008 0748     		ldr	r0, .L211
 1550              	.LVL185:
 1551 000a 40F27671 		movw	r1, #1910
 1552 000e FFF7FEFF 		bl	assertEFM
 1553              	.LVL186:
 1554              	.L210:
1911:../emlib/src/em_cmu.c **** 
1912:../emlib/src/em_cmu.c ****   delay         &= (_CMU_HFRCOCTRL_SUDELAY_MASK >> _CMU_HFRCOCTRL_SUDELAY_SHIFT);
1913:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL & ~(_CMU_HFRCOCTRL_SUDELAY_MASK)) |
 1555              		.loc 1 1913 0 is_stmt 1
 1556 0012 064B     		ldr	r3, .L211+4
1912:../emlib/src/em_cmu.c ****   delay         &= (_CMU_HFRCOCTRL_SUDELAY_MASK >> _CMU_HFRCOCTRL_SUDELAY_SHIFT);
 1557              		.loc 1 1912 0
 1558 0014 04F01F04 		and	r4, r4, #31
 1559              	.LVL187:
 1560              		.loc 1 1913 0
 1561 0018 DA68     		ldr	r2, [r3, #12]
 1562 001a 22F4F832 		bic	r2, r2, #126976
 1563 001e 42EA0434 		orr	r4, r2, r4, lsl #12
 1564              	.LVL188:
 1565 0022 DC60     		str	r4, [r3, #12]
 1566 0024 10BD     		pop	{r4, pc}
 1567              	.L212:
 1568 0026 00BF     		.align	2
ARM GAS  /tmp/ccnCWsWR.s 			page 77


 1569              	.L211:
 1570 0028 00000000 		.word	.LC0
 1571 002c 00800C40 		.word	1074561024
 1572              		.cfi_endproc
 1573              	.LFE95:
 1575              		.section	.text.CMU_LCDClkFDIVGet,"ax",%progbits
 1576              		.align	1
 1577              		.global	CMU_LCDClkFDIVGet
 1578              		.thumb
 1579              		.thumb_func
 1581              	CMU_LCDClkFDIVGet:
 1582              	.LFB96:
1914:../emlib/src/em_cmu.c ****                    (delay << _CMU_HFRCOCTRL_SUDELAY_SHIFT);
1915:../emlib/src/em_cmu.c **** }
1916:../emlib/src/em_cmu.c **** 
1917:../emlib/src/em_cmu.c **** 
1918:../emlib/src/em_cmu.c **** /***************************************************************************//**
1919:../emlib/src/em_cmu.c ****  * @brief
1920:../emlib/src/em_cmu.c ****  *   Get the LCD framerate divisor (FDIV) setting.
1921:../emlib/src/em_cmu.c ****  *
1922:../emlib/src/em_cmu.c ****  * @return
1923:../emlib/src/em_cmu.c ****  *   The LCD framerate divisor.
1924:../emlib/src/em_cmu.c ****  ******************************************************************************/
1925:../emlib/src/em_cmu.c **** uint32_t CMU_LCDClkFDIVGet(void)
1926:../emlib/src/em_cmu.c **** {
 1583              		.loc 1 1926 0
 1584              		.cfi_startproc
 1585              		@ args = 0, pretend = 0, frame = 0
 1586              		@ frame_needed = 0, uses_anonymous_args = 0
 1587              		@ link register save eliminated.
1927:../emlib/src/em_cmu.c **** #if defined(LCD_PRESENT)
1928:../emlib/src/em_cmu.c ****   return((CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK) >> _CMU_LCDCTRL_FDIV_SHIFT);
1929:../emlib/src/em_cmu.c **** #else
1930:../emlib/src/em_cmu.c ****   return 0;
1931:../emlib/src/em_cmu.c **** #endif /* defined(LCD_PRESENT) */
1932:../emlib/src/em_cmu.c **** }
 1588              		.loc 1 1932 0
 1589 0000 0020     		movs	r0, #0
 1590 0002 7047     		bx	lr
 1591              		.cfi_endproc
 1592              	.LFE96:
 1594              		.section	.text.CMU_LCDClkFDIVSet,"ax",%progbits
 1595              		.align	1
 1596              		.global	CMU_LCDClkFDIVSet
 1597              		.thumb
 1598              		.thumb_func
 1600              	CMU_LCDClkFDIVSet:
 1601              	.LFB97:
1933:../emlib/src/em_cmu.c **** 
1934:../emlib/src/em_cmu.c **** 
1935:../emlib/src/em_cmu.c **** /***************************************************************************//**
1936:../emlib/src/em_cmu.c ****  * @brief
1937:../emlib/src/em_cmu.c ****  *   Set the LCD framerate divisor (FDIV) setting.
1938:../emlib/src/em_cmu.c ****  *
1939:../emlib/src/em_cmu.c ****  * @note
1940:../emlib/src/em_cmu.c ****  *   The FDIV field (CMU LCDCTRL register) should only be modified while the
1941:../emlib/src/em_cmu.c ****  *   LCD module is clock disabled (CMU LFACLKEN0.LCD bit is 0). This function
ARM GAS  /tmp/ccnCWsWR.s 			page 78


1942:../emlib/src/em_cmu.c ****  *   will NOT modify FDIV if the LCD module clock is enabled. Please refer to
1943:../emlib/src/em_cmu.c ****  *   CMU_ClockEnable() for disabling/enabling LCD clock.
1944:../emlib/src/em_cmu.c ****  *
1945:../emlib/src/em_cmu.c ****  * @param[in] div
1946:../emlib/src/em_cmu.c ****  *   The FDIV setting to use.
1947:../emlib/src/em_cmu.c ****  ******************************************************************************/
1948:../emlib/src/em_cmu.c **** void CMU_LCDClkFDIVSet(uint32_t div)
1949:../emlib/src/em_cmu.c **** {
 1602              		.loc 1 1949 0
 1603              		.cfi_startproc
 1604              		@ args = 0, pretend = 0, frame = 0
 1605              		@ frame_needed = 0, uses_anonymous_args = 0
 1606              		@ link register save eliminated.
 1607              	.LVL189:
 1608 0000 7047     		bx	lr
 1609              		.cfi_endproc
 1610              	.LFE97:
 1612              		.section	.text.CMU_OscillatorEnable,"ax",%progbits
 1613              		.align	1
 1614              		.global	CMU_OscillatorEnable
 1615              		.thumb
 1616              		.thumb_func
 1618              	CMU_OscillatorEnable:
 1619              	.LFB98:
1950:../emlib/src/em_cmu.c **** #if defined(LCD_PRESENT)
1951:../emlib/src/em_cmu.c ****   EFM_ASSERT(div <= cmuClkDiv_128);
1952:../emlib/src/em_cmu.c **** 
1953:../emlib/src/em_cmu.c ****   /* Do not allow modification if LCD clock enabled */
1954:../emlib/src/em_cmu.c ****   if (CMU->LFACLKEN0 & CMU_LFACLKEN0_LCD)
1955:../emlib/src/em_cmu.c ****   {
1956:../emlib/src/em_cmu.c ****     return;
1957:../emlib/src/em_cmu.c ****   }
1958:../emlib/src/em_cmu.c **** 
1959:../emlib/src/em_cmu.c ****   div        <<= _CMU_LCDCTRL_FDIV_SHIFT;
1960:../emlib/src/em_cmu.c ****   div         &= _CMU_LCDCTRL_FDIV_MASK;
1961:../emlib/src/em_cmu.c ****   CMU->LCDCTRL = (CMU->LCDCTRL & ~_CMU_LCDCTRL_FDIV_MASK) | div;
1962:../emlib/src/em_cmu.c **** #else
1963:../emlib/src/em_cmu.c ****   (void)div;  /* Unused parameter */
1964:../emlib/src/em_cmu.c **** #endif /* defined(LCD_PRESENT) */
1965:../emlib/src/em_cmu.c **** }
1966:../emlib/src/em_cmu.c **** 
1967:../emlib/src/em_cmu.c **** 
1968:../emlib/src/em_cmu.c **** /***************************************************************************//**
1969:../emlib/src/em_cmu.c ****  * @brief
1970:../emlib/src/em_cmu.c ****  *   Enable/disable oscillator.
1971:../emlib/src/em_cmu.c ****  *
1972:../emlib/src/em_cmu.c ****  * @note
1973:../emlib/src/em_cmu.c ****  *   WARNING: When this function is called to disable either cmuOsc_LFXO or
1974:../emlib/src/em_cmu.c ****  *   cmuOsc_HFXO the LFXOMODE or HFXOMODE fields of the CMU_CTRL register
1975:../emlib/src/em_cmu.c ****  *   are reset to the reset value. I.e. if external clock sources are selected
1976:../emlib/src/em_cmu.c ****  *   in either LFXOMODE or HFXOMODE fields, the configuration will be cleared
1977:../emlib/src/em_cmu.c ****  *   and needs to be reconfigured if needed later.
1978:../emlib/src/em_cmu.c ****  *
1979:../emlib/src/em_cmu.c ****  * @param[in] osc
1980:../emlib/src/em_cmu.c ****  *   The oscillator to enable/disable.
1981:../emlib/src/em_cmu.c ****  *
1982:../emlib/src/em_cmu.c ****  * @param[in] enable
ARM GAS  /tmp/ccnCWsWR.s 			page 79


1983:../emlib/src/em_cmu.c ****  *   @li true - enable specified oscillator.
1984:../emlib/src/em_cmu.c ****  *   @li false - disable specified oscillator.
1985:../emlib/src/em_cmu.c ****  *
1986:../emlib/src/em_cmu.c ****  * @param[in] wait
1987:../emlib/src/em_cmu.c ****  *   Only used if @p enable is true.
1988:../emlib/src/em_cmu.c ****  *   @li true - wait for oscillator start-up time to timeout before returning.
1989:../emlib/src/em_cmu.c ****  *   @li false - do not wait for oscillator start-up time to timeout before
1990:../emlib/src/em_cmu.c ****  *     returning.
1991:../emlib/src/em_cmu.c ****  ******************************************************************************/
1992:../emlib/src/em_cmu.c **** void CMU_OscillatorEnable(CMU_Osc_TypeDef osc, bool enable, bool wait)
1993:../emlib/src/em_cmu.c **** {
 1620              		.loc 1 1993 0
 1621              		.cfi_startproc
 1622              		@ args = 0, pretend = 0, frame = 0
 1623              		@ frame_needed = 0, uses_anonymous_args = 0
 1624              	.LVL190:
 1625              		.loc 1 1993 0
 1626 0000 10B5     		push	{r4, lr}
 1627              		.cfi_def_cfa_offset 8
 1628              		.cfi_offset 4, -8
 1629              		.cfi_offset 14, -4
1994:../emlib/src/em_cmu.c ****   uint32_t status;
1995:../emlib/src/em_cmu.c ****   uint32_t enBit;
1996:../emlib/src/em_cmu.c ****   uint32_t disBit;
1997:../emlib/src/em_cmu.c **** 
1998:../emlib/src/em_cmu.c ****   switch (osc)
 1630              		.loc 1 1998 0
 1631 0002 0428     		cmp	r0, #4
 1632 0004 0FD8     		bhi	.L216
 1633 0006 DFE800F0 		tbb	[pc, r0]
 1634              	.L218:
 1635 000a 09       		.byte	(.L217-.L218)/2
 1636 000b 06       		.byte	(.L219-.L218)/2
 1637 000c 18       		.byte	(.L226-.L218)/2
 1638 000d 15       		.byte	(.L221-.L218)/2
 1639 000e 03       		.byte	(.L222-.L218)/2
 1640 000f 00       		.p2align 1
 1641              	.L222:
 1642              	.LVL191:
1999:../emlib/src/em_cmu.c ****   {
2000:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
2001:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_HFRCOEN;
2002:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_HFRCODIS;
2003:../emlib/src/em_cmu.c ****     status = CMU_STATUS_HFRCORDY;
2004:../emlib/src/em_cmu.c ****     break;
2005:../emlib/src/em_cmu.c **** 
2006:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
2007:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_HFXOEN;
2008:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_HFXODIS;
2009:../emlib/src/em_cmu.c ****     status = CMU_STATUS_HFXORDY;
2010:../emlib/src/em_cmu.c ****     break;
2011:../emlib/src/em_cmu.c **** 
2012:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
2013:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_AUXHFRCOEN;
 1643              		.loc 1 2013 0
 1644 0010 1020     		movs	r0, #16
 1645              	.LVL192:
ARM GAS  /tmp/ccnCWsWR.s 			page 80


2014:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_AUXHFRCODIS;
2015:../emlib/src/em_cmu.c ****     status = CMU_STATUS_AUXHFRCORDY;
 1646              		.loc 1 2015 0
 1647 0012 2023     		movs	r3, #32
2016:../emlib/src/em_cmu.c ****     break;
 1648              		.loc 1 2016 0
 1649 0014 13E0     		b	.L220
 1650              	.LVL193:
 1651              	.L219:
2017:../emlib/src/em_cmu.c **** 
2018:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
2019:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_LFRCOEN;
 1652              		.loc 1 2019 0
 1653 0016 4020     		movs	r0, #64
 1654              	.LVL194:
2020:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_LFRCODIS;
2021:../emlib/src/em_cmu.c ****     status = CMU_STATUS_LFRCORDY;
 1655              		.loc 1 2021 0
 1656 0018 8023     		movs	r3, #128
2022:../emlib/src/em_cmu.c ****     break;
 1657              		.loc 1 2022 0
 1658 001a 10E0     		b	.L220
 1659              	.LVL195:
 1660              	.L217:
2023:../emlib/src/em_cmu.c **** 
2024:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
2025:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_LFXOEN;
 1661              		.loc 1 2025 0
 1662 001c 4FF48070 		mov	r0, #256
 1663              	.LVL196:
2026:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_LFXODIS;
2027:../emlib/src/em_cmu.c ****     status = CMU_STATUS_LFXORDY;
 1664              		.loc 1 2027 0
 1665 0020 4FF40073 		mov	r3, #512
2028:../emlib/src/em_cmu.c ****     break;
 1666              		.loc 1 2028 0
 1667 0024 0BE0     		b	.L220
 1668              	.LVL197:
 1669              	.L216:
 1670              	.LBB48:
 1671              	.LBB49:
2029:../emlib/src/em_cmu.c **** 
2030:../emlib/src/em_cmu.c **** #if defined _CMU_LFCLKSEL_LFAE_ULFRCO
2031:../emlib/src/em_cmu.c ****   case cmuOsc_ULFRCO:
2032:../emlib/src/em_cmu.c ****     /* ULFRCO is always enabled, and cannot be turned off */
2033:../emlib/src/em_cmu.c ****     return;
2034:../emlib/src/em_cmu.c **** #endif
2035:../emlib/src/em_cmu.c **** 
2036:../emlib/src/em_cmu.c ****   default:
2037:../emlib/src/em_cmu.c ****     /* Undefined clock source */
2038:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1672              		.loc 1 2038 0
 1673 0026 0C48     		ldr	r0, .L230
 1674              	.LVL198:
 1675 0028 40F2F671 		movw	r1, #2038
 1676              	.LVL199:
 1677              	.LBE49:
ARM GAS  /tmp/ccnCWsWR.s 			page 81


 1678              	.LBE48:
2039:../emlib/src/em_cmu.c ****     return;
2040:../emlib/src/em_cmu.c ****   }
2041:../emlib/src/em_cmu.c **** 
2042:../emlib/src/em_cmu.c ****   if (enable)
2043:../emlib/src/em_cmu.c ****   {
2044:../emlib/src/em_cmu.c ****     CMU->OSCENCMD = enBit;
2045:../emlib/src/em_cmu.c **** 
2046:../emlib/src/em_cmu.c ****     /* Wait for clock to stabilize if requested */
2047:../emlib/src/em_cmu.c ****     if (wait)
2048:../emlib/src/em_cmu.c ****     {
2049:../emlib/src/em_cmu.c ****       while (!(CMU->STATUS & status))
2050:../emlib/src/em_cmu.c ****         ;
2051:../emlib/src/em_cmu.c ****     }
2052:../emlib/src/em_cmu.c ****   }
2053:../emlib/src/em_cmu.c ****   else
2054:../emlib/src/em_cmu.c ****   {
2055:../emlib/src/em_cmu.c ****     CMU->OSCENCMD = disBit;
2056:../emlib/src/em_cmu.c ****   }
2057:../emlib/src/em_cmu.c **** 
2058:../emlib/src/em_cmu.c ****   /* Keep EMU module informed */
2059:../emlib/src/em_cmu.c ****   EMU_UpdateOscConfig();
2060:../emlib/src/em_cmu.c **** }
 1679              		.loc 1 2060 0
 1680 002c BDE81040 		pop	{r4, lr}
 1681              	.LBB51:
 1682              	.LBB50:
2038:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1683              		.loc 1 2038 0
 1684 0030 FFF7FEBF 		b	assertEFM
 1685              	.LVL200:
 1686              	.L221:
 1687              	.LBE50:
 1688              	.LBE51:
2001:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_HFRCOEN;
 1689              		.loc 1 2001 0
 1690 0034 0120     		movs	r0, #1
 1691              	.LVL201:
2003:../emlib/src/em_cmu.c ****     status = CMU_STATUS_HFRCORDY;
 1692              		.loc 1 2003 0
 1693 0036 0223     		movs	r3, #2
 1694 0038 01E0     		b	.L220
 1695              	.LVL202:
 1696              	.L226:
2007:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_HFXOEN;
 1697              		.loc 1 2007 0
 1698 003a 0420     		movs	r0, #4
 1699              	.LVL203:
2009:../emlib/src/em_cmu.c ****     status = CMU_STATUS_HFXORDY;
 1700              		.loc 1 2009 0
 1701 003c 0823     		movs	r3, #8
 1702              	.L220:
 1703              	.LVL204:
 1704 003e 074C     		ldr	r4, .L230+4
2042:../emlib/src/em_cmu.c ****   if (enable)
 1705              		.loc 1 2042 0
 1706 0040 29B1     		cbz	r1, .L223
ARM GAS  /tmp/ccnCWsWR.s 			page 82


2044:../emlib/src/em_cmu.c ****     CMU->OSCENCMD = enBit;
 1707              		.loc 1 2044 0
 1708 0042 2062     		str	r0, [r4, #32]
2047:../emlib/src/em_cmu.c ****     if (wait)
 1709              		.loc 1 2047 0
 1710 0044 22B1     		cbz	r2, .L224
 1711              	.LVL205:
 1712              	.L225:
2049:../emlib/src/em_cmu.c ****       while (!(CMU->STATUS & status))
 1713              		.loc 1 2049 0
 1714 0046 E26A     		ldr	r2, [r4, #44]
 1715 0048 1342     		tst	r3, r2
 1716 004a FCD0     		beq	.L225
 1717 004c 00E0     		b	.L224
 1718              	.LVL206:
 1719              	.L223:
2055:../emlib/src/em_cmu.c ****     CMU->OSCENCMD = disBit;
 1720              		.loc 1 2055 0
 1721 004e 2362     		str	r3, [r4, #32]
 1722              	.LVL207:
 1723              	.L224:
 1724              		.loc 1 2060 0
 1725 0050 BDE81040 		pop	{r4, lr}
2059:../emlib/src/em_cmu.c ****   EMU_UpdateOscConfig();
 1726              		.loc 1 2059 0
 1727 0054 FFF7FEBF 		b	EMU_UpdateOscConfig
 1728              	.LVL208:
 1729              	.L231:
 1730              		.align	2
 1731              	.L230:
 1732 0058 00000000 		.word	.LC0
 1733 005c 00800C40 		.word	1074561024
 1734              		.cfi_endproc
 1735              	.LFE98:
 1737              		.section	.text.CMU_ClockSelectSet,"ax",%progbits
 1738              		.align	1
 1739              		.global	CMU_ClockSelectSet
 1740              		.thumb
 1741              		.thumb_func
 1743              	CMU_ClockSelectSet:
 1744              	.LFB90:
1409:../emlib/src/em_cmu.c **** {
 1745              		.loc 1 1409 0
 1746              		.cfi_startproc
 1747              		@ args = 0, pretend = 0, frame = 0
 1748              		@ frame_needed = 0, uses_anonymous_args = 0
 1749              	.LVL209:
 1750 0000 10B5     		push	{r4, lr}
 1751              		.cfi_def_cfa_offset 8
 1752              		.cfi_offset 4, -8
 1753              		.cfi_offset 14, -4
1419:../emlib/src/em_cmu.c ****   selReg = (clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
 1754              		.loc 1 1419 0
 1755 0002 00F00F04 		and	r4, r0, #15
 1756              	.LVL210:
1421:../emlib/src/em_cmu.c ****   switch (selReg)
 1757              		.loc 1 1421 0
ARM GAS  /tmp/ccnCWsWR.s 			page 83


 1758 0006 012C     		cmp	r4, #1
 1759 0008 03D0     		beq	.L234
 1760 000a 55D3     		bcc	.L233
 1761 000c 032C     		cmp	r4, #3
 1762 000e 26D9     		bls	.L252
 1763 0010 52E0     		b	.L233
 1764              	.L234:
1424:../emlib/src/em_cmu.c ****     switch (ref)
 1765              		.loc 1 1424 0
 1766 0012 0239     		subs	r1, r1, #2
 1767              	.LVL211:
 1768 0014 0329     		cmp	r1, #3
 1769 0016 09D8     		bhi	.L236
 1770 0018 DFE801F0 		tbb	[pc, r1]
 1771              	.L238:
 1772 001c 0C       		.byte	(.L237-.L238)/2
 1773 001d 0F       		.byte	(.L250-.L238)/2
 1774 001e 02       		.byte	(.L240-.L238)/2
 1775 001f 05       		.byte	(.L241-.L238)/2
 1776              		.p2align 1
 1777              	.L240:
 1778              	.LVL212:
1438:../emlib/src/em_cmu.c ****       osc    = cmuOsc_HFXO;
 1779              		.loc 1 1438 0
 1780 0020 0220     		movs	r0, #2
 1781              	.LVL213:
1437:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_HFXO;
 1782              		.loc 1 1437 0
 1783 0022 0446     		mov	r4, r0
 1784              	.LVL214:
1463:../emlib/src/em_cmu.c ****       break;
 1785              		.loc 1 1463 0
 1786 0024 0BE0     		b	.L239
 1787              	.LVL215:
 1788              	.L241:
1467:../emlib/src/em_cmu.c ****       osc    = cmuOsc_HFRCO;
 1789              		.loc 1 1467 0
 1790 0026 0320     		movs	r0, #3
 1791              	.LVL216:
1466:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_HFRCO;
 1792              		.loc 1 1466 0
 1793 0028 0124     		movs	r4, #1
 1794              	.LVL217:
1468:../emlib/src/em_cmu.c ****       break;
 1795              		.loc 1 1468 0
 1796 002a 08E0     		b	.L239
 1797              	.LVL218:
 1798              	.L236:
1478:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1799              		.loc 1 1478 0
 1800 002c 2648     		ldr	r0, .L255
 1801              	.LVL219:
 1802 002e 40F2C651 		movw	r1, #1478
 1803 0032 44E0     		b	.L253
 1804              	.LVL220:
 1805              	.L237:
1428:../emlib/src/em_cmu.c ****       osc    = cmuOsc_LFXO;
ARM GAS  /tmp/ccnCWsWR.s 			page 84


 1806              		.loc 1 1428 0
 1807 0034 0020     		movs	r0, #0
 1808              	.LVL221:
1427:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_LFXO;
 1809              		.loc 1 1427 0
 1810 0036 0424     		movs	r4, #4
 1811              	.LVL222:
 1812 0038 01E0     		b	.L239
 1813              	.LVL223:
 1814              	.L250:
1433:../emlib/src/em_cmu.c ****       osc    = cmuOsc_LFRCO;
 1815              		.loc 1 1433 0
 1816 003a 0120     		movs	r0, #1
 1817              	.LVL224:
1432:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_LFRCO;
 1818              		.loc 1 1432 0
 1819 003c 0324     		movs	r4, #3
 1820              	.LVL225:
 1821              	.L239:
1483:../emlib/src/em_cmu.c ****     CMU_OscillatorEnable(osc, true, true);
 1822              		.loc 1 1483 0
 1823 003e 0121     		movs	r1, #1
 1824 0040 0A46     		mov	r2, r1
 1825 0042 FFF7FEFF 		bl	CMU_OscillatorEnable
 1826              	.LVL226:
1486:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 1827              		.loc 1 1486 0
 1828 0046 FFF7FEFF 		bl	CMU_FlashWaitStateMax
 1829              	.LVL227:
1489:../emlib/src/em_cmu.c ****     CMU->CMD = select;
 1830              		.loc 1 1489 0
 1831 004a 204B     		ldr	r3, .L255+4
 1832 004c 5C62     		str	r4, [r3, #36]
1492:../emlib/src/em_cmu.c ****     EMU_UpdateOscConfig();
 1833              		.loc 1 1492 0
 1834 004e FFF7FEFF 		bl	EMU_UpdateOscConfig
 1835              	.LVL228:
1496:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 1836              		.loc 1 1496 0
 1837 0052 FFF7FEFF 		bl	SystemCoreClockGet
 1838              	.LVL229:
1653:../emlib/src/em_cmu.c **** }
 1839              		.loc 1 1653 0
 1840 0056 BDE81040 		pop	{r4, lr}
 1841              	.LVL230:
1499:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 1842              		.loc 1 1499 0
 1843 005a FFF7FEBF 		b	CMU_FlashWaitStateControl
 1844              	.LVL231:
 1845              	.L252:
1505:../emlib/src/em_cmu.c ****     switch (ref)
 1846              		.loc 1 1505 0
 1847 005e 0139     		subs	r1, r1, #1
 1848              	.LVL232:
 1849 0060 0529     		cmp	r1, #5
 1850 0062 17D8     		bhi	.L242
 1851 0064 DFE801F0 		tbb	[pc, r1]
ARM GAS  /tmp/ccnCWsWR.s 			page 85


 1852              	.L244:
 1853 0068 1A       		.byte	(.L251-.L244)/2
 1854 0069 03       		.byte	(.L245-.L244)/2
 1855 006a 0A       		.byte	(.L246-.L244)/2
 1856 006b 16       		.byte	(.L242-.L244)/2
 1857 006c 16       		.byte	(.L242-.L244)/2
 1858 006d 11       		.byte	(.L247-.L244)/2
 1859              		.p2align 1
 1860              	.L245:
1513:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
 1861              		.loc 1 1513 0
 1862 006e 0121     		movs	r1, #1
 1863 0070 0020     		movs	r0, #0
 1864              	.LVL233:
 1865 0072 0A46     		mov	r2, r1
 1866 0074 FFF7FEFF 		bl	CMU_OscillatorEnable
 1867              	.LVL234:
1514:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_LFXO;
 1868              		.loc 1 1514 0
 1869 0078 0223     		movs	r3, #2
1515:../emlib/src/em_cmu.c ****       break;
 1870              		.loc 1 1515 0
 1871 007a 10E0     		b	.L243
 1872              	.LVL235:
 1873              	.L246:
1519:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
 1874              		.loc 1 1519 0
 1875 007c 0120     		movs	r0, #1
 1876              	.LVL236:
 1877 007e 0146     		mov	r1, r0
 1878 0080 0246     		mov	r2, r0
 1879 0082 FFF7FEFF 		bl	CMU_OscillatorEnable
 1880              	.LVL237:
1520:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_LFRCO;
 1881              		.loc 1 1520 0
 1882 0086 0123     		movs	r3, #1
1521:../emlib/src/em_cmu.c ****       break;
 1883              		.loc 1 1521 0
 1884 0088 09E0     		b	.L243
 1885              	.LVL238:
 1886              	.L247:
 1887              	.LBB54:
 1888              	.LBB55:
 1889              		.loc 3 78 0
 1890 008a 114B     		ldr	r3, .L255+8
 1891 008c 0122     		movs	r2, #1
 1892 008e 1A60     		str	r2, [r3]
 1893              	.LBE55:
 1894              	.LBE54:
1526:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2;
 1895              		.loc 1 1526 0
 1896 0090 0323     		movs	r3, #3
 1897 0092 04E0     		b	.L243
 1898              	.LVL239:
 1899              	.L242:
1552:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1900              		.loc 1 1552 0
ARM GAS  /tmp/ccnCWsWR.s 			page 86


 1901 0094 0C48     		ldr	r0, .L255
 1902              	.LVL240:
 1903 0096 4FF4C261 		mov	r1, #1552
 1904 009a 10E0     		b	.L253
 1905              	.LVL241:
 1906              	.L251:
1508:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_DISABLED;
 1907              		.loc 1 1508 0
 1908 009c 0023     		movs	r3, #0
 1909              	.LVL242:
 1910              	.L243:
 1911 009e 0B4A     		ldr	r2, .L255+4
1557:../emlib/src/em_cmu.c ****     if (selReg == CMU_LFACLKSEL_REG)
 1912              		.loc 1 1557 0
 1913 00a0 022C     		cmp	r4, #2
1563:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFA_MASK) |
 1914              		.loc 1 1563 0
 1915 00a2 916A     		ldr	r1, [r2, #40]
 1916 00a4 0BBF     		itete	eq
 1917 00a6 21F00301 		biceq	r1, r1, #3
1573:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFB_MASK) |
 1918              		.loc 1 1573 0
 1919 00aa 21F00C01 		bicne	r1, r1, #12
1563:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFA_MASK) |
 1920              		.loc 1 1563 0
 1921 00ae 0B43     		orreq	r3, r3, r1
 1922              	.LVL243:
1573:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFB_MASK) |
 1923              		.loc 1 1573 0
 1924 00b0 41EA8303 		orrne	r3, r1, r3, lsl #2
 1925 00b4 9362     		str	r3, [r2, #40]
 1926 00b6 10BD     		pop	{r4, pc}
 1927              	.LVL244:
 1928              	.L233:
1650:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1929              		.loc 1 1650 0
 1930 00b8 0348     		ldr	r0, .L255
 1931              	.LVL245:
 1932 00ba 40F27261 		movw	r1, #1650
 1933              	.LVL246:
 1934              	.L253:
1653:../emlib/src/em_cmu.c **** }
 1935              		.loc 1 1653 0
 1936 00be BDE81040 		pop	{r4, lr}
 1937              	.LVL247:
1650:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1938              		.loc 1 1650 0
 1939 00c2 FFF7FEBF 		b	assertEFM
 1940              	.LVL248:
 1941              	.L256:
 1942 00c6 00BF     		.align	2
 1943              	.L255:
 1944 00c8 00000000 		.word	.LC0
 1945 00cc 00800C40 		.word	1074561024
 1946 00d0 08089043 		.word	1133512712
 1947              		.cfi_endproc
 1948              	.LFE90:
ARM GAS  /tmp/ccnCWsWR.s 			page 87


 1950              		.section	.text.CMU_OscillatorTuningGet,"ax",%progbits
 1951              		.align	1
 1952              		.global	CMU_OscillatorTuningGet
 1953              		.thumb
 1954              		.thumb_func
 1956              	CMU_OscillatorTuningGet:
 1957              	.LFB99:
2061:../emlib/src/em_cmu.c **** 
2062:../emlib/src/em_cmu.c **** 
2063:../emlib/src/em_cmu.c **** /***************************************************************************//**
2064:../emlib/src/em_cmu.c ****  * @brief
2065:../emlib/src/em_cmu.c ****  *   Get oscillator frequency tuning setting.
2066:../emlib/src/em_cmu.c ****  *
2067:../emlib/src/em_cmu.c ****  * @param[in] osc
2068:../emlib/src/em_cmu.c ****  *   Oscillator to get tuning value for, one of:
2069:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_LFRCO
2070:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_HFRCO
2071:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_AUXHFRCO
2072:../emlib/src/em_cmu.c ****  *
2073:../emlib/src/em_cmu.c ****  * @return
2074:../emlib/src/em_cmu.c ****  *   The oscillator frequency tuning setting in use.
2075:../emlib/src/em_cmu.c ****  ******************************************************************************/
2076:../emlib/src/em_cmu.c **** uint32_t CMU_OscillatorTuningGet(CMU_Osc_TypeDef osc)
2077:../emlib/src/em_cmu.c **** {
 1958              		.loc 1 2077 0
 1959              		.cfi_startproc
 1960              		@ args = 0, pretend = 0, frame = 0
 1961              		@ frame_needed = 0, uses_anonymous_args = 0
 1962              	.LVL249:
2078:../emlib/src/em_cmu.c ****   uint32_t ret;
2079:../emlib/src/em_cmu.c **** 
2080:../emlib/src/em_cmu.c ****   switch (osc)
 1963              		.loc 1 2080 0
 1964 0000 0328     		cmp	r0, #3
2077:../emlib/src/em_cmu.c **** {
 1965              		.loc 1 2077 0
 1966 0002 08B5     		push	{r3, lr}
 1967              		.cfi_def_cfa_offset 8
 1968              		.cfi_offset 3, -8
 1969              		.cfi_offset 14, -4
 1970              		.loc 1 2080 0
 1971 0004 08D0     		beq	.L259
 1972 0006 0428     		cmp	r0, #4
 1973 0008 09D0     		beq	.L260
 1974 000a 0128     		cmp	r0, #1
 1975 000c 0BD1     		bne	.L263
2081:../emlib/src/em_cmu.c ****   {
2082:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
2083:../emlib/src/em_cmu.c ****     ret = (CMU->LFRCOCTRL & _CMU_LFRCOCTRL_TUNING_MASK) >>
 1976              		.loc 1 2083 0
 1977 000e 094B     		ldr	r3, .L265
 1978 0010 1869     		ldr	r0, [r3, #16]
 1979              	.LVL250:
 1980 0012 00F07F00 		and	r0, r0, #127
 1981              	.LVL251:
2084:../emlib/src/em_cmu.c ****           _CMU_LFRCOCTRL_TUNING_SHIFT;
2085:../emlib/src/em_cmu.c ****     break;
ARM GAS  /tmp/ccnCWsWR.s 			page 88


 1982              		.loc 1 2085 0
 1983 0016 08BD     		pop	{r3, pc}
 1984              	.LVL252:
 1985              	.L259:
2086:../emlib/src/em_cmu.c **** 
2087:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
2088:../emlib/src/em_cmu.c ****     ret = (CMU->HFRCOCTRL & _CMU_HFRCOCTRL_TUNING_MASK) >>
 1986              		.loc 1 2088 0
 1987 0018 064B     		ldr	r3, .L265
 1988 001a D868     		ldr	r0, [r3, #12]
 1989              	.LVL253:
 1990 001c 01E0     		b	.L264
 1991              	.LVL254:
 1992              	.L260:
2089:../emlib/src/em_cmu.c ****           _CMU_HFRCOCTRL_TUNING_SHIFT;
2090:../emlib/src/em_cmu.c ****     break;
2091:../emlib/src/em_cmu.c **** 
2092:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
2093:../emlib/src/em_cmu.c ****     ret = (CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_TUNING_MASK) >>
 1993              		.loc 1 2093 0
 1994 001e 054B     		ldr	r3, .L265
 1995 0020 5869     		ldr	r0, [r3, #20]
 1996              	.LVL255:
 1997              	.L264:
 1998 0022 C0B2     		uxtb	r0, r0
 1999              	.LVL256:
2094:../emlib/src/em_cmu.c ****           _CMU_AUXHFRCOCTRL_TUNING_SHIFT;
2095:../emlib/src/em_cmu.c ****     break;
 2000              		.loc 1 2095 0
 2001 0024 08BD     		pop	{r3, pc}
 2002              	.LVL257:
 2003              	.L263:
2096:../emlib/src/em_cmu.c **** 
2097:../emlib/src/em_cmu.c ****   default:
2098:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 2004              		.loc 1 2098 0
 2005 0026 0448     		ldr	r0, .L265+4
 2006              	.LVL258:
 2007 0028 40F63201 		movw	r1, #2098
 2008 002c FFF7FEFF 		bl	assertEFM
 2009              	.LVL259:
2099:../emlib/src/em_cmu.c ****     ret = 0;
 2010              		.loc 1 2099 0
 2011 0030 0020     		movs	r0, #0
 2012              	.LVL260:
2100:../emlib/src/em_cmu.c ****     break;
2101:../emlib/src/em_cmu.c ****   }
2102:../emlib/src/em_cmu.c **** 
2103:../emlib/src/em_cmu.c ****   return(ret);
2104:../emlib/src/em_cmu.c **** }
 2013              		.loc 1 2104 0
 2014 0032 08BD     		pop	{r3, pc}
 2015              	.L266:
 2016              		.align	2
 2017              	.L265:
 2018 0034 00800C40 		.word	1074561024
 2019 0038 00000000 		.word	.LC0
ARM GAS  /tmp/ccnCWsWR.s 			page 89


 2020              		.cfi_endproc
 2021              	.LFE99:
 2023              		.section	.text.CMU_OscillatorTuningSet,"ax",%progbits
 2024              		.align	1
 2025              		.global	CMU_OscillatorTuningSet
 2026              		.thumb
 2027              		.thumb_func
 2029              	CMU_OscillatorTuningSet:
 2030              	.LFB100:
2105:../emlib/src/em_cmu.c **** 
2106:../emlib/src/em_cmu.c **** 
2107:../emlib/src/em_cmu.c **** /***************************************************************************//**
2108:../emlib/src/em_cmu.c ****  * @brief
2109:../emlib/src/em_cmu.c ****  *   Set the oscillator frequency tuning control.
2110:../emlib/src/em_cmu.c ****  *
2111:../emlib/src/em_cmu.c ****  * @note
2112:../emlib/src/em_cmu.c ****  *   Oscillator tuning is done during production, and the tuning value is
2113:../emlib/src/em_cmu.c ****  *   automatically loaded after a reset. Changing the tuning value from the
2114:../emlib/src/em_cmu.c ****  *   calibrated value is for more advanced use.
2115:../emlib/src/em_cmu.c ****  *
2116:../emlib/src/em_cmu.c ****  * @param[in] osc
2117:../emlib/src/em_cmu.c ****  *   Oscillator to set tuning value for, one of:
2118:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_LFRCO
2119:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_HFRCO
2120:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_AUXHFRCO
2121:../emlib/src/em_cmu.c ****  *
2122:../emlib/src/em_cmu.c ****  * @param[in] val
2123:../emlib/src/em_cmu.c ****  *   The oscillator frequency tuning setting to use.
2124:../emlib/src/em_cmu.c ****  ******************************************************************************/
2125:../emlib/src/em_cmu.c **** void CMU_OscillatorTuningSet(CMU_Osc_TypeDef osc, uint32_t val)
2126:../emlib/src/em_cmu.c **** {
 2031              		.loc 1 2126 0
 2032              		.cfi_startproc
 2033              		@ args = 0, pretend = 0, frame = 0
 2034              		@ frame_needed = 0, uses_anonymous_args = 0
 2035              	.LVL261:
2127:../emlib/src/em_cmu.c ****   switch (osc)
 2036              		.loc 1 2127 0
 2037 0000 0328     		cmp	r0, #3
2126:../emlib/src/em_cmu.c **** {
 2038              		.loc 1 2126 0
 2039 0002 10B5     		push	{r4, lr}
 2040              		.cfi_def_cfa_offset 8
 2041              		.cfi_offset 4, -8
 2042              		.cfi_offset 14, -4
2126:../emlib/src/em_cmu.c **** {
 2043              		.loc 1 2126 0
 2044 0004 0C46     		mov	r4, r1
 2045              		.loc 1 2127 0
 2046 0006 13D0     		beq	.L269
 2047 0008 0428     		cmp	r0, #4
 2048 000a 20D0     		beq	.L270
 2049 000c 0128     		cmp	r0, #1
 2050 000e 2DD1     		bne	.L276
2128:../emlib/src/em_cmu.c ****   {
2129:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
2130:../emlib/src/em_cmu.c ****     EFM_ASSERT(val <= (_CMU_LFRCOCTRL_TUNING_MASK >> _CMU_LFRCOCTRL_TUNING_SHIFT));
ARM GAS  /tmp/ccnCWsWR.s 			page 90


 2051              		.loc 1 2130 0
 2052 0010 7F29     		cmp	r1, #127
 2053 0012 04D9     		bls	.L272
 2054              		.loc 1 2130 0 is_stmt 0 discriminator 1
 2055 0014 1948     		ldr	r0, .L277
 2056              	.LVL262:
 2057 0016 40F65201 		movw	r1, #2130
 2058              	.LVL263:
 2059 001a FFF7FEFF 		bl	assertEFM
 2060              	.LVL264:
 2061              	.L272:
2131:../emlib/src/em_cmu.c **** 
2132:../emlib/src/em_cmu.c ****     val           &= (_CMU_LFRCOCTRL_TUNING_MASK >> _CMU_LFRCOCTRL_TUNING_SHIFT);
2133:../emlib/src/em_cmu.c ****     CMU->LFRCOCTRL = (CMU->LFRCOCTRL & ~(_CMU_LFRCOCTRL_TUNING_MASK)) |
 2062              		.loc 1 2133 0 is_stmt 1
 2063 001e 184B     		ldr	r3, .L277+4
2132:../emlib/src/em_cmu.c ****     val           &= (_CMU_LFRCOCTRL_TUNING_MASK >> _CMU_LFRCOCTRL_TUNING_SHIFT);
 2064              		.loc 1 2132 0
 2065 0020 04F07F04 		and	r4, r4, #127
 2066              	.LVL265:
 2067              		.loc 1 2133 0
 2068 0024 1A69     		ldr	r2, [r3, #16]
 2069 0026 22F07F02 		bic	r2, r2, #127
 2070 002a 1443     		orrs	r4, r4, r2
 2071              	.LVL266:
 2072 002c 1C61     		str	r4, [r3, #16]
2134:../emlib/src/em_cmu.c ****                      (val << _CMU_LFRCOCTRL_TUNING_SHIFT);
2135:../emlib/src/em_cmu.c ****     break;
 2073              		.loc 1 2135 0
 2074 002e 10BD     		pop	{r4, pc}
 2075              	.LVL267:
 2076              	.L269:
2136:../emlib/src/em_cmu.c **** 
2137:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
2138:../emlib/src/em_cmu.c ****     EFM_ASSERT(val <= (_CMU_HFRCOCTRL_TUNING_MASK >> _CMU_HFRCOCTRL_TUNING_SHIFT));
 2077              		.loc 1 2138 0
 2078 0030 FF29     		cmp	r1, #255
 2079 0032 04D9     		bls	.L274
 2080              		.loc 1 2138 0 is_stmt 0 discriminator 1
 2081 0034 1148     		ldr	r0, .L277
 2082              	.LVL268:
 2083 0036 40F65A01 		movw	r1, #2138
 2084              	.LVL269:
 2085 003a FFF7FEFF 		bl	assertEFM
 2086              	.LVL270:
 2087              	.L274:
2139:../emlib/src/em_cmu.c **** 
2140:../emlib/src/em_cmu.c ****     val           &= (_CMU_HFRCOCTRL_TUNING_MASK >> _CMU_HFRCOCTRL_TUNING_SHIFT);
2141:../emlib/src/em_cmu.c ****     CMU->HFRCOCTRL = (CMU->HFRCOCTRL & ~(_CMU_HFRCOCTRL_TUNING_MASK)) |
 2088              		.loc 1 2141 0 is_stmt 1
 2089 003e 104B     		ldr	r3, .L277+4
2140:../emlib/src/em_cmu.c ****     val           &= (_CMU_HFRCOCTRL_TUNING_MASK >> _CMU_HFRCOCTRL_TUNING_SHIFT);
 2090              		.loc 1 2140 0
 2091 0040 E4B2     		uxtb	r4, r4
 2092              	.LVL271:
 2093              		.loc 1 2141 0
 2094 0042 DA68     		ldr	r2, [r3, #12]
ARM GAS  /tmp/ccnCWsWR.s 			page 91


 2095 0044 22F0FF02 		bic	r2, r2, #255
 2096 0048 1443     		orrs	r4, r4, r2
 2097 004a DC60     		str	r4, [r3, #12]
2142:../emlib/src/em_cmu.c ****                      (val << _CMU_HFRCOCTRL_TUNING_SHIFT);
2143:../emlib/src/em_cmu.c ****     break;
 2098              		.loc 1 2143 0
 2099 004c 10BD     		pop	{r4, pc}
 2100              	.LVL272:
 2101              	.L270:
2144:../emlib/src/em_cmu.c **** 
2145:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
2146:../emlib/src/em_cmu.c ****     EFM_ASSERT(val <= (_CMU_AUXHFRCOCTRL_TUNING_MASK >> _CMU_AUXHFRCOCTRL_TUNING_SHIFT));
 2102              		.loc 1 2146 0
 2103 004e FF29     		cmp	r1, #255
 2104 0050 04D9     		bls	.L275
 2105              		.loc 1 2146 0 is_stmt 0 discriminator 1
 2106 0052 0A48     		ldr	r0, .L277
 2107              	.LVL273:
 2108 0054 40F66201 		movw	r1, #2146
 2109              	.LVL274:
 2110 0058 FFF7FEFF 		bl	assertEFM
 2111              	.LVL275:
 2112              	.L275:
2147:../emlib/src/em_cmu.c **** 
2148:../emlib/src/em_cmu.c ****     val             <<= _CMU_AUXHFRCOCTRL_TUNING_SHIFT;
2149:../emlib/src/em_cmu.c ****     val              &= _CMU_AUXHFRCOCTRL_TUNING_MASK;
2150:../emlib/src/em_cmu.c ****     CMU->AUXHFRCOCTRL = (CMU->AUXHFRCOCTRL & ~(_CMU_AUXHFRCOCTRL_TUNING_MASK)) | val;
 2113              		.loc 1 2150 0 is_stmt 1
 2114 005c 084B     		ldr	r3, .L277+4
2149:../emlib/src/em_cmu.c ****     val              &= _CMU_AUXHFRCOCTRL_TUNING_MASK;
 2115              		.loc 1 2149 0
 2116 005e E4B2     		uxtb	r4, r4
 2117              	.LVL276:
 2118              		.loc 1 2150 0
 2119 0060 5A69     		ldr	r2, [r3, #20]
 2120 0062 22F0FF02 		bic	r2, r2, #255
 2121 0066 1443     		orrs	r4, r4, r2
 2122 0068 5C61     		str	r4, [r3, #20]
2151:../emlib/src/em_cmu.c ****     break;
 2123              		.loc 1 2151 0
 2124 006a 10BD     		pop	{r4, pc}
 2125              	.LVL277:
 2126              	.L276:
2152:../emlib/src/em_cmu.c **** 
2153:../emlib/src/em_cmu.c ****   default:
2154:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 2127              		.loc 1 2154 0
 2128 006c 0348     		ldr	r0, .L277
 2129              	.LVL278:
 2130 006e 40F66A01 		movw	r1, #2154
 2131              	.LVL279:
2155:../emlib/src/em_cmu.c ****     break;
2156:../emlib/src/em_cmu.c ****   }
2157:../emlib/src/em_cmu.c **** }
 2132              		.loc 1 2157 0
 2133 0072 BDE81040 		pop	{r4, lr}
 2134              	.LVL280:
ARM GAS  /tmp/ccnCWsWR.s 			page 92


2154:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 2135              		.loc 1 2154 0
 2136 0076 FFF7FEBF 		b	assertEFM
 2137              	.LVL281:
 2138              	.L278:
 2139 007a 00BF     		.align	2
 2140              	.L277:
 2141 007c 00000000 		.word	.LC0
 2142 0080 00800C40 		.word	1074561024
 2143              		.cfi_endproc
 2144              	.LFE100:
 2146              		.section	.text.CMU_PCNTClockExternalGet,"ax",%progbits
 2147              		.align	1
 2148              		.global	CMU_PCNTClockExternalGet
 2149              		.thumb
 2150              		.thumb_func
 2152              	CMU_PCNTClockExternalGet:
 2153              	.LFB101:
2158:../emlib/src/em_cmu.c **** 
2159:../emlib/src/em_cmu.c **** 
2160:../emlib/src/em_cmu.c **** /**************************************************************************//**
2161:../emlib/src/em_cmu.c ****  * @brief
2162:../emlib/src/em_cmu.c ****  *   Determine if currently selected PCNTn clock used is external or LFBCLK.
2163:../emlib/src/em_cmu.c ****  *
2164:../emlib/src/em_cmu.c ****  * @param[in] inst
2165:../emlib/src/em_cmu.c ****  *   PCNT instance number to get currently selected clock source for.
2166:../emlib/src/em_cmu.c ****  *
2167:../emlib/src/em_cmu.c ****  * @return
2168:../emlib/src/em_cmu.c ****  *   @li true - selected clock is external clock.
2169:../emlib/src/em_cmu.c ****  *   @li false - selected clock is LFBCLK.
2170:../emlib/src/em_cmu.c ****  *****************************************************************************/
2171:../emlib/src/em_cmu.c **** bool CMU_PCNTClockExternalGet(unsigned int inst)
2172:../emlib/src/em_cmu.c **** {
 2154              		.loc 1 2172 0
 2155              		.cfi_startproc
 2156              		@ args = 0, pretend = 0, frame = 0
 2157              		@ frame_needed = 0, uses_anonymous_args = 0
 2158              		@ link register save eliminated.
 2159              	.LVL282:
2173:../emlib/src/em_cmu.c ****   bool     ret;
2174:../emlib/src/em_cmu.c ****   uint32_t setting;
2175:../emlib/src/em_cmu.c **** 
2176:../emlib/src/em_cmu.c ****   switch (inst)
 2160              		.loc 1 2176 0
 2161 0000 0128     		cmp	r0, #1
 2162 0002 0CD0     		beq	.L281
 2163 0004 06D3     		bcc	.L282
 2164 0006 0228     		cmp	r0, #2
 2165 0008 11D1     		bne	.L287
2177:../emlib/src/em_cmu.c ****   {
2178:../emlib/src/em_cmu.c **** #if defined(_CMU_PCNTCTRL_PCNT0CLKEN_MASK)
2179:../emlib/src/em_cmu.c ****   case 0:
2180:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT0CLKSEL_PCNT0S0;
2181:../emlib/src/em_cmu.c ****     break;
2182:../emlib/src/em_cmu.c **** 
2183:../emlib/src/em_cmu.c **** #if defined(_CMU_PCNTCTRL_PCNT1CLKEN_MASK)
2184:../emlib/src/em_cmu.c ****   case 1:
ARM GAS  /tmp/ccnCWsWR.s 			page 93


2185:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT1CLKSEL_PCNT1S0;
2186:../emlib/src/em_cmu.c ****     break;
2187:../emlib/src/em_cmu.c **** 
2188:../emlib/src/em_cmu.c **** #if defined(_CMU_PCNTCTRL_PCNT2CLKEN_MASK)
2189:../emlib/src/em_cmu.c ****   case 2:
2190:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT2CLKSEL_PCNT2S0;
 2166              		.loc 1 2190 0
 2167 000a 0A4B     		ldr	r3, .L288
 2168 000c 986F     		ldr	r0, [r3, #120]
 2169              	.LVL283:
 2170 000e 00F02000 		and	r0, r0, #32
 2171              	.LVL284:
2191:../emlib/src/em_cmu.c ****     break;
 2172              		.loc 1 2191 0
 2173 0012 08E0     		b	.L284
 2174              	.LVL285:
 2175              	.L282:
2180:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT0CLKSEL_PCNT0S0;
 2176              		.loc 1 2180 0
 2177 0014 074B     		ldr	r3, .L288
 2178 0016 986F     		ldr	r0, [r3, #120]
 2179              	.LVL286:
 2180 0018 00F00200 		and	r0, r0, #2
 2181              	.LVL287:
2181:../emlib/src/em_cmu.c ****     break;
 2182              		.loc 1 2181 0
 2183 001c 03E0     		b	.L284
 2184              	.LVL288:
 2185              	.L281:
2185:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT1CLKSEL_PCNT1S0;
 2186              		.loc 1 2185 0
 2187 001e 054B     		ldr	r3, .L288
 2188 0020 986F     		ldr	r0, [r3, #120]
 2189              	.LVL289:
 2190 0022 00F00800 		and	r0, r0, #8
 2191              	.LVL290:
 2192              	.L284:
2192:../emlib/src/em_cmu.c **** #endif
2193:../emlib/src/em_cmu.c **** #endif
2194:../emlib/src/em_cmu.c **** #endif
2195:../emlib/src/em_cmu.c **** 
2196:../emlib/src/em_cmu.c ****   default:
2197:../emlib/src/em_cmu.c ****     setting = 0;
2198:../emlib/src/em_cmu.c ****     break;
2199:../emlib/src/em_cmu.c ****   }
2200:../emlib/src/em_cmu.c **** 
2201:../emlib/src/em_cmu.c ****   if (setting)
 2193              		.loc 1 2201 0
 2194 0026 0030     		adds	r0, r0, #0
 2195 0028 18BF     		it	ne
 2196 002a 0120     		movne	r0, #1
 2197              	.LVL291:
 2198 002c 7047     		bx	lr
 2199              	.LVL292:
 2200              	.L287:
2202:../emlib/src/em_cmu.c ****   {
2203:../emlib/src/em_cmu.c ****     ret = true;
ARM GAS  /tmp/ccnCWsWR.s 			page 94


2204:../emlib/src/em_cmu.c ****   }
2205:../emlib/src/em_cmu.c ****   else
2206:../emlib/src/em_cmu.c ****   {
2207:../emlib/src/em_cmu.c ****     ret = false;
 2201              		.loc 1 2207 0
 2202 002e 0020     		movs	r0, #0
 2203              	.LVL293:
2208:../emlib/src/em_cmu.c ****   }
2209:../emlib/src/em_cmu.c ****   return ret;
2210:../emlib/src/em_cmu.c **** }
 2204              		.loc 1 2210 0
 2205 0030 7047     		bx	lr
 2206              	.L289:
 2207 0032 00BF     		.align	2
 2208              	.L288:
 2209 0034 00800C40 		.word	1074561024
 2210              		.cfi_endproc
 2211              	.LFE101:
 2213              		.section	.text.CMU_PCNTClockExternalSet,"ax",%progbits
 2214              		.align	1
 2215              		.global	CMU_PCNTClockExternalSet
 2216              		.thumb
 2217              		.thumb_func
 2219              	CMU_PCNTClockExternalSet:
 2220              	.LFB102:
2211:../emlib/src/em_cmu.c **** 
2212:../emlib/src/em_cmu.c **** 
2213:../emlib/src/em_cmu.c **** /**************************************************************************//**
2214:../emlib/src/em_cmu.c ****  * @brief
2215:../emlib/src/em_cmu.c ****  *   Select PCNTn clock.
2216:../emlib/src/em_cmu.c ****  *
2217:../emlib/src/em_cmu.c ****  * @param[in] inst
2218:../emlib/src/em_cmu.c ****  *   PCNT instance number to set selected clock source for.
2219:../emlib/src/em_cmu.c ****  *
2220:../emlib/src/em_cmu.c ****  * @param[in] external
2221:../emlib/src/em_cmu.c ****  *   Set to true to select external clock, false to select LFBCLK.
2222:../emlib/src/em_cmu.c ****  *****************************************************************************/
2223:../emlib/src/em_cmu.c **** void CMU_PCNTClockExternalSet(unsigned int inst, bool external)
2224:../emlib/src/em_cmu.c **** {
 2221              		.loc 1 2224 0
 2222              		.cfi_startproc
 2223              		@ args = 0, pretend = 0, frame = 0
 2224              		@ frame_needed = 0, uses_anonymous_args = 0
 2225              	.LVL294:
2225:../emlib/src/em_cmu.c **** #if defined(PCNT_PRESENT)
2226:../emlib/src/em_cmu.c ****   uint32_t setting = 0;
2227:../emlib/src/em_cmu.c **** 
2228:../emlib/src/em_cmu.c ****   EFM_ASSERT(inst < PCNT_COUNT);
 2226              		.loc 1 2228 0
 2227 0000 0228     		cmp	r0, #2
2224:../emlib/src/em_cmu.c **** {
 2228              		.loc 1 2224 0
 2229 0002 38B5     		push	{r3, r4, r5, lr}
 2230              		.cfi_def_cfa_offset 16
 2231              		.cfi_offset 3, -16
 2232              		.cfi_offset 4, -12
 2233              		.cfi_offset 5, -8
ARM GAS  /tmp/ccnCWsWR.s 			page 95


 2234              		.cfi_offset 14, -4
2224:../emlib/src/em_cmu.c **** {
 2235              		.loc 1 2224 0
 2236 0004 0446     		mov	r4, r0
 2237 0006 0D46     		mov	r5, r1
 2238              		.loc 1 2228 0
 2239 0008 04D9     		bls	.L291
 2240              		.loc 1 2228 0 is_stmt 0 discriminator 1
 2241 000a 0448     		ldr	r0, .L292
 2242              	.LVL295:
 2243 000c 40F6B401 		movw	r1, #2228
 2244              	.LVL296:
 2245 0010 FFF7FEFF 		bl	assertEFM
 2246              	.LVL297:
 2247              	.L291:
 2248              	.LBB58:
 2249              	.LBB59:
  75:../emlib/inc/em_bitband.h ****   uint32_t tmp =
 2250              		.loc 3 75 0 is_stmt 1
 2251 0014 024B     		ldr	r3, .L292+4
  76:../emlib/inc/em_bitband.h ****     BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);
 2252              		.loc 3 76 0
 2253 0016 E400     		lsls	r4, r4, #3
 2254              	.LVL298:
 2255              		.loc 3 78 0
 2256 0018 1D51     		str	r5, [r3, r4]
 2257 001a 38BD     		pop	{r3, r4, r5, pc}
 2258              	.LVL299:
 2259              	.L293:
 2260              		.align	2
 2261              	.L292:
 2262 001c 00000000 		.word	.LC0
 2263 0020 040F9043 		.word	1133514500
 2264              	.LBE59:
 2265              	.LBE58:
 2266              		.cfi_endproc
 2267              	.LFE102:
 2269              		.section	.rodata.str1.1,"aMS",%progbits,1
 2270              	.LC0:
 2271 0000 2E2E2F65 		.ascii	"../emlib/src/em_cmu.c\000"
 2271      6D6C6962 
 2271      2F737263 
 2271      2F656D5F 
 2271      636D752E 
 2272              		.text
 2273              	.Letext0:
 2274              		.file 4 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 2275              		.file 5 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 2276              		.file 6 "../Device/EnergyMicro/EFM32G/Include/efm32g_msc.h"
 2277              		.file 7 "../Device/EnergyMicro/EFM32G/Include/efm32g230f128.h"
 2278              		.file 8 "../Device/EnergyMicro/EFM32G/Include/efm32g_devinfo.h"
 2279              		.file 9 "../emlib/inc/em_cmu.h"
 2280              		.file 10 "../emlib/inc/em_assert.h"
 2281              		.file 11 "../Device/EnergyMicro/EFM32G/Include/system_efm32g.h"
 2282              		.file 12 "../CMSIS/Include/core_cm3.h"
 2283              		.file 13 "../emlib/inc/em_emu.h"
