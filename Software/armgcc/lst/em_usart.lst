ARM GAS  /tmp/ccmo25Cu.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"em_usart.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.USART_BaudrateAsyncSet,"ax",%progbits
  19              		.align	1
  20              		.global	USART_BaudrateAsyncSet
  21              		.thumb
  22              		.thumb_func
  24              	USART_BaudrateAsyncSet:
  25              	.LFB78:
  26              		.file 1 "../emlib/src/em_usart.c"
   1:../emlib/src/em_usart.c **** /***************************************************************************//**
   2:../emlib/src/em_usart.c ****  * @file
   3:../emlib/src/em_usart.c ****  * @brief Universal synchronous/asynchronous receiver/transmitter (USART/UART)
   4:../emlib/src/em_usart.c ****  *   Peripheral API
   5:../emlib/src/em_usart.c ****  * @author Energy Micro AS
   6:../emlib/src/em_usart.c ****  * @version 3.20.2
   7:../emlib/src/em_usart.c ****  *******************************************************************************
   8:../emlib/src/em_usart.c ****  * @section License
   9:../emlib/src/em_usart.c ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
  10:../emlib/src/em_usart.c ****  *******************************************************************************
  11:../emlib/src/em_usart.c ****  *
  12:../emlib/src/em_usart.c ****  * Permission is granted to anyone to use this software for any purpose,
  13:../emlib/src/em_usart.c ****  * including commercial applications, and to alter it and redistribute it
  14:../emlib/src/em_usart.c ****  * freely, subject to the following restrictions:
  15:../emlib/src/em_usart.c ****  *
  16:../emlib/src/em_usart.c ****  * 1. The origin of this software must not be misrepresented; you must not
  17:../emlib/src/em_usart.c ****  *    claim that you wrote the original software.
  18:../emlib/src/em_usart.c ****  * 2. Altered source versions must be plainly marked as such, and must not be
  19:../emlib/src/em_usart.c ****  *    misrepresented as being the original software.
  20:../emlib/src/em_usart.c ****  * 3. This notice may not be removed or altered from any source distribution.
  21:../emlib/src/em_usart.c ****  *
  22:../emlib/src/em_usart.c ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  23:../emlib/src/em_usart.c ****  * obligation to support this Software. Energy Micro AS is providing the
  24:../emlib/src/em_usart.c ****  * Software "AS IS", with no express or implied warranties of any kind,
  25:../emlib/src/em_usart.c ****  * including, but not limited to, any implied warranties of merchantability
  26:../emlib/src/em_usart.c ****  * or fitness for any particular purpose or warranties against infringement
  27:../emlib/src/em_usart.c ****  * of any proprietary rights of a third party.
  28:../emlib/src/em_usart.c ****  *
  29:../emlib/src/em_usart.c ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  30:../emlib/src/em_usart.c ****  * special damages, or any other relief, or for any claim by any third party,
  31:../emlib/src/em_usart.c ****  * arising from your use of this Software.
  32:../emlib/src/em_usart.c ****  *
ARM GAS  /tmp/ccmo25Cu.s 			page 2


  33:../emlib/src/em_usart.c ****  ******************************************************************************/
  34:../emlib/src/em_usart.c **** #include "em_usart.h"
  35:../emlib/src/em_usart.c **** #if defined(USART_COUNT) && (USART_COUNT > 0)
  36:../emlib/src/em_usart.c **** 
  37:../emlib/src/em_usart.c **** #include "em_cmu.h"
  38:../emlib/src/em_usart.c **** #include "em_assert.h"
  39:../emlib/src/em_usart.c **** 
  40:../emlib/src/em_usart.c **** /***************************************************************************//**
  41:../emlib/src/em_usart.c ****  * @addtogroup EM_Library
  42:../emlib/src/em_usart.c ****  * @{
  43:../emlib/src/em_usart.c ****  ******************************************************************************/
  44:../emlib/src/em_usart.c **** 
  45:../emlib/src/em_usart.c **** /***************************************************************************//**
  46:../emlib/src/em_usart.c ****  * @addtogroup USART
  47:../emlib/src/em_usart.c ****  * @brief Universal Synchronous/Asynchronous Receiver/Transmitter
  48:../emlib/src/em_usart.c ****  *   Peripheral API
  49:../emlib/src/em_usart.c ****  * @{
  50:../emlib/src/em_usart.c ****  ******************************************************************************/
  51:../emlib/src/em_usart.c **** 
  52:../emlib/src/em_usart.c **** /*******************************************************************************
  53:../emlib/src/em_usart.c ****  *******************************   DEFINES   ***********************************
  54:../emlib/src/em_usart.c ****  ******************************************************************************/
  55:../emlib/src/em_usart.c **** 
  56:../emlib/src/em_usart.c **** /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
  57:../emlib/src/em_usart.c **** 
  58:../emlib/src/em_usart.c **** 
  59:../emlib/src/em_usart.c **** /** Validation of USART register block pointer reference for assert statements. */
  60:../emlib/src/em_usart.c **** #if (USART_COUNT == 1) && defined(USART0)
  61:../emlib/src/em_usart.c **** #define USART_REF_VALID(ref)    ((ref) == USART0)
  62:../emlib/src/em_usart.c **** 
  63:../emlib/src/em_usart.c **** #elif (USART_COUNT == 1) && defined(USART1)
  64:../emlib/src/em_usart.c **** #define USART_REF_VALID(ref)    ((ref) == USART1)
  65:../emlib/src/em_usart.c **** 
  66:../emlib/src/em_usart.c **** #elif (USART_COUNT == 2)
  67:../emlib/src/em_usart.c **** #define USART_REF_VALID(ref)    (((ref) == USART0) || ((ref) == USART1))
  68:../emlib/src/em_usart.c **** 
  69:../emlib/src/em_usart.c **** #elif (USART_COUNT == 3)
  70:../emlib/src/em_usart.c **** #define USART_REF_VALID(ref)    (((ref) == USART0) || ((ref) == USART1) || \
  71:../emlib/src/em_usart.c ****                                  ((ref) == USART2))
  72:../emlib/src/em_usart.c **** #elif (USART_COUNT == 4)
  73:../emlib/src/em_usart.c **** #define USART_REF_VALID(ref)    (((ref) == USART0) || ((ref) == USART1) || \
  74:../emlib/src/em_usart.c ****                                  ((ref) == USART2) || ((ref) == USART3))
  75:../emlib/src/em_usart.c **** #else
  76:../emlib/src/em_usart.c **** #error Undefined number of USARTs.
  77:../emlib/src/em_usart.c **** #endif
  78:../emlib/src/em_usart.c **** 
  79:../emlib/src/em_usart.c **** #if defined(USART0)
  80:../emlib/src/em_usart.c **** #define USART_IRDA_VALID(ref)    ((ref) == USART0)
  81:../emlib/src/em_usart.c **** #elif (USART_COUNT == 1) && defined(USART1)
  82:../emlib/src/em_usart.c **** #define USART_IRDA_VALID(ref)    ((ref) == USART1)
  83:../emlib/src/em_usart.c **** #else
  84:../emlib/src/em_usart.c **** #define USART_IRDA_VALID(ref)    (0)
  85:../emlib/src/em_usart.c **** #endif
  86:../emlib/src/em_usart.c **** 
  87:../emlib/src/em_usart.c **** #if defined(_EFM32_TINY_FAMILY) || defined(_EFM32_ZERO_FAMILY)
  88:../emlib/src/em_usart.c **** #define USART_I2S_VALID(ref)    ((ref) == USART1)
  89:../emlib/src/em_usart.c **** 
ARM GAS  /tmp/ccmo25Cu.s 			page 3


  90:../emlib/src/em_usart.c **** #elif defined(_EFM32_GIANT_FAMILY) || defined(_EFM32_WONDER_FAMILY)
  91:../emlib/src/em_usart.c **** #define USART_I2S_VALID(ref)    (((ref) == USART1) || ((ref) == USART2))
  92:../emlib/src/em_usart.c **** #endif
  93:../emlib/src/em_usart.c **** 
  94:../emlib/src/em_usart.c **** #if (UART_COUNT == 1)
  95:../emlib/src/em_usart.c **** #define UART_REF_VALID(ref)    ((ref) == UART0)
  96:../emlib/src/em_usart.c **** #elif (UART_COUNT == 2)
  97:../emlib/src/em_usart.c **** #define UART_REF_VALID(ref)    (((ref) == UART0) || ((ref) == UART1))
  98:../emlib/src/em_usart.c **** #else
  99:../emlib/src/em_usart.c **** #define UART_REF_VALID(ref)    (0)
 100:../emlib/src/em_usart.c **** #endif
 101:../emlib/src/em_usart.c **** 
 102:../emlib/src/em_usart.c **** /** @endcond */
 103:../emlib/src/em_usart.c **** 
 104:../emlib/src/em_usart.c **** 
 105:../emlib/src/em_usart.c **** /*******************************************************************************
 106:../emlib/src/em_usart.c ****  **************************   GLOBAL FUNCTIONS   *******************************
 107:../emlib/src/em_usart.c ****  ******************************************************************************/
 108:../emlib/src/em_usart.c **** 
 109:../emlib/src/em_usart.c **** /***************************************************************************//**
 110:../emlib/src/em_usart.c ****  * @brief
 111:../emlib/src/em_usart.c ****  *   Configure USART/UART operating in asynchronous mode to use a given
 112:../emlib/src/em_usart.c ****  *   baudrate (or as close as possible to specified baudrate).
 113:../emlib/src/em_usart.c ****  *
 114:../emlib/src/em_usart.c ****  * @param[in] usart
 115:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 116:../emlib/src/em_usart.c ****  *
 117:../emlib/src/em_usart.c ****  * @param[in] refFreq
 118:../emlib/src/em_usart.c ****  *   USART/UART reference clock frequency in Hz that will be used. If set to 0,
 119:../emlib/src/em_usart.c ****  *   the currently configured reference clock is assumed.
 120:../emlib/src/em_usart.c ****  *
 121:../emlib/src/em_usart.c ****  * @param[in] baudrate
 122:../emlib/src/em_usart.c ****  *   Baudrate to try to achieve for USART/UART.
 123:../emlib/src/em_usart.c ****  *
 124:../emlib/src/em_usart.c ****  * @param[in] ovs
 125:../emlib/src/em_usart.c ****  *   Oversampling to be used. Normal is 16x oversampling, but lower oversampling
 126:../emlib/src/em_usart.c ****  *   may be used to achieve higher rates or better baudrate accuracy in some
 127:../emlib/src/em_usart.c ****  *   cases. Notice that lower oversampling frequency makes channel more
 128:../emlib/src/em_usart.c ****  *   vulnerable to bit faults during reception due to clock inaccuracies
 129:../emlib/src/em_usart.c ****  *   compared to link partner.
 130:../emlib/src/em_usart.c ****  ******************************************************************************/
 131:../emlib/src/em_usart.c **** void USART_BaudrateAsyncSet(USART_TypeDef *usart,
 132:../emlib/src/em_usart.c ****                             uint32_t refFreq,
 133:../emlib/src/em_usart.c ****                             uint32_t baudrate,
 134:../emlib/src/em_usart.c ****                             USART_OVS_TypeDef ovs)
 135:../emlib/src/em_usart.c **** {
  27              		.loc 1 135 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  33              		.cfi_def_cfa_offset 24
  34              		.cfi_offset 4, -24
  35              		.cfi_offset 5, -20
  36              		.cfi_offset 6, -16
  37              		.cfi_offset 7, -12
ARM GAS  /tmp/ccmo25Cu.s 			page 4


  38              		.cfi_offset 8, -8
  39              		.cfi_offset 14, -4
  40              		.loc 1 135 0
  41 0004 0746     		mov	r7, r0
  42 0006 0D46     		mov	r5, r1
  43 0008 9846     		mov	r8, r3
 136:../emlib/src/em_usart.c ****   uint32_t clkdiv;
 137:../emlib/src/em_usart.c ****   uint32_t oversample;
 138:../emlib/src/em_usart.c **** 
 139:../emlib/src/em_usart.c ****   /* Inhibit divide by 0 */
 140:../emlib/src/em_usart.c ****   EFM_ASSERT(baudrate);
  44              		.loc 1 140 0
  45 000a 1646     		mov	r6, r2
  46 000c 1AB9     		cbnz	r2, .L2
  47              		.loc 1 140 0 is_stmt 0 discriminator 1
  48 000e 3048     		ldr	r0, .L17
  49              	.LVL1:
  50 0010 8C21     		movs	r1, #140
  51              	.LVL2:
  52 0012 FFF7FEFF 		bl	assertEFM
  53              	.LVL3:
  54              	.L2:
 141:../emlib/src/em_usart.c **** 
 142:../emlib/src/em_usart.c ****   /*
 143:../emlib/src/em_usart.c ****    * We want to use integer division to avoid forcing in float division
 144:../emlib/src/em_usart.c ****    * utils, and yet keep rounding effect errors to a minimum.
 145:../emlib/src/em_usart.c ****    *
 146:../emlib/src/em_usart.c ****    * CLKDIV in asynchronous mode is given by:
 147:../emlib/src/em_usart.c ****    *
 148:../emlib/src/em_usart.c ****    * CLKDIV = 256 * (fHFPERCLK/(oversample * br) - 1)
 149:../emlib/src/em_usart.c ****    * or
 150:../emlib/src/em_usart.c ****    * CLKDIV = (256 * fHFPERCLK)/(oversample * br) - 256
 151:../emlib/src/em_usart.c ****    *
 152:../emlib/src/em_usart.c ****    * The basic problem with integer division in the above formula is that
 153:../emlib/src/em_usart.c ****    * the dividend (256 * fHFPERCLK) may become higher than max 32 bit
 154:../emlib/src/em_usart.c ****    * integer. Yet, we want to evaluate dividend first before dividing in
 155:../emlib/src/em_usart.c ****    * order to get as small rounding effects as possible. We do not want
 156:../emlib/src/em_usart.c ****    * to make too harsh restrictions on max fHFPERCLK value either.
 157:../emlib/src/em_usart.c ****    *
 158:../emlib/src/em_usart.c ****    * One can possibly factorize 256 and oversample/br. However,
 159:../emlib/src/em_usart.c ****    * since the last 6 bits of CLKDIV are don't care, we can base our
 160:../emlib/src/em_usart.c ****    * integer arithmetic on the below formula
 161:../emlib/src/em_usart.c ****    *
 162:../emlib/src/em_usart.c ****    * CLKDIV / 64 = (4 * fHFPERCLK)/(oversample * br) - 4
 163:../emlib/src/em_usart.c ****    *
 164:../emlib/src/em_usart.c ****    * and calculate 1/64 of CLKDIV first. This allows for fHFPERCLK
 165:../emlib/src/em_usart.c ****    * up to 1GHz without overflowing a 32 bit value!
 166:../emlib/src/em_usart.c ****    */
 167:../emlib/src/em_usart.c **** 
 168:../emlib/src/em_usart.c ****   /* HFPERCLK used to clock all USART/UART peripheral modules */
 169:../emlib/src/em_usart.c ****   if (!refFreq)
  55              		.loc 1 169 0 is_stmt 1
  56 0016 1DB9     		cbnz	r5, .L3
 170:../emlib/src/em_usart.c ****   {
 171:../emlib/src/em_usart.c ****     refFreq = CMU_ClockFreqGet(cmuClock_HFPER);
  57              		.loc 1 171 0
  58 0018 2E48     		ldr	r0, .L17+4
ARM GAS  /tmp/ccmo25Cu.s 			page 5


  59 001a FFF7FEFF 		bl	CMU_ClockFreqGet
  60              	.LVL4:
  61 001e 0546     		mov	r5, r0
  62              	.LVL5:
  63              	.L3:
 172:../emlib/src/em_usart.c ****   }
 173:../emlib/src/em_usart.c **** 
 174:../emlib/src/em_usart.c ****   /* Map oversampling */
 175:../emlib/src/em_usart.c ****   switch (ovs)
  64              		.loc 1 175 0
  65 0020 B8F1200F 		cmp	r8, #32
  66 0024 13D0     		beq	.L5
  67 0026 03D8     		bhi	.L6
  68 0028 B8F1000F 		cmp	r8, #0
  69 002c 07D0     		beq	.L7
  70 002e 28E0     		b	.L4
  71              	.L6:
  72 0030 B8F1400F 		cmp	r8, #64
  73 0034 13D0     		beq	.L8
  74 0036 B8F1600F 		cmp	r8, #96
  75 003a 1AD0     		beq	.L9
  76 003c 21E0     		b	.L4
  77              	.L7:
 176:../emlib/src/em_usart.c ****   {
 177:../emlib/src/em_usart.c ****   case USART_CTRL_OVS_X16:
 178:../emlib/src/em_usart.c ****     EFM_ASSERT(baudrate <= (refFreq / 16));
  78              		.loc 1 178 0
  79 003e B6EB151F 		cmp	r6, r5, lsr #4
  80 0042 24D9     		bls	.L12
  81              		.loc 1 178 0 is_stmt 0 discriminator 1
  82 0044 2248     		ldr	r0, .L17
  83 0046 B221     		movs	r1, #178
  84 0048 FFF7FEFF 		bl	assertEFM
  85              	.LVL6:
  86 004c 1FE0     		b	.L12
  87              	.L5:
 179:../emlib/src/em_usart.c ****     oversample = 16;
 180:../emlib/src/em_usart.c ****     break;
 181:../emlib/src/em_usart.c **** 
 182:../emlib/src/em_usart.c ****   case USART_CTRL_OVS_X8:
 183:../emlib/src/em_usart.c ****     EFM_ASSERT(baudrate <= (refFreq / 8));
  88              		.loc 1 183 0 is_stmt 1
  89 004e B6EBD50F 		cmp	r6, r5, lsr #3
  90 0052 1ED9     		bls	.L13
  91              		.loc 1 183 0 is_stmt 0 discriminator 1
  92 0054 1E48     		ldr	r0, .L17
  93 0056 B721     		movs	r1, #183
  94 0058 FFF7FEFF 		bl	assertEFM
  95              	.LVL7:
  96 005c 19E0     		b	.L13
  97              	.L8:
 184:../emlib/src/em_usart.c ****     oversample = 8;
 185:../emlib/src/em_usart.c ****     break;
 186:../emlib/src/em_usart.c **** 
 187:../emlib/src/em_usart.c ****   case USART_CTRL_OVS_X6:
 188:../emlib/src/em_usart.c ****     EFM_ASSERT(baudrate <= (refFreq / 6));
  98              		.loc 1 188 0 is_stmt 1
ARM GAS  /tmp/ccmo25Cu.s 			page 6


  99 005e 0624     		movs	r4, #6
 100 0060 B5FBF4F3 		udiv	r3, r5, r4
 101 0064 9E42     		cmp	r6, r3
 102 0066 17D9     		bls	.L10
 103              		.loc 1 188 0 is_stmt 0 discriminator 1
 104 0068 1948     		ldr	r0, .L17
 105 006a BC21     		movs	r1, #188
 106 006c FFF7FEFF 		bl	assertEFM
 107              	.LVL8:
 108 0070 12E0     		b	.L10
 109              	.L9:
 189:../emlib/src/em_usart.c ****     oversample = 6;
 190:../emlib/src/em_usart.c ****     break;
 191:../emlib/src/em_usart.c **** 
 192:../emlib/src/em_usart.c ****   case USART_CTRL_OVS_X4:
 193:../emlib/src/em_usart.c ****     EFM_ASSERT(baudrate <= (refFreq / 4));
 110              		.loc 1 193 0 is_stmt 1
 111 0072 B6EB950F 		cmp	r6, r5, lsr #2
 112 0076 0ED9     		bls	.L15
 113              		.loc 1 193 0 is_stmt 0 discriminator 1
 114 0078 1548     		ldr	r0, .L17
 115 007a C121     		movs	r1, #193
 116 007c FFF7FEFF 		bl	assertEFM
 117              	.LVL9:
 118 0080 09E0     		b	.L15
 119              	.L4:
 194:../emlib/src/em_usart.c ****     oversample = 4;
 195:../emlib/src/em_usart.c ****     break;
 196:../emlib/src/em_usart.c **** 
 197:../emlib/src/em_usart.c ****   default:
 198:../emlib/src/em_usart.c ****     /* Invalid input */
 199:../emlib/src/em_usart.c ****     EFM_ASSERT(0);
 120              		.loc 1 199 0 is_stmt 1
 121 0082 1348     		ldr	r0, .L17
 122 0084 C721     		movs	r1, #199
 200:../emlib/src/em_usart.c ****     return;
 201:../emlib/src/em_usart.c ****   }
 202:../emlib/src/em_usart.c **** 
 203:../emlib/src/em_usart.c ****   /* Calculate and set CLKDIV with fractional bits.
 204:../emlib/src/em_usart.c ****    * The addend (oversample*baudrate)/2 in the first line is to round the
 205:../emlib/src/em_usart.c ****    * divisor up by half the divisor before the division in order to reduce the
 206:../emlib/src/em_usart.c ****    * integer division error, which consequently results in a higher baudrate
 207:../emlib/src/em_usart.c ****    * than desired. */
 208:../emlib/src/em_usart.c ****   clkdiv  = 4 * refFreq + (oversample * baudrate) / 2;
 209:../emlib/src/em_usart.c ****   clkdiv /= (oversample * baudrate);
 210:../emlib/src/em_usart.c ****   clkdiv -= 4;
 211:../emlib/src/em_usart.c ****   clkdiv *= 64;
 212:../emlib/src/em_usart.c **** 
 213:../emlib/src/em_usart.c ****   /* Verify that resulting clock divider is within limits */
 214:../emlib/src/em_usart.c ****   EFM_ASSERT(clkdiv <= _USART_CLKDIV_MASK);
 215:../emlib/src/em_usart.c **** 
 216:../emlib/src/em_usart.c ****   /* If EFM_ASSERT is not enabled, make sure we don't write to reserved bits */
 217:../emlib/src/em_usart.c ****   clkdiv &= _USART_CLKDIV_MASK;
 218:../emlib/src/em_usart.c **** 
 219:../emlib/src/em_usart.c ****   usart->CTRL  &= ~_USART_CTRL_OVS_MASK;
 220:../emlib/src/em_usart.c ****   usart->CTRL  |= ovs;
 221:../emlib/src/em_usart.c ****   usart->CLKDIV = clkdiv;
ARM GAS  /tmp/ccmo25Cu.s 			page 7


 222:../emlib/src/em_usart.c **** }
 123              		.loc 1 222 0
 124 0086 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 125              	.LVL10:
 199:../emlib/src/em_usart.c ****     EFM_ASSERT(0);
 126              		.loc 1 199 0
 127 008a FFF7FEBF 		b	assertEFM
 128              	.LVL11:
 129              	.L12:
 179:../emlib/src/em_usart.c ****     oversample = 16;
 130              		.loc 1 179 0
 131 008e 1024     		movs	r4, #16
 132 0090 02E0     		b	.L10
 133              	.L13:
 184:../emlib/src/em_usart.c ****     oversample = 8;
 134              		.loc 1 184 0
 135 0092 0824     		movs	r4, #8
 136 0094 00E0     		b	.L10
 137              	.L15:
 194:../emlib/src/em_usart.c ****     oversample = 4;
 138              		.loc 1 194 0
 139 0096 0424     		movs	r4, #4
 140              	.L10:
 141              	.LVL12:
 208:../emlib/src/em_usart.c ****   clkdiv  = 4 * refFreq + (oversample * baudrate) / 2;
 142              		.loc 1 208 0
 143 0098 7443     		muls	r4, r6, r4
 144              	.LVL13:
 145 009a AD00     		lsls	r5, r5, #2
 146              	.LVL14:
 147 009c 05EB5405 		add	r5, r5, r4, lsr #1
 148              	.LVL15:
 209:../emlib/src/em_usart.c ****   clkdiv /= (oversample * baudrate);
 149              		.loc 1 209 0
 150 00a0 B5FBF4F4 		udiv	r4, r5, r4
 151              	.LVL16:
 210:../emlib/src/em_usart.c ****   clkdiv -= 4;
 152              		.loc 1 210 0
 153 00a4 043C     		subs	r4, r4, #4
 154              	.LVL17:
 214:../emlib/src/em_usart.c ****   EFM_ASSERT(clkdiv <= _USART_CLKDIV_MASK);
 155              		.loc 1 214 0
 156 00a6 0C4B     		ldr	r3, .L17+8
 211:../emlib/src/em_usart.c ****   clkdiv *= 64;
 157              		.loc 1 211 0
 158 00a8 A401     		lsls	r4, r4, #6
 159              	.LVL18:
 214:../emlib/src/em_usart.c ****   EFM_ASSERT(clkdiv <= _USART_CLKDIV_MASK);
 160              		.loc 1 214 0
 161 00aa 9C42     		cmp	r4, r3
 162 00ac 03D9     		bls	.L11
 214:../emlib/src/em_usart.c ****   EFM_ASSERT(clkdiv <= _USART_CLKDIV_MASK);
 163              		.loc 1 214 0 is_stmt 0 discriminator 1
 164 00ae 0848     		ldr	r0, .L17
 165 00b0 D621     		movs	r1, #214
 166 00b2 FFF7FEFF 		bl	assertEFM
 167              	.LVL19:
ARM GAS  /tmp/ccmo25Cu.s 			page 8


 168              	.L11:
 219:../emlib/src/em_usart.c ****   usart->CTRL  &= ~_USART_CTRL_OVS_MASK;
 169              		.loc 1 219 0 is_stmt 1
 170 00b6 3A68     		ldr	r2, [r7]
 217:../emlib/src/em_usart.c ****   clkdiv &= _USART_CLKDIV_MASK;
 171              		.loc 1 217 0
 172 00b8 074B     		ldr	r3, .L17+8
 219:../emlib/src/em_usart.c ****   usart->CTRL  &= ~_USART_CTRL_OVS_MASK;
 173              		.loc 1 219 0
 174 00ba 22F06002 		bic	r2, r2, #96
 175 00be 3A60     		str	r2, [r7]
 220:../emlib/src/em_usart.c ****   usart->CTRL  |= ovs;
 176              		.loc 1 220 0
 177 00c0 3A68     		ldr	r2, [r7]
 217:../emlib/src/em_usart.c ****   clkdiv &= _USART_CLKDIV_MASK;
 178              		.loc 1 217 0
 179 00c2 2340     		ands	r3, r3, r4
 180              	.LVL20:
 220:../emlib/src/em_usart.c ****   usart->CTRL  |= ovs;
 181              		.loc 1 220 0
 182 00c4 48EA0202 		orr	r2, r8, r2
 183 00c8 3A60     		str	r2, [r7]
 221:../emlib/src/em_usart.c ****   usart->CLKDIV = clkdiv;
 184              		.loc 1 221 0
 185 00ca 7B61     		str	r3, [r7, #20]
 186 00cc BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 187              	.LVL21:
 188              	.L18:
 189              		.align	2
 190              	.L17:
 191 00d0 00000000 		.word	.LC0
 192 00d4 10810200 		.word	164112
 193 00d8 C0FF1F00 		.word	2097088
 194              		.cfi_endproc
 195              	.LFE78:
 197              		.section	.text.USART_BaudrateCalc,"ax",%progbits
 198              		.align	1
 199              		.global	USART_BaudrateCalc
 200              		.thumb
 201              		.thumb_func
 203              	USART_BaudrateCalc:
 204              	.LFB79:
 223:../emlib/src/em_usart.c **** 
 224:../emlib/src/em_usart.c **** 
 225:../emlib/src/em_usart.c **** /***************************************************************************//**
 226:../emlib/src/em_usart.c ****  * @brief
 227:../emlib/src/em_usart.c ****  *   Calculate baudrate for USART/UART given reference frequency, clock division
 228:../emlib/src/em_usart.c ****  *   and oversampling rate (if async mode).
 229:../emlib/src/em_usart.c ****  *
 230:../emlib/src/em_usart.c ****  * @details
 231:../emlib/src/em_usart.c ****  *   This function returns the baudrate that a USART/UART module will use if
 232:../emlib/src/em_usart.c ****  *   configured with the given frequency, clock divisor and mode. Notice that
 233:../emlib/src/em_usart.c ****  *   this function will not use actual HW configuration. It can be used
 234:../emlib/src/em_usart.c ****  *   to determinate if a given configuration is sufficiently accurate for the
 235:../emlib/src/em_usart.c ****  *   application.
 236:../emlib/src/em_usart.c ****  *
 237:../emlib/src/em_usart.c ****  * @param[in] refFreq
ARM GAS  /tmp/ccmo25Cu.s 			page 9


 238:../emlib/src/em_usart.c ****  *   USART/UART HF peripheral frequency used.
 239:../emlib/src/em_usart.c ****  *
 240:../emlib/src/em_usart.c ****  * @param[in] clkdiv
 241:../emlib/src/em_usart.c ****  *   Clock division factor to be used.
 242:../emlib/src/em_usart.c ****  *
 243:../emlib/src/em_usart.c ****  * @param[in] syncmode
 244:../emlib/src/em_usart.c ****  *   @li true - synchronous mode operation.
 245:../emlib/src/em_usart.c ****  *   @li false - asynchronous mode operation.
 246:../emlib/src/em_usart.c ****  *
 247:../emlib/src/em_usart.c ****  * @param[in] ovs
 248:../emlib/src/em_usart.c ****  *   Oversampling used if asynchronous mode. Not used if @p syncmode is true.
 249:../emlib/src/em_usart.c ****  *
 250:../emlib/src/em_usart.c ****  * @return
 251:../emlib/src/em_usart.c ****  *   Baudrate with given settings.
 252:../emlib/src/em_usart.c ****  ******************************************************************************/
 253:../emlib/src/em_usart.c **** uint32_t USART_BaudrateCalc(uint32_t refFreq,
 254:../emlib/src/em_usart.c ****                             uint32_t clkdiv,
 255:../emlib/src/em_usart.c ****                             bool syncmode,
 256:../emlib/src/em_usart.c ****                             USART_OVS_TypeDef ovs)
 257:../emlib/src/em_usart.c **** {
 205              		.loc 1 257 0
 206              		.cfi_startproc
 207              		@ args = 0, pretend = 0, frame = 0
 208              		@ frame_needed = 0, uses_anonymous_args = 0
 209              	.LVL22:
 210 0000 10B5     		push	{r4, lr}
 211              		.cfi_def_cfa_offset 8
 212              		.cfi_offset 4, -8
 213              		.cfi_offset 14, -4
 258:../emlib/src/em_usart.c ****   uint32_t oversample;
 259:../emlib/src/em_usart.c ****   uint32_t divisor;
 260:../emlib/src/em_usart.c ****   uint32_t factor;
 261:../emlib/src/em_usart.c ****   uint32_t remainder;
 262:../emlib/src/em_usart.c ****   uint32_t quotient;
 263:../emlib/src/em_usart.c ****   uint32_t br;
 264:../emlib/src/em_usart.c **** 
 265:../emlib/src/em_usart.c ****   /* Mask out unused bits */
 266:../emlib/src/em_usart.c ****   clkdiv &= _USART_CLKDIV_MASK;
 214              		.loc 1 266 0
 215 0002 0F4C     		ldr	r4, .L26
 216 0004 0C40     		ands	r4, r4, r1
 217              	.LVL23:
 267:../emlib/src/em_usart.c **** 
 268:../emlib/src/em_usart.c ****   /* We want to use integer division to avoid forcing in float division */
 269:../emlib/src/em_usart.c ****   /* utils, and yet keep rounding effect errors to a minimum. */
 270:../emlib/src/em_usart.c **** 
 271:../emlib/src/em_usart.c ****   /* Baudrate calculation depends on if synchronous or asynchronous mode */
 272:../emlib/src/em_usart.c ****   if (syncmode)
 218              		.loc 1 272 0
 219 0006 5AB9     		cbnz	r2, .L24
 273:../emlib/src/em_usart.c ****   {
 274:../emlib/src/em_usart.c ****     /*
 275:../emlib/src/em_usart.c ****      * Baudrate is given by:
 276:../emlib/src/em_usart.c ****      *
 277:../emlib/src/em_usart.c ****      * br = fHFPERCLK/(2 * (1 + (CLKDIV / 256)))
 278:../emlib/src/em_usart.c ****      *
 279:../emlib/src/em_usart.c ****      * which can be rewritten to
ARM GAS  /tmp/ccmo25Cu.s 			page 10


 280:../emlib/src/em_usart.c ****      *
 281:../emlib/src/em_usart.c ****      * br = (128 * fHFPERCLK)/(256 + CLKDIV)
 282:../emlib/src/em_usart.c ****      */
 283:../emlib/src/em_usart.c ****     oversample = 1; /* Not used in sync mode, ie 1 */
 284:../emlib/src/em_usart.c ****     factor     = 128;
 285:../emlib/src/em_usart.c ****   }
 286:../emlib/src/em_usart.c ****   else
 287:../emlib/src/em_usart.c ****   {
 288:../emlib/src/em_usart.c ****     /*
 289:../emlib/src/em_usart.c ****      * Baudrate in asynchronous mode is given by:
 290:../emlib/src/em_usart.c ****      *
 291:../emlib/src/em_usart.c ****      * br = fHFPERCLK/(oversample * (1 + (CLKDIV / 256)))
 292:../emlib/src/em_usart.c ****      *
 293:../emlib/src/em_usart.c ****      * which can be rewritten to
 294:../emlib/src/em_usart.c ****      *
 295:../emlib/src/em_usart.c ****      * br = (256 * fHFPERCLK)/(oversample * (256 + CLKDIV))
 296:../emlib/src/em_usart.c ****      *
 297:../emlib/src/em_usart.c ****      * First of all we can reduce the 256 factor of the dividend with
 298:../emlib/src/em_usart.c ****      * (part of) oversample part of the divisor.
 299:../emlib/src/em_usart.c ****      */
 300:../emlib/src/em_usart.c **** 
 301:../emlib/src/em_usart.c ****     switch (ovs)
 220              		.loc 1 301 0
 221 0008 202B     		cmp	r3, #32
 222 000a 0AD0     		beq	.L25
 223 000c 402B     		cmp	r3, #64
 224 000e 04D0     		beq	.L22
 225 0010 002B     		cmp	r3, #0
 302:../emlib/src/em_usart.c ****     {
 303:../emlib/src/em_usart.c ****     case USART_CTRL_OVS_X16:
 304:../emlib/src/em_usart.c ****       oversample = 1;
 305:../emlib/src/em_usart.c ****       factor     = 256 / 16;
 306:../emlib/src/em_usart.c ****       break;
 307:../emlib/src/em_usart.c **** 
 308:../emlib/src/em_usart.c ****     case USART_CTRL_OVS_X8:
 309:../emlib/src/em_usart.c ****       oversample = 1;
 310:../emlib/src/em_usart.c ****       factor     = 256 / 8;
 311:../emlib/src/em_usart.c ****       break;
 312:../emlib/src/em_usart.c **** 
 313:../emlib/src/em_usart.c ****     case USART_CTRL_OVS_X6:
 314:../emlib/src/em_usart.c ****       oversample = 3;
 315:../emlib/src/em_usart.c ****       factor     = 256 / 2;
 316:../emlib/src/em_usart.c ****       break;
 317:../emlib/src/em_usart.c **** 
 318:../emlib/src/em_usart.c ****     default:
 319:../emlib/src/em_usart.c ****       oversample = 1;
 320:../emlib/src/em_usart.c ****       factor     = 256 / 4;
 226              		.loc 1 320 0
 227 0012 0CBF     		ite	eq
 228 0014 1023     		moveq	r3, #16
 229 0016 4023     		movne	r3, #64
 230              	.LVL24:
 231 0018 03E0     		b	.L25
 232              	.LVL25:
 233              	.L22:
 315:../emlib/src/em_usart.c ****       factor     = 256 / 2;
 234              		.loc 1 315 0
ARM GAS  /tmp/ccmo25Cu.s 			page 11


 235 001a 8023     		movs	r3, #128
 236              	.LVL26:
 314:../emlib/src/em_usart.c ****       oversample = 3;
 237              		.loc 1 314 0
 238 001c 0322     		movs	r2, #3
 239              	.LVL27:
 316:../emlib/src/em_usart.c ****       break;
 240              		.loc 1 316 0
 241 001e 01E0     		b	.L20
 242              	.LVL28:
 243              	.L24:
 284:../emlib/src/em_usart.c ****     factor     = 128;
 244              		.loc 1 284 0
 245 0020 8023     		movs	r3, #128
 246              	.LVL29:
 247              	.L25:
 309:../emlib/src/em_usart.c ****       oversample = 1;
 248              		.loc 1 309 0
 249 0022 0122     		movs	r2, #1
 250              	.LVL30:
 251              	.L20:
 321:../emlib/src/em_usart.c ****       break;
 322:../emlib/src/em_usart.c ****     }
 323:../emlib/src/em_usart.c ****   }
 324:../emlib/src/em_usart.c **** 
 325:../emlib/src/em_usart.c ****   /*
 326:../emlib/src/em_usart.c ****    * The basic problem with integer division in the above formula is that
 327:../emlib/src/em_usart.c ****    * the dividend (factor * fHFPERCLK) may become higher than max 32 bit
 328:../emlib/src/em_usart.c ****    * integer. Yet we want to evaluate dividend first before dividing in
 329:../emlib/src/em_usart.c ****    * order to get as small rounding effects as possible. We do not want
 330:../emlib/src/em_usart.c ****    * to make too harsh restrictions on max fHFPERCLK value either.
 331:../emlib/src/em_usart.c ****    *
 332:../emlib/src/em_usart.c ****    * For division a/b, we can write
 333:../emlib/src/em_usart.c ****    *
 334:../emlib/src/em_usart.c ****    * a = qb + r
 335:../emlib/src/em_usart.c ****    *
 336:../emlib/src/em_usart.c ****    * where q is the quotient and r is the remainder, both integers.
 337:../emlib/src/em_usart.c ****    *
 338:../emlib/src/em_usart.c ****    * The orignal baudrate formula can be rewritten as
 339:../emlib/src/em_usart.c ****    *
 340:../emlib/src/em_usart.c ****    * br = xa / b = x(qb + r)/b = xq + xr/b
 341:../emlib/src/em_usart.c ****    *
 342:../emlib/src/em_usart.c ****    * where x is 'factor', a is 'refFreq' and b is 'divisor', referring to
 343:../emlib/src/em_usart.c ****    * variable names.
 344:../emlib/src/em_usart.c ****    */
 345:../emlib/src/em_usart.c **** 
 346:../emlib/src/em_usart.c ****   /* Divisor will never exceed max 32 bit value since clkdiv <= 0x1fffc0 */
 347:../emlib/src/em_usart.c ****   /* and 'oversample' has been reduced to <= 3. */
 348:../emlib/src/em_usart.c ****   divisor = oversample * (256 + clkdiv);
 252              		.loc 1 348 0
 253 0024 04F58074 		add	r4, r4, #256
 254              	.LVL31:
 255 0028 6243     		muls	r2, r4, r2
 256              	.LVL32:
 349:../emlib/src/em_usart.c **** 
 350:../emlib/src/em_usart.c ****   quotient  = refFreq / divisor;
 257              		.loc 1 350 0
ARM GAS  /tmp/ccmo25Cu.s 			page 12


 258 002a B0FBF2F1 		udiv	r1, r0, r2
 259              	.LVL33:
 351:../emlib/src/em_usart.c ****   remainder = refFreq % divisor;
 260              		.loc 1 351 0
 261 002e 02FB1100 		mls	r0, r2, r1, r0
 262              	.LVL34:
 352:../emlib/src/em_usart.c **** 
 353:../emlib/src/em_usart.c ****   /* factor <= 128 and since divisor >= 256, the below cannot exceed max */
 354:../emlib/src/em_usart.c ****   /* 32 bit value. */
 355:../emlib/src/em_usart.c ****   br = factor * quotient;
 356:../emlib/src/em_usart.c **** 
 357:../emlib/src/em_usart.c ****   /*
 358:../emlib/src/em_usart.c ****    * factor <= 128 and remainder < (oversample*(256 + clkdiv)), which
 359:../emlib/src/em_usart.c ****    * means dividend (factor * remainder) worst case is
 360:../emlib/src/em_usart.c ****    * 128*(3 * (256 + 0x1fffc0)) = 0x30012000.
 361:../emlib/src/em_usart.c ****    */
 362:../emlib/src/em_usart.c ****   br += (factor * remainder) / divisor;
 263              		.loc 1 362 0
 264 0032 5843     		muls	r0, r3, r0
 265 0034 B0FBF2F0 		udiv	r0, r0, r2
 363:../emlib/src/em_usart.c **** 
 364:../emlib/src/em_usart.c ****   return br;
 365:../emlib/src/em_usart.c **** }
 266              		.loc 1 365 0
 267 0038 03FB0100 		mla	r0, r3, r1, r0
 268 003c 10BD     		pop	{r4, pc}
 269              	.LVL35:
 270              	.L27:
 271 003e 00BF     		.align	2
 272              	.L26:
 273 0040 C0FF1F00 		.word	2097088
 274              		.cfi_endproc
 275              	.LFE79:
 277              		.section	.text.USART_BaudrateGet,"ax",%progbits
 278              		.align	1
 279              		.global	USART_BaudrateGet
 280              		.thumb
 281              		.thumb_func
 283              	USART_BaudrateGet:
 284              	.LFB80:
 366:../emlib/src/em_usart.c **** 
 367:../emlib/src/em_usart.c **** 
 368:../emlib/src/em_usart.c **** /***************************************************************************//**
 369:../emlib/src/em_usart.c ****  * @brief
 370:../emlib/src/em_usart.c ****  *   Get current baudrate for USART/UART.
 371:../emlib/src/em_usart.c ****  *
 372:../emlib/src/em_usart.c ****  * @details
 373:../emlib/src/em_usart.c ****  *   This function returns the actual baudrate (not considering oscillator
 374:../emlib/src/em_usart.c ****  *   inaccuracies) used by a USART/UART peripheral.
 375:../emlib/src/em_usart.c ****  *
 376:../emlib/src/em_usart.c ****  * @param[in] usart
 377:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 378:../emlib/src/em_usart.c ****  *
 379:../emlib/src/em_usart.c ****  * @return
 380:../emlib/src/em_usart.c ****  *   Current baudrate.
 381:../emlib/src/em_usart.c ****  ******************************************************************************/
 382:../emlib/src/em_usart.c **** uint32_t USART_BaudrateGet(USART_TypeDef *usart)
ARM GAS  /tmp/ccmo25Cu.s 			page 13


 383:../emlib/src/em_usart.c **** {
 285              		.loc 1 383 0
 286              		.cfi_startproc
 287              		@ args = 0, pretend = 0, frame = 0
 288              		@ frame_needed = 0, uses_anonymous_args = 0
 289              	.LVL36:
 290 0000 70B5     		push	{r4, r5, r6, lr}
 291              		.cfi_def_cfa_offset 16
 292              		.cfi_offset 4, -16
 293              		.cfi_offset 5, -12
 294              		.cfi_offset 6, -8
 295              		.cfi_offset 14, -4
 296              		.loc 1 383 0
 297 0002 0446     		mov	r4, r0
 384:../emlib/src/em_usart.c ****   uint32_t          freq;
 385:../emlib/src/em_usart.c ****   USART_OVS_TypeDef ovs;
 386:../emlib/src/em_usart.c ****   bool              syncmode;
 387:../emlib/src/em_usart.c **** 
 388:../emlib/src/em_usart.c ****   if (usart->CTRL & USART_CTRL_SYNC)
 298              		.loc 1 388 0
 299 0004 0568     		ldr	r5, [r0]
 300              	.LVL37:
 389:../emlib/src/em_usart.c ****   {
 390:../emlib/src/em_usart.c ****     syncmode = true;
 391:../emlib/src/em_usart.c ****   }
 392:../emlib/src/em_usart.c ****   else
 393:../emlib/src/em_usart.c ****   {
 394:../emlib/src/em_usart.c ****     syncmode = false;
 395:../emlib/src/em_usart.c ****   }
 396:../emlib/src/em_usart.c **** 
 397:../emlib/src/em_usart.c ****   /* HFPERCLK used to clock all USART/UART peripheral modules */
 398:../emlib/src/em_usart.c ****   freq = CMU_ClockFreqGet(cmuClock_HFPER);
 301              		.loc 1 398 0
 302 0006 0648     		ldr	r0, .L29
 303              	.LVL38:
 304 0008 FFF7FEFF 		bl	CMU_ClockFreqGet
 305              	.LVL39:
 399:../emlib/src/em_usart.c ****   ovs  = (USART_OVS_TypeDef) (usart->CTRL & _USART_CTRL_OVS_MASK);
 306              		.loc 1 399 0
 307 000c 2368     		ldr	r3, [r4]
 308              	.LVL40:
 400:../emlib/src/em_usart.c ****   return USART_BaudrateCalc(freq, usart->CLKDIV, syncmode, ovs);
 309              		.loc 1 400 0
 310 000e 05F00102 		and	r2, r5, #1
 311 0012 6169     		ldr	r1, [r4, #20]
 312 0014 03F06003 		and	r3, r3, #96
 313              	.LVL41:
 401:../emlib/src/em_usart.c **** }
 314              		.loc 1 401 0
 315 0018 BDE87040 		pop	{r4, r5, r6, lr}
 316              	.LVL42:
 400:../emlib/src/em_usart.c ****   return USART_BaudrateCalc(freq, usart->CLKDIV, syncmode, ovs);
 317              		.loc 1 400 0
 318 001c FFF7FEBF 		b	USART_BaudrateCalc
 319              	.LVL43:
 320              	.L30:
 321              		.align	2
ARM GAS  /tmp/ccmo25Cu.s 			page 14


 322              	.L29:
 323 0020 10810200 		.word	164112
 324              		.cfi_endproc
 325              	.LFE80:
 327              		.section	.text.USART_BaudrateSyncSet,"ax",%progbits
 328              		.align	1
 329              		.global	USART_BaudrateSyncSet
 330              		.thumb
 331              		.thumb_func
 333              	USART_BaudrateSyncSet:
 334              	.LFB81:
 402:../emlib/src/em_usart.c **** 
 403:../emlib/src/em_usart.c **** 
 404:../emlib/src/em_usart.c **** /***************************************************************************//**
 405:../emlib/src/em_usart.c ****  * @brief
 406:../emlib/src/em_usart.c ****  *   Configure USART operating in synchronous mode to use a given baudrate
 407:../emlib/src/em_usart.c ****  *   (or as close as possible to specified baudrate).
 408:../emlib/src/em_usart.c ****  *
 409:../emlib/src/em_usart.c ****  * @details
 410:../emlib/src/em_usart.c ****  *   The configuration will be set to use a baudrate <= the specified baudrate
 411:../emlib/src/em_usart.c ****  *   in order to ensure that the baudrate does not exceed the specified value.
 412:../emlib/src/em_usart.c ****  *
 413:../emlib/src/em_usart.c ****  *   Fractional clock division is suppressed, although the HW design allows it.
 414:../emlib/src/em_usart.c ****  *   It could cause half clock cycles to exceed specified limit, and thus
 415:../emlib/src/em_usart.c ****  *   potentially violate specifications for the slave device. In some special
 416:../emlib/src/em_usart.c ****  *   situations fractional clock division may be useful even in synchronous
 417:../emlib/src/em_usart.c ****  *   mode, but in those cases it must be directly adjusted, possibly assisted
 418:../emlib/src/em_usart.c ****  *   by USART_BaudrateCalc():
 419:../emlib/src/em_usart.c ****  *
 420:../emlib/src/em_usart.c ****  * @param[in] usart
 421:../emlib/src/em_usart.c ****  *   Pointer to USART peripheral register block. (Cannot be used on UART
 422:../emlib/src/em_usart.c ****  *   modules.)
 423:../emlib/src/em_usart.c ****  *
 424:../emlib/src/em_usart.c ****  * @param[in] refFreq
 425:../emlib/src/em_usart.c ****  *   USART reference clock frequency in Hz that will be used. If set to 0,
 426:../emlib/src/em_usart.c ****  *   the currently configured reference clock is assumed.
 427:../emlib/src/em_usart.c ****  *
 428:../emlib/src/em_usart.c ****  * @param[in] baudrate
 429:../emlib/src/em_usart.c ****  *   Baudrate to try to achieve for USART.
 430:../emlib/src/em_usart.c ****  ******************************************************************************/
 431:../emlib/src/em_usart.c **** void USART_BaudrateSyncSet(USART_TypeDef *usart, uint32_t refFreq, uint32_t baudrate)
 432:../emlib/src/em_usart.c **** {
 335              		.loc 1 432 0
 336              		.cfi_startproc
 337              		@ args = 0, pretend = 0, frame = 0
 338              		@ frame_needed = 0, uses_anonymous_args = 0
 339              	.LVL44:
 340 0000 70B5     		push	{r4, r5, r6, lr}
 341              		.cfi_def_cfa_offset 16
 342              		.cfi_offset 4, -16
 343              		.cfi_offset 5, -12
 344              		.cfi_offset 6, -8
 345              		.cfi_offset 14, -4
 346              		.loc 1 432 0
 347 0002 0646     		mov	r6, r0
 348 0004 0D46     		mov	r5, r1
 433:../emlib/src/em_usart.c ****   uint32_t clkdiv;
ARM GAS  /tmp/ccmo25Cu.s 			page 15


 434:../emlib/src/em_usart.c **** 
 435:../emlib/src/em_usart.c ****   /* Inhibit divide by 0 */
 436:../emlib/src/em_usart.c ****   EFM_ASSERT(baudrate);
 349              		.loc 1 436 0
 350 0006 1446     		mov	r4, r2
 351 0008 22B9     		cbnz	r2, .L32
 352              		.loc 1 436 0 is_stmt 0 discriminator 1
 353 000a 0F48     		ldr	r0, .L35
 354              	.LVL45:
 355 000c 4FF4DA71 		mov	r1, #436
 356              	.LVL46:
 357 0010 FFF7FEFF 		bl	assertEFM
 358              	.LVL47:
 359              	.L32:
 437:../emlib/src/em_usart.c **** 
 438:../emlib/src/em_usart.c ****   /*
 439:../emlib/src/em_usart.c ****    * We want to use integer division to avoid forcing in float division
 440:../emlib/src/em_usart.c ****    * utils, and yet keep rounding effect errors to a minimum.
 441:../emlib/src/em_usart.c ****    *
 442:../emlib/src/em_usart.c ****    * CLKDIV in synchronous mode is given by:
 443:../emlib/src/em_usart.c ****    *
 444:../emlib/src/em_usart.c ****    * CLKDIV = 256 * (fHFPERCLK/(2 * br) - 1)
 445:../emlib/src/em_usart.c ****    * or
 446:../emlib/src/em_usart.c ****    * CLKDIV = (256 * fHFPERCLK)/(2 * br) - 256 = (128 * fHFPERCLK)/br - 256
 447:../emlib/src/em_usart.c ****    *
 448:../emlib/src/em_usart.c ****    * The basic problem with integer division in the above formula is that
 449:../emlib/src/em_usart.c ****    * the dividend (128 * fHFPERCLK) may become higher than max 32 bit
 450:../emlib/src/em_usart.c ****    * integer. Yet, we want to evaluate dividend first before dividing in
 451:../emlib/src/em_usart.c ****    * order to get as small rounding effects as possible. We do not want
 452:../emlib/src/em_usart.c ****    * to make too harsh restrictions on max fHFPERCLK value either.
 453:../emlib/src/em_usart.c ****    *
 454:../emlib/src/em_usart.c ****    * One can possibly factorize 128 and br. However, since the last
 455:../emlib/src/em_usart.c ****    * 6 bits of CLKDIV are don't care, we can base our integer arithmetic
 456:../emlib/src/em_usart.c ****    * on the below formula without loosing any extra precision:
 457:../emlib/src/em_usart.c ****    *
 458:../emlib/src/em_usart.c ****    * CLKDIV / 64 = (2 * fHFPERCLK)/br - 4
 459:../emlib/src/em_usart.c ****    *
 460:../emlib/src/em_usart.c ****    * and calculate 1/64 of CLKDIV first. This allows for fHFPERCLK
 461:../emlib/src/em_usart.c ****    * up to 2GHz without overflowing a 32 bit value!
 462:../emlib/src/em_usart.c ****    */
 463:../emlib/src/em_usart.c **** 
 464:../emlib/src/em_usart.c ****   /* HFPERCLK used to clock all USART/UART peripheral modules */
 465:../emlib/src/em_usart.c ****   if (!refFreq)
 360              		.loc 1 465 0 is_stmt 1
 361 0014 1DB9     		cbnz	r5, .L33
 466:../emlib/src/em_usart.c ****   {
 467:../emlib/src/em_usart.c ****     refFreq = CMU_ClockFreqGet(cmuClock_HFPER);
 362              		.loc 1 467 0
 363 0016 0D48     		ldr	r0, .L35+4
 364 0018 FFF7FEFF 		bl	CMU_ClockFreqGet
 365              	.LVL48:
 366 001c 0546     		mov	r5, r0
 367              	.LVL49:
 368              	.L33:
 468:../emlib/src/em_usart.c ****   }
 469:../emlib/src/em_usart.c **** 
 470:../emlib/src/em_usart.c ****   /* Calculate and set CLKDIV with fractional bits */
ARM GAS  /tmp/ccmo25Cu.s 			page 16


 471:../emlib/src/em_usart.c ****   clkdiv  = 2 * refFreq;
 472:../emlib/src/em_usart.c ****   clkdiv += baudrate - 1;
 369              		.loc 1 472 0
 370 001e 631E     		subs	r3, r4, #1
 371 0020 03EB4505 		add	r5, r3, r5, lsl #1
 372              	.LVL50:
 473:../emlib/src/em_usart.c ****   clkdiv /= baudrate;
 373              		.loc 1 473 0
 374 0024 B5FBF4F4 		udiv	r4, r5, r4
 375              	.LVL51:
 474:../emlib/src/em_usart.c ****   clkdiv -= 4;
 475:../emlib/src/em_usart.c ****   clkdiv *= 64;
 376              		.loc 1 475 0
 377 0028 A401     		lsls	r4, r4, #6
 378              	.LVL52:
 476:../emlib/src/em_usart.c ****   /* Make sure we don't use fractional bits by rounding CLKDIV */
 477:../emlib/src/em_usart.c ****   /* up (and thus reducing baudrate, not increasing baudrate above */
 478:../emlib/src/em_usart.c ****   /* specified value). */
 479:../emlib/src/em_usart.c ****   clkdiv += 0xc0;
 379              		.loc 1 479 0
 380 002a 403C     		subs	r4, r4, #64
 381              	.LVL53:
 480:../emlib/src/em_usart.c ****   clkdiv &= 0xffffff00;
 481:../emlib/src/em_usart.c **** 
 482:../emlib/src/em_usart.c ****   /* Verify that resulting clock divider is within limits */
 483:../emlib/src/em_usart.c ****   EFM_ASSERT(clkdiv <= _USART_CLKDIV_MASK);
 382              		.loc 1 483 0
 383 002c 084B     		ldr	r3, .L35+8
 384              	.LVL54:
 480:../emlib/src/em_usart.c ****   clkdiv &= 0xffffff00;
 385              		.loc 1 480 0
 386 002e 24F0FF02 		bic	r2, r4, #255
 387              	.LVL55:
 388              		.loc 1 483 0
 389 0032 9A42     		cmp	r2, r3
 390 0034 04D9     		bls	.L34
 391              		.loc 1 483 0 is_stmt 0 discriminator 1
 392 0036 0448     		ldr	r0, .L35
 393 0038 40F2E311 		movw	r1, #483
 394 003c FFF7FEFF 		bl	assertEFM
 395              	.LVL56:
 396              	.L34:
 484:../emlib/src/em_usart.c **** 
 485:../emlib/src/em_usart.c ****   /* If EFM_ASSERT is not enabled, make sure we don't write to reserved bits */
 486:../emlib/src/em_usart.c ****   clkdiv &= _USART_CLKDIV_DIV_MASK;
 397              		.loc 1 486 0 is_stmt 1
 398 0040 044B     		ldr	r3, .L35+12
 399 0042 2340     		ands	r3, r3, r4
 400              	.LVL57:
 487:../emlib/src/em_usart.c **** 
 488:../emlib/src/em_usart.c ****   usart->CLKDIV = clkdiv;
 401              		.loc 1 488 0
 402 0044 7361     		str	r3, [r6, #20]
 403 0046 70BD     		pop	{r4, r5, r6, pc}
 404              	.LVL58:
 405              	.L36:
 406              		.align	2
ARM GAS  /tmp/ccmo25Cu.s 			page 17


 407              	.L35:
 408 0048 00000000 		.word	.LC0
 409 004c 10810200 		.word	164112
 410 0050 C0FF1F00 		.word	2097088
 411 0054 00FF1F00 		.word	2096896
 412              		.cfi_endproc
 413              	.LFE81:
 415              		.section	.text.USART_Enable,"ax",%progbits
 416              		.align	1
 417              		.global	USART_Enable
 418              		.thumb
 419              		.thumb_func
 421              	USART_Enable:
 422              	.LFB82:
 489:../emlib/src/em_usart.c **** }
 490:../emlib/src/em_usart.c **** 
 491:../emlib/src/em_usart.c **** 
 492:../emlib/src/em_usart.c **** /***************************************************************************//**
 493:../emlib/src/em_usart.c ****  * @brief
 494:../emlib/src/em_usart.c ****  *   Enable/disable USART/UART receiver and/or transmitter.
 495:../emlib/src/em_usart.c ****  *
 496:../emlib/src/em_usart.c ****  * @details
 497:../emlib/src/em_usart.c ****  *   Notice that this function does not do any configuration. Enabling should
 498:../emlib/src/em_usart.c ****  *   normally be done after initialization is done (if not enabled as part
 499:../emlib/src/em_usart.c ****  *   of init).
 500:../emlib/src/em_usart.c ****  *
 501:../emlib/src/em_usart.c ****  * @param[in] usart
 502:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 503:../emlib/src/em_usart.c ****  *
 504:../emlib/src/em_usart.c ****  * @param[in] enable
 505:../emlib/src/em_usart.c ****  *   Select status for receiver/transmitter.
 506:../emlib/src/em_usart.c ****  ******************************************************************************/
 507:../emlib/src/em_usart.c **** void USART_Enable(USART_TypeDef *usart, USART_Enable_TypeDef enable)
 508:../emlib/src/em_usart.c **** {
 423              		.loc 1 508 0
 424              		.cfi_startproc
 425              		@ args = 0, pretend = 0, frame = 0
 426              		@ frame_needed = 0, uses_anonymous_args = 0
 427              	.LVL59:
 428 0000 38B5     		push	{r3, r4, r5, lr}
 429              		.cfi_def_cfa_offset 16
 430              		.cfi_offset 3, -16
 431              		.cfi_offset 4, -12
 432              		.cfi_offset 5, -8
 433              		.cfi_offset 14, -4
 509:../emlib/src/em_usart.c ****   uint32_t tmp;
 510:../emlib/src/em_usart.c **** 
 511:../emlib/src/em_usart.c ****   /* Make sure the module exists on the selected chip */
 512:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart) || (UART_REF_VALID(usart)));
 434              		.loc 1 512 0
 435 0002 0C4B     		ldr	r3, .L39
 508:../emlib/src/em_usart.c **** {
 436              		.loc 1 508 0
 437 0004 0446     		mov	r4, r0
 438              		.loc 1 512 0
 439 0006 9842     		cmp	r0, r3
 508:../emlib/src/em_usart.c **** {
ARM GAS  /tmp/ccmo25Cu.s 			page 18


 440              		.loc 1 508 0
 441 0008 0D46     		mov	r5, r1
 442              		.loc 1 512 0
 443 000a 0CD0     		beq	.L38
 444              		.loc 1 512 0 is_stmt 0 discriminator 1
 445 000c 03F58063 		add	r3, r3, #1024
 446 0010 9842     		cmp	r0, r3
 447 0012 08D0     		beq	.L38
 448 0014 03F58063 		add	r3, r3, #1024
 449 0018 9842     		cmp	r0, r3
 450 001a 04D0     		beq	.L38
 451 001c 0648     		ldr	r0, .L39+4
 452              	.LVL60:
 453 001e 4FF40071 		mov	r1, #512
 454              	.LVL61:
 455 0022 FFF7FEFF 		bl	assertEFM
 456              	.LVL62:
 457              	.L38:
 513:../emlib/src/em_usart.c **** 
 514:../emlib/src/em_usart.c ****   /* Disable as specified */
 515:../emlib/src/em_usart.c ****   tmp        = ~((uint32_t) (enable));
 458              		.loc 1 515 0 is_stmt 1
 459 0026 EB43     		mvns	r3, r5
 460              	.LVL63:
 516:../emlib/src/em_usart.c ****   tmp       &= _USART_CMD_RXEN_MASK | _USART_CMD_TXEN_MASK;
 461              		.loc 1 516 0
 462 0028 03F00503 		and	r3, r3, #5
 463              	.LVL64:
 517:../emlib/src/em_usart.c ****   usart->CMD = tmp << 1;
 464              		.loc 1 517 0
 465 002c 5B00     		lsls	r3, r3, #1
 466              	.LVL65:
 467 002e E360     		str	r3, [r4, #12]
 518:../emlib/src/em_usart.c **** 
 519:../emlib/src/em_usart.c ****   /* Enable as specified */
 520:../emlib/src/em_usart.c ****   usart->CMD = (uint32_t) (enable);
 468              		.loc 1 520 0
 469 0030 E560     		str	r5, [r4, #12]
 470 0032 38BD     		pop	{r3, r4, r5, pc}
 471              	.LVL66:
 472              	.L40:
 473              		.align	2
 474              	.L39:
 475 0034 00C00040 		.word	1073790976
 476 0038 00000000 		.word	.LC0
 477              		.cfi_endproc
 478              	.LFE82:
 480              		.section	.text.USART_InitPrsTrigger,"ax",%progbits
 481              		.align	1
 482              		.global	USART_InitPrsTrigger
 483              		.thumb
 484              		.thumb_func
 486              	USART_InitPrsTrigger:
 487              	.LFB86:
 521:../emlib/src/em_usart.c **** }
 522:../emlib/src/em_usart.c **** 
 523:../emlib/src/em_usart.c **** 
ARM GAS  /tmp/ccmo25Cu.s 			page 19


 524:../emlib/src/em_usart.c **** /***************************************************************************//**
 525:../emlib/src/em_usart.c ****  * @brief
 526:../emlib/src/em_usart.c ****  *   Init USART/UART for normal asynchronous mode.
 527:../emlib/src/em_usart.c ****  *
 528:../emlib/src/em_usart.c ****  * @details
 529:../emlib/src/em_usart.c ****  *   This function will configure basic settings in order to operate in normal
 530:../emlib/src/em_usart.c ****  *   asynchronous mode.
 531:../emlib/src/em_usart.c ****  *
 532:../emlib/src/em_usart.c ****  *   Special control setup not covered by this function must be done after
 533:../emlib/src/em_usart.c ****  *   using this function by direct modification of the CTRL register.
 534:../emlib/src/em_usart.c ****  *
 535:../emlib/src/em_usart.c ****  *   Notice that pins used by the USART/UART module must be properly configured
 536:../emlib/src/em_usart.c ****  *   by the user explicitly, in order for the USART/UART to work as intended.
 537:../emlib/src/em_usart.c ****  *   (When configuring pins, one should remember to consider the sequence of
 538:../emlib/src/em_usart.c ****  *   configuration, in order to avoid unintended pulses/glitches on output
 539:../emlib/src/em_usart.c ****  *   pins.)
 540:../emlib/src/em_usart.c ****  *
 541:../emlib/src/em_usart.c ****  * @param[in] usart
 542:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 543:../emlib/src/em_usart.c ****  *
 544:../emlib/src/em_usart.c ****  * @param[in] init
 545:../emlib/src/em_usart.c ****  *   Pointer to initialization structure used to configure basic async setup.
 546:../emlib/src/em_usart.c ****  ******************************************************************************/
 547:../emlib/src/em_usart.c **** void USART_InitAsync(USART_TypeDef *usart, const USART_InitAsync_TypeDef *init)
 548:../emlib/src/em_usart.c **** {
 549:../emlib/src/em_usart.c ****   /* Make sure the module exists on the selected chip */
 550:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart) || UART_REF_VALID(usart));
 551:../emlib/src/em_usart.c **** 
 552:../emlib/src/em_usart.c ****   /* Init USART registers to HW reset state. */
 553:../emlib/src/em_usart.c ****   USART_Reset(usart);
 554:../emlib/src/em_usart.c **** 
 555:../emlib/src/em_usart.c **** #if defined(USART_INPUT_RXPRS) && defined(USART_CTRL_MVDIS)
 556:../emlib/src/em_usart.c ****   /* Disable majority vote if specified. */
 557:../emlib/src/em_usart.c ****   if (init->mvdis)
 558:../emlib/src/em_usart.c ****   {
 559:../emlib/src/em_usart.c ****     usart->CTRL |= USART_CTRL_MVDIS;
 560:../emlib/src/em_usart.c ****   }
 561:../emlib/src/em_usart.c **** 
 562:../emlib/src/em_usart.c ****   /* Configure PRS input mode. */
 563:../emlib/src/em_usart.c ****   if (init->prsRxEnable)
 564:../emlib/src/em_usart.c ****   {
 565:../emlib/src/em_usart.c ****     usart->INPUT = (uint32_t) init->prsRxCh | USART_INPUT_RXPRS;
 566:../emlib/src/em_usart.c ****   }
 567:../emlib/src/em_usart.c **** #endif
 568:../emlib/src/em_usart.c **** 
 569:../emlib/src/em_usart.c ****   /* Configure databits, stopbits and parity */
 570:../emlib/src/em_usart.c ****   usart->FRAME = (uint32_t) (init->databits) |
 571:../emlib/src/em_usart.c ****                  (uint32_t) (init->stopbits) |
 572:../emlib/src/em_usart.c ****                  (uint32_t) (init->parity);
 573:../emlib/src/em_usart.c **** 
 574:../emlib/src/em_usart.c ****   /* Configure baudrate */
 575:../emlib/src/em_usart.c ****   USART_BaudrateAsyncSet(usart, init->refFreq, init->baudrate, init->oversampling);
 576:../emlib/src/em_usart.c **** 
 577:../emlib/src/em_usart.c ****   /* Finally enable (as specified) */
 578:../emlib/src/em_usart.c ****   usart->CMD = (uint32_t) (init->enable);
 579:../emlib/src/em_usart.c **** }
 580:../emlib/src/em_usart.c **** 
ARM GAS  /tmp/ccmo25Cu.s 			page 20


 581:../emlib/src/em_usart.c **** 
 582:../emlib/src/em_usart.c **** /***************************************************************************//**
 583:../emlib/src/em_usart.c ****  * @brief
 584:../emlib/src/em_usart.c ****  *   Init USART for synchronous mode.
 585:../emlib/src/em_usart.c ****  *
 586:../emlib/src/em_usart.c ****  * @details
 587:../emlib/src/em_usart.c ****  *   This function will configure basic settings in order to operate in
 588:../emlib/src/em_usart.c ****  *   synchronous mode.
 589:../emlib/src/em_usart.c ****  *
 590:../emlib/src/em_usart.c ****  *   Special control setup not covered by this function must be done after
 591:../emlib/src/em_usart.c ****  *   using this function by direct modification of the CTRL register.
 592:../emlib/src/em_usart.c ****  *
 593:../emlib/src/em_usart.c ****  *   Notice that pins used by the USART module must be properly configured
 594:../emlib/src/em_usart.c ****  *   by the user explicitly, in order for the USART to work as intended.
 595:../emlib/src/em_usart.c ****  *   (When configuring pins, one should remember to consider the sequence of
 596:../emlib/src/em_usart.c ****  *   configuration, in order to avoid unintended pulses/glitches on output
 597:../emlib/src/em_usart.c ****  *   pins.)
 598:../emlib/src/em_usart.c ****  *
 599:../emlib/src/em_usart.c ****  * @param[in] usart
 600:../emlib/src/em_usart.c ****  *   Pointer to USART peripheral register block. (UART does not support this
 601:../emlib/src/em_usart.c ****  *   mode.)
 602:../emlib/src/em_usart.c ****  *
 603:../emlib/src/em_usart.c ****  * @param[in] init
 604:../emlib/src/em_usart.c ****  *   Pointer to initialization structure used to configure basic async setup.
 605:../emlib/src/em_usart.c ****  ******************************************************************************/
 606:../emlib/src/em_usart.c **** void USART_InitSync(USART_TypeDef *usart, const USART_InitSync_TypeDef *init)
 607:../emlib/src/em_usart.c **** {
 608:../emlib/src/em_usart.c ****   /* Make sure the module exists on the selected chip */
 609:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart));
 610:../emlib/src/em_usart.c **** 
 611:../emlib/src/em_usart.c ****   /* Init USART registers to HW reset state. */
 612:../emlib/src/em_usart.c ****   USART_Reset(usart);
 613:../emlib/src/em_usart.c **** 
 614:../emlib/src/em_usart.c ****   /* Set bits for synchronous mode */
 615:../emlib/src/em_usart.c ****   usart->CTRL |= (USART_CTRL_SYNC) |
 616:../emlib/src/em_usart.c ****                  ((uint32_t) init->clockMode) |
 617:../emlib/src/em_usart.c ****                  (init->msbf ? USART_CTRL_MSBF : 0);
 618:../emlib/src/em_usart.c **** 
 619:../emlib/src/em_usart.c **** #if defined(USART_INPUT_RXPRS) && defined(USART_TRIGCTRL_AUTOTXTEN)
 620:../emlib/src/em_usart.c ****   usart->CTRL |= (init->prsRxEnable ? USART_INPUT_RXPRS : 0) |
 621:../emlib/src/em_usart.c ****                  (init->autoTx      ? USART_CTRL_AUTOTX : 0);
 622:../emlib/src/em_usart.c **** #endif
 623:../emlib/src/em_usart.c **** 
 624:../emlib/src/em_usart.c ****   /* Configure databits, leave stopbits and parity at reset default (not used) */
 625:../emlib/src/em_usart.c ****   usart->FRAME = ((uint32_t) (init->databits)) |
 626:../emlib/src/em_usart.c ****                  (USART_FRAME_STOPBITS_DEFAULT) |
 627:../emlib/src/em_usart.c ****                  (USART_FRAME_PARITY_DEFAULT);
 628:../emlib/src/em_usart.c **** 
 629:../emlib/src/em_usart.c ****   /* Configure baudrate */
 630:../emlib/src/em_usart.c ****   USART_BaudrateSyncSet(usart, init->refFreq, init->baudrate);
 631:../emlib/src/em_usart.c **** 
 632:../emlib/src/em_usart.c ****   /* Finally enable (as specified) */
 633:../emlib/src/em_usart.c ****   if (init->master)
 634:../emlib/src/em_usart.c ****   {
 635:../emlib/src/em_usart.c ****     usart->CMD = USART_CMD_MASTEREN;
 636:../emlib/src/em_usart.c ****   }
 637:../emlib/src/em_usart.c **** 
ARM GAS  /tmp/ccmo25Cu.s 			page 21


 638:../emlib/src/em_usart.c ****   usart->CMD = (uint32_t) (init->enable);
 639:../emlib/src/em_usart.c **** }
 640:../emlib/src/em_usart.c **** 
 641:../emlib/src/em_usart.c **** 
 642:../emlib/src/em_usart.c **** #if defined(USART0) || ((USART_COUNT == 1) && defined(USART1))
 643:../emlib/src/em_usart.c **** /***************************************************************************//**
 644:../emlib/src/em_usart.c ****  * @brief
 645:../emlib/src/em_usart.c ****  *   Init USART0 for asynchronous IrDA mode.
 646:../emlib/src/em_usart.c ****  *
 647:../emlib/src/em_usart.c ****  * @details
 648:../emlib/src/em_usart.c ****  *   This function will configure basic settings in order to operate in
 649:../emlib/src/em_usart.c ****  *   asynchronous IrDA mode.
 650:../emlib/src/em_usart.c ****  *
 651:../emlib/src/em_usart.c ****  *   Special control setup not covered by this function must be done after
 652:../emlib/src/em_usart.c ****  *   using this function by direct modification of the CTRL and IRCTRL
 653:../emlib/src/em_usart.c ****  *   registers.
 654:../emlib/src/em_usart.c ****  *
 655:../emlib/src/em_usart.c ****  *   Notice that pins used by the USART/UART module must be properly configured
 656:../emlib/src/em_usart.c ****  *   by the user explicitly, in order for the USART/UART to work as intended.
 657:../emlib/src/em_usart.c ****  *   (When configuring pins, one should remember to consider the sequence of
 658:../emlib/src/em_usart.c ****  *   configuration, in order to avoid unintended pulses/glitches on output
 659:../emlib/src/em_usart.c ****  *   pins.)
 660:../emlib/src/em_usart.c ****  *
 661:../emlib/src/em_usart.c ****  * @param[in] init
 662:../emlib/src/em_usart.c ****  *   Pointer to initialization structure used to configure async IrDA setup.
 663:../emlib/src/em_usart.c ****  *
 664:../emlib/src/em_usart.c ****  * @note
 665:../emlib/src/em_usart.c ****  *   This function only applies to USART0 as IrDA is not supported on the other
 666:../emlib/src/em_usart.c ****  *   USART modules.
 667:../emlib/src/em_usart.c ****  *
 668:../emlib/src/em_usart.c ****  ******************************************************************************/
 669:../emlib/src/em_usart.c **** void USART_InitIrDA(const USART_InitIrDA_TypeDef *init)
 670:../emlib/src/em_usart.c **** {
 671:../emlib/src/em_usart.c ****   #if (USART_COUNT == 1) && defined(USART1)
 672:../emlib/src/em_usart.c ****   USART_TypeDef *usart = USART1;
 673:../emlib/src/em_usart.c ****   #else
 674:../emlib/src/em_usart.c ****   USART_TypeDef *usart = USART0;
 675:../emlib/src/em_usart.c ****   #endif
 676:../emlib/src/em_usart.c **** 
 677:../emlib/src/em_usart.c ****   /* Init USART as async device */
 678:../emlib/src/em_usart.c ****   USART_InitAsync(usart, &(init->async));
 679:../emlib/src/em_usart.c **** 
 680:../emlib/src/em_usart.c ****   /* Set IrDA modulation to RZI (return-to-zero-inverted) */
 681:../emlib/src/em_usart.c ****   usart->CTRL |= USART_CTRL_TXINV;
 682:../emlib/src/em_usart.c **** 
 683:../emlib/src/em_usart.c ****   /* Invert Rx signal before demodulator if enabled */
 684:../emlib/src/em_usart.c ****   if (init->irRxInv)
 685:../emlib/src/em_usart.c ****   {
 686:../emlib/src/em_usart.c ****     usart->CTRL |= USART_CTRL_RXINV;
 687:../emlib/src/em_usart.c ****   }
 688:../emlib/src/em_usart.c **** 
 689:../emlib/src/em_usart.c ****   /* Configure IrDA */
 690:../emlib/src/em_usart.c ****   usart->IRCTRL |= (uint32_t) init->irPw |
 691:../emlib/src/em_usart.c ****                    (uint32_t) init->irPrsSel |
 692:../emlib/src/em_usart.c ****                    ((uint32_t) init->irFilt << _USART_IRCTRL_IRFILT_SHIFT) |
 693:../emlib/src/em_usart.c ****                    ((uint32_t) init->irPrsEn << _USART_IRCTRL_IRPRSEN_SHIFT);
 694:../emlib/src/em_usart.c **** 
ARM GAS  /tmp/ccmo25Cu.s 			page 22


 695:../emlib/src/em_usart.c ****   /* Enable IrDA */
 696:../emlib/src/em_usart.c ****   usart->IRCTRL |= USART_IRCTRL_IREN;
 697:../emlib/src/em_usart.c **** }
 698:../emlib/src/em_usart.c **** #endif
 699:../emlib/src/em_usart.c **** 
 700:../emlib/src/em_usart.c **** 
 701:../emlib/src/em_usart.c **** #if defined(_USART_I2SCTRL_MASK)
 702:../emlib/src/em_usart.c **** /***************************************************************************//**
 703:../emlib/src/em_usart.c ****  * @brief
 704:../emlib/src/em_usart.c ****  *   Init USART for I2S mode.
 705:../emlib/src/em_usart.c ****  *
 706:../emlib/src/em_usart.c ****  * @details
 707:../emlib/src/em_usart.c ****  *   This function will configure basic settings in order to operate in I2S
 708:../emlib/src/em_usart.c ****  *   mode.
 709:../emlib/src/em_usart.c ****  *
 710:../emlib/src/em_usart.c ****  *   Special control setup not covered by this function must be done after
 711:../emlib/src/em_usart.c ****  *   using this function by direct modification of the CTRL and I2SCTRL
 712:../emlib/src/em_usart.c ****  *   registers.
 713:../emlib/src/em_usart.c ****  *
 714:../emlib/src/em_usart.c ****  *   Notice that pins used by the USART module must be properly configured
 715:../emlib/src/em_usart.c ****  *   by the user explicitly, in order for the USART to work as intended.
 716:../emlib/src/em_usart.c ****  *   (When configuring pins, one should remember to consider the sequence of
 717:../emlib/src/em_usart.c ****  *   configuration, in order to avoid unintended pulses/glitches on output
 718:../emlib/src/em_usart.c ****  *   pins.)
 719:../emlib/src/em_usart.c ****  *
 720:../emlib/src/em_usart.c ****  * @param[in] usart
 721:../emlib/src/em_usart.c ****  *   Pointer to USART peripheral register block. (UART does not support this
 722:../emlib/src/em_usart.c ****  *   mode.)
 723:../emlib/src/em_usart.c ****  *
 724:../emlib/src/em_usart.c ****  * @param[in] init
 725:../emlib/src/em_usart.c ****  *   Pointer to initialization structure used to configure basic I2S setup.
 726:../emlib/src/em_usart.c ****  *
 727:../emlib/src/em_usart.c ****  * @note
 728:../emlib/src/em_usart.c ****  *   This function does not apply to all USART's. Refer to chip manuals.
 729:../emlib/src/em_usart.c ****  *
 730:../emlib/src/em_usart.c ****  ******************************************************************************/
 731:../emlib/src/em_usart.c **** void USART_InitI2s(USART_TypeDef *usart, USART_InitI2s_TypeDef *init)
 732:../emlib/src/em_usart.c **** {
 733:../emlib/src/em_usart.c ****   USART_Enable_TypeDef enable;
 734:../emlib/src/em_usart.c **** 
 735:../emlib/src/em_usart.c ****   /* Make sure the module exists on the selected chip */
 736:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_I2S_VALID(usart));
 737:../emlib/src/em_usart.c **** 
 738:../emlib/src/em_usart.c ****   /* Override the enable setting. */
 739:../emlib/src/em_usart.c ****   enable            = init->sync.enable;
 740:../emlib/src/em_usart.c ****   init->sync.enable = usartDisable;
 741:../emlib/src/em_usart.c **** 
 742:../emlib/src/em_usart.c ****   /* Init USART as a sync device. */
 743:../emlib/src/em_usart.c ****   USART_InitSync(usart, &init->sync);
 744:../emlib/src/em_usart.c **** 
 745:../emlib/src/em_usart.c ****   /* Configure and enable I2CCTRL register acording to selected mode. */
 746:../emlib/src/em_usart.c ****   usart->I2SCTRL = ((uint32_t) init->format) |
 747:../emlib/src/em_usart.c ****                    ((uint32_t) init->justify) |
 748:../emlib/src/em_usart.c ****                    (init->delay    ? USART_I2SCTRL_DELAY    : 0) |
 749:../emlib/src/em_usart.c ****                    (init->dmaSplit ? USART_I2SCTRL_DMASPLIT : 0) |
 750:../emlib/src/em_usart.c ****                    (init->mono     ? USART_I2SCTRL_MONO     : 0) |
 751:../emlib/src/em_usart.c ****                    (USART_I2SCTRL_EN);
ARM GAS  /tmp/ccmo25Cu.s 			page 23


 752:../emlib/src/em_usart.c **** 
 753:../emlib/src/em_usart.c ****   if (enable != usartDisable)
 754:../emlib/src/em_usart.c ****   {
 755:../emlib/src/em_usart.c ****     USART_Enable(usart, enable);
 756:../emlib/src/em_usart.c ****   }
 757:../emlib/src/em_usart.c **** }
 758:../emlib/src/em_usart.c **** #endif
 759:../emlib/src/em_usart.c **** 
 760:../emlib/src/em_usart.c **** 
 761:../emlib/src/em_usart.c **** /***************************************************************************//**
 762:../emlib/src/em_usart.c ****  * @brief
 763:../emlib/src/em_usart.c ****  *   Initialize automatic transmissions using PRS channel as trigger
 764:../emlib/src/em_usart.c ****  * @note
 765:../emlib/src/em_usart.c ****  *   Initialize USART with USART_Init() before setting up PRS configuration
 766:../emlib/src/em_usart.c ****  *
 767:../emlib/src/em_usart.c ****  * @param[in] usart Pointer to USART to configure
 768:../emlib/src/em_usart.c ****  * @param[in] init Pointer to initialization structure
 769:../emlib/src/em_usart.c ****  ******************************************************************************/
 770:../emlib/src/em_usart.c **** void USART_InitPrsTrigger(USART_TypeDef *usart, const USART_PrsTriggerInit_TypeDef *init)
 771:../emlib/src/em_usart.c **** {
 488              		.loc 1 771 0
 489              		.cfi_startproc
 490              		@ args = 0, pretend = 0, frame = 0
 491              		@ frame_needed = 0, uses_anonymous_args = 0
 492              		@ link register save eliminated.
 493              	.LVL67:
 772:../emlib/src/em_usart.c ****   uint32_t trigctrl;
 773:../emlib/src/em_usart.c **** 
 774:../emlib/src/em_usart.c ****   /* Clear values that will be reconfigured  */
 775:../emlib/src/em_usart.c ****   trigctrl = usart->TRIGCTRL & ~(_USART_TRIGCTRL_RXTEN_MASK |
 494              		.loc 1 775 0
 495 0000 8368     		ldr	r3, [r0, #8]
 776:../emlib/src/em_usart.c ****                                  _USART_TRIGCTRL_TXTEN_MASK |
 777:../emlib/src/em_usart.c **** #if defined(USART_TRIGCTRL_AUTOTXTEN)
 778:../emlib/src/em_usart.c ****                                  _USART_TRIGCTRL_AUTOTXTEN_MASK |
 779:../emlib/src/em_usart.c **** #endif
 780:../emlib/src/em_usart.c ****                                  _USART_TRIGCTRL_TSEL_MASK);
 781:../emlib/src/em_usart.c **** 
 782:../emlib/src/em_usart.c **** #if defined(USART_TRIGCTRL_AUTOTXTEN)
 783:../emlib/src/em_usart.c ****   if (init->autoTxTriggerEnable)
 784:../emlib/src/em_usart.c ****   {
 785:../emlib/src/em_usart.c ****     trigctrl |= USART_TRIGCTRL_AUTOTXTEN;
 786:../emlib/src/em_usart.c ****   }
 787:../emlib/src/em_usart.c **** #endif
 788:../emlib/src/em_usart.c ****   if (init->txTriggerEnable)
 496              		.loc 1 788 0
 497 0002 4A78     		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 775:../emlib/src/em_usart.c ****   trigctrl = usart->TRIGCTRL & ~(_USART_TRIGCTRL_RXTEN_MASK |
 498              		.loc 1 775 0
 499 0004 23F03703 		bic	r3, r3, #55
 500              	.LVL68:
 501              		.loc 1 788 0
 502 0008 0AB1     		cbz	r2, .L42
 789:../emlib/src/em_usart.c ****   {
 790:../emlib/src/em_usart.c ****     trigctrl |= USART_TRIGCTRL_TXTEN;
 503              		.loc 1 790 0
 504 000a 43F02003 		orr	r3, r3, #32
ARM GAS  /tmp/ccmo25Cu.s 			page 24


 505              	.LVL69:
 506              	.L42:
 791:../emlib/src/em_usart.c ****   }
 792:../emlib/src/em_usart.c ****   if (init->rxTriggerEnable)
 507              		.loc 1 792 0
 508 000e 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 509 0010 0AB1     		cbz	r2, .L43
 793:../emlib/src/em_usart.c ****   {
 794:../emlib/src/em_usart.c ****     trigctrl |= USART_TRIGCTRL_RXTEN;
 510              		.loc 1 794 0
 511 0012 43F01003 		orr	r3, r3, #16
 512              	.LVL70:
 513              	.L43:
 795:../emlib/src/em_usart.c ****   }
 796:../emlib/src/em_usart.c ****   trigctrl |= init->prsTriggerChannel;
 514              		.loc 1 796 0
 515 0016 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 516 0018 1343     		orrs	r3, r3, r2
 517              	.LVL71:
 797:../emlib/src/em_usart.c **** 
 798:../emlib/src/em_usart.c ****   /* Enable new configuration */
 799:../emlib/src/em_usart.c ****   usart->TRIGCTRL = trigctrl;
 518              		.loc 1 799 0
 519 001a 8360     		str	r3, [r0, #8]
 520 001c 7047     		bx	lr
 521              		.cfi_endproc
 522              	.LFE86:
 524              		.section	.text.USART_Reset,"ax",%progbits
 525              		.align	1
 526              		.global	USART_Reset
 527              		.thumb
 528              		.thumb_func
 530              	USART_Reset:
 531              	.LFB87:
 800:../emlib/src/em_usart.c **** }
 801:../emlib/src/em_usart.c **** 
 802:../emlib/src/em_usart.c **** 
 803:../emlib/src/em_usart.c **** /***************************************************************************//**
 804:../emlib/src/em_usart.c ****  * @brief
 805:../emlib/src/em_usart.c ****  *   Reset USART/UART to same state as after a HW reset.
 806:../emlib/src/em_usart.c ****  *
 807:../emlib/src/em_usart.c ****  * @param[in] usart
 808:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 809:../emlib/src/em_usart.c ****  ******************************************************************************/
 810:../emlib/src/em_usart.c **** void USART_Reset(USART_TypeDef *usart)
 811:../emlib/src/em_usart.c **** {
 532              		.loc 1 811 0
 533              		.cfi_startproc
 534              		@ args = 0, pretend = 0, frame = 0
 535              		@ frame_needed = 0, uses_anonymous_args = 0
 536              	.LVL72:
 812:../emlib/src/em_usart.c ****   /* Make sure the module exists on the selected chip */
 813:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart) || UART_REF_VALID(usart));
 537              		.loc 1 813 0
 538 0000 124B     		ldr	r3, .L53
 811:../emlib/src/em_usart.c **** {
 539              		.loc 1 811 0
ARM GAS  /tmp/ccmo25Cu.s 			page 25


 540 0002 10B5     		push	{r4, lr}
 541              		.cfi_def_cfa_offset 8
 542              		.cfi_offset 4, -8
 543              		.cfi_offset 14, -4
 544              		.loc 1 813 0
 545 0004 9842     		cmp	r0, r3
 811:../emlib/src/em_usart.c **** {
 546              		.loc 1 811 0
 547 0006 0446     		mov	r4, r0
 548              		.loc 1 813 0
 549 0008 0CD0     		beq	.L51
 550              		.loc 1 813 0 is_stmt 0 discriminator 1
 551 000a 03F58063 		add	r3, r3, #1024
 552 000e 9842     		cmp	r0, r3
 553 0010 08D0     		beq	.L51
 554 0012 03F58063 		add	r3, r3, #1024
 555 0016 9842     		cmp	r0, r3
 556 0018 04D0     		beq	.L51
 557 001a 0D48     		ldr	r0, .L53+4
 558              	.LVL73:
 559 001c 40F22D31 		movw	r1, #813
 560 0020 FFF7FEFF 		bl	assertEFM
 561              	.LVL74:
 562              	.L51:
 814:../emlib/src/em_usart.c **** 
 815:../emlib/src/em_usart.c ****   /* Make sure disabled first, before resetting other registers */
 816:../emlib/src/em_usart.c ****   usart->CMD = USART_CMD_RXDIS | USART_CMD_TXDIS | USART_CMD_MASTERDIS |
 563              		.loc 1 816 0 is_stmt 1
 564 0024 40F6AA63 		movw	r3, #3754
 565 0028 E360     		str	r3, [r4, #12]
 817:../emlib/src/em_usart.c ****                USART_CMD_RXBLOCKDIS | USART_CMD_TXTRIDIS | USART_CMD_CLEARTX | USART_CMD_CLEARRX;
 818:../emlib/src/em_usart.c ****   usart->CTRL     = _USART_CTRL_RESETVALUE;
 819:../emlib/src/em_usart.c ****   usart->FRAME    = _USART_FRAME_RESETVALUE;
 566              		.loc 1 819 0
 567 002a 41F20502 		movw	r2, #4101
 818:../emlib/src/em_usart.c ****   usart->CTRL     = _USART_CTRL_RESETVALUE;
 568              		.loc 1 818 0
 569 002e 0023     		movs	r3, #0
 570 0030 2360     		str	r3, [r4]
 571              		.loc 1 819 0
 572 0032 6260     		str	r2, [r4, #4]
 820:../emlib/src/em_usart.c ****   usart->TRIGCTRL = _USART_TRIGCTRL_RESETVALUE;
 821:../emlib/src/em_usart.c ****   usart->CLKDIV   = _USART_CLKDIV_RESETVALUE;
 822:../emlib/src/em_usart.c ****   usart->IEN      = _USART_IEN_RESETVALUE;
 823:../emlib/src/em_usart.c ****   usart->IFC      = _USART_IFC_MASK;
 573              		.loc 1 823 0
 574 0034 41F6F972 		movw	r2, #8185
 820:../emlib/src/em_usart.c ****   usart->TRIGCTRL = _USART_TRIGCTRL_RESETVALUE;
 575              		.loc 1 820 0
 576 0038 A360     		str	r3, [r4, #8]
 821:../emlib/src/em_usart.c ****   usart->CLKDIV   = _USART_CLKDIV_RESETVALUE;
 577              		.loc 1 821 0
 578 003a 6361     		str	r3, [r4, #20]
 822:../emlib/src/em_usart.c ****   usart->IEN      = _USART_IEN_RESETVALUE;
 579              		.loc 1 822 0
 580 003c E364     		str	r3, [r4, #76]
 581              		.loc 1 823 0
ARM GAS  /tmp/ccmo25Cu.s 			page 26


 582 003e A264     		str	r2, [r4, #72]
 824:../emlib/src/em_usart.c ****   usart->ROUTE    = _USART_ROUTE_RESETVALUE;
 825:../emlib/src/em_usart.c **** 
 826:../emlib/src/em_usart.c ****   if (USART_IRDA_VALID(usart))
 583              		.loc 1 826 0
 584 0040 024A     		ldr	r2, .L53
 824:../emlib/src/em_usart.c ****   usart->ROUTE    = _USART_ROUTE_RESETVALUE;
 585              		.loc 1 824 0
 586 0042 6365     		str	r3, [r4, #84]
 587              		.loc 1 826 0
 588 0044 9442     		cmp	r4, r2
 827:../emlib/src/em_usart.c ****   {
 828:../emlib/src/em_usart.c ****     usart->IRCTRL = _USART_IRCTRL_RESETVALUE;
 589              		.loc 1 828 0
 590 0046 08BF     		it	eq
 591 0048 2365     		streq	r3, [r4, #80]
 592 004a 10BD     		pop	{r4, pc}
 593              	.LVL75:
 594              	.L54:
 595              		.align	2
 596              	.L53:
 597 004c 00C00040 		.word	1073790976
 598 0050 00000000 		.word	.LC0
 599              		.cfi_endproc
 600              	.LFE87:
 602              		.section	.text.USART_InitAsync,"ax",%progbits
 603              		.align	1
 604              		.global	USART_InitAsync
 605              		.thumb
 606              		.thumb_func
 608              	USART_InitAsync:
 609              	.LFB83:
 548:../emlib/src/em_usart.c **** {
 610              		.loc 1 548 0
 611              		.cfi_startproc
 612              		@ args = 0, pretend = 0, frame = 0
 613              		@ frame_needed = 0, uses_anonymous_args = 0
 614              	.LVL76:
 615 0000 38B5     		push	{r3, r4, r5, lr}
 616              		.cfi_def_cfa_offset 16
 617              		.cfi_offset 3, -16
 618              		.cfi_offset 4, -12
 619              		.cfi_offset 5, -8
 620              		.cfi_offset 14, -4
 550:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart) || UART_REF_VALID(usart));
 621              		.loc 1 550 0
 622 0002 124B     		ldr	r3, .L57
 548:../emlib/src/em_usart.c **** {
 623              		.loc 1 548 0
 624 0004 0446     		mov	r4, r0
 550:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart) || UART_REF_VALID(usart));
 625              		.loc 1 550 0
 626 0006 9842     		cmp	r0, r3
 548:../emlib/src/em_usart.c **** {
 627              		.loc 1 548 0
 628 0008 0D46     		mov	r5, r1
 550:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart) || UART_REF_VALID(usart));
ARM GAS  /tmp/ccmo25Cu.s 			page 27


 629              		.loc 1 550 0
 630 000a 0CD0     		beq	.L56
 550:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart) || UART_REF_VALID(usart));
 631              		.loc 1 550 0 is_stmt 0 discriminator 1
 632 000c 03F58063 		add	r3, r3, #1024
 633 0010 9842     		cmp	r0, r3
 634 0012 08D0     		beq	.L56
 635 0014 03F58063 		add	r3, r3, #1024
 636 0018 9842     		cmp	r0, r3
 637 001a 04D0     		beq	.L56
 638 001c 0C48     		ldr	r0, .L57+4
 639              	.LVL77:
 640 001e 40F22621 		movw	r1, #550
 641              	.LVL78:
 642 0022 FFF7FEFF 		bl	assertEFM
 643              	.LVL79:
 644              	.L56:
 553:../emlib/src/em_usart.c ****   USART_Reset(usart);
 645              		.loc 1 553 0 is_stmt 1
 646 0026 2046     		mov	r0, r4
 647 0028 FFF7FEFF 		bl	USART_Reset
 648              	.LVL80:
 571:../emlib/src/em_usart.c ****                  (uint32_t) (init->stopbits) |
 649              		.loc 1 571 0
 650 002c 2A8A     		ldrh	r2, [r5, #16]
 570:../emlib/src/em_usart.c ****   usart->FRAME = (uint32_t) (init->databits) |
 651              		.loc 1 570 0
 652 002e 6B7B     		ldrb	r3, [r5, #13]	@ zero_extendqisi2
 575:../emlib/src/em_usart.c ****   USART_BaudrateAsyncSet(usart, init->refFreq, init->baudrate, init->oversampling);
 653              		.loc 1 575 0
 654 0030 2046     		mov	r0, r4
 570:../emlib/src/em_usart.c ****   usart->FRAME = (uint32_t) (init->databits) |
 655              		.loc 1 570 0
 656 0032 1343     		orrs	r3, r3, r2
 572:../emlib/src/em_usart.c ****                  (uint32_t) (init->parity);
 657              		.loc 1 572 0
 658 0034 EA89     		ldrh	r2, [r5, #14]
 575:../emlib/src/em_usart.c ****   USART_BaudrateAsyncSet(usart, init->refFreq, init->baudrate, init->oversampling);
 659              		.loc 1 575 0
 660 0036 6968     		ldr	r1, [r5, #4]
 571:../emlib/src/em_usart.c ****                  (uint32_t) (init->stopbits) |
 661              		.loc 1 571 0
 662 0038 1343     		orrs	r3, r3, r2
 570:../emlib/src/em_usart.c ****   usart->FRAME = (uint32_t) (init->databits) |
 663              		.loc 1 570 0
 664 003a 6360     		str	r3, [r4, #4]
 575:../emlib/src/em_usart.c ****   USART_BaudrateAsyncSet(usart, init->refFreq, init->baudrate, init->oversampling);
 665              		.loc 1 575 0
 666 003c AA68     		ldr	r2, [r5, #8]
 667 003e 2B7B     		ldrb	r3, [r5, #12]	@ zero_extendqisi2
 668 0040 FFF7FEFF 		bl	USART_BaudrateAsyncSet
 669              	.LVL81:
 578:../emlib/src/em_usart.c ****   usart->CMD = (uint32_t) (init->enable);
 670              		.loc 1 578 0
 671 0044 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 672 0046 E360     		str	r3, [r4, #12]
 673 0048 38BD     		pop	{r3, r4, r5, pc}
ARM GAS  /tmp/ccmo25Cu.s 			page 28


 674              	.LVL82:
 675              	.L58:
 676 004a 00BF     		.align	2
 677              	.L57:
 678 004c 00C00040 		.word	1073790976
 679 0050 00000000 		.word	.LC0
 680              		.cfi_endproc
 681              	.LFE83:
 683              		.section	.text.USART_InitIrDA,"ax",%progbits
 684              		.align	1
 685              		.global	USART_InitIrDA
 686              		.thumb
 687              		.thumb_func
 689              	USART_InitIrDA:
 690              	.LFB85:
 670:../emlib/src/em_usart.c **** {
 691              		.loc 1 670 0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 0
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              	.LVL83:
 696 0000 38B5     		push	{r3, r4, r5, lr}
 697              		.cfi_def_cfa_offset 16
 698              		.cfi_offset 3, -16
 699              		.cfi_offset 4, -12
 700              		.cfi_offset 5, -8
 701              		.cfi_offset 14, -4
 678:../emlib/src/em_usart.c ****   USART_InitAsync(usart, &(init->async));
 702              		.loc 1 678 0
 703 0002 114D     		ldr	r5, .L64
 670:../emlib/src/em_usart.c **** {
 704              		.loc 1 670 0
 705 0004 0446     		mov	r4, r0
 678:../emlib/src/em_usart.c ****   USART_InitAsync(usart, &(init->async));
 706              		.loc 1 678 0
 707 0006 2146     		mov	r1, r4
 708 0008 2846     		mov	r0, r5
 709              	.LVL84:
 710 000a FFF7FEFF 		bl	USART_InitAsync
 711              	.LVL85:
 681:../emlib/src/em_usart.c ****   usart->CTRL |= USART_CTRL_TXINV;
 712              		.loc 1 681 0
 713 000e 2B68     		ldr	r3, [r5]
 714 0010 2846     		mov	r0, r5
 715 0012 43F48043 		orr	r3, r3, #16384
 716 0016 2B60     		str	r3, [r5]
 684:../emlib/src/em_usart.c ****   if (init->irRxInv)
 717              		.loc 1 684 0
 718 0018 237D     		ldrb	r3, [r4, #20]	@ zero_extendqisi2
 719 001a 1BB1     		cbz	r3, .L60
 686:../emlib/src/em_usart.c ****     usart->CTRL |= USART_CTRL_RXINV;
 720              		.loc 1 686 0
 721 001c 2B68     		ldr	r3, [r5]
 722 001e 43F40053 		orr	r3, r3, #8192
 723 0022 2B60     		str	r3, [r5]
 724              	.L60:
 690:../emlib/src/em_usart.c ****   usart->IRCTRL |= (uint32_t) init->irPw |
ARM GAS  /tmp/ccmo25Cu.s 			page 29


 725              		.loc 1 690 0
 726 0024 217E     		ldrb	r1, [r4, #24]	@ zero_extendqisi2
 727 0026 A37D     		ldrb	r3, [r4, #22]	@ zero_extendqisi2
 728 0028 026D     		ldr	r2, [r0, #80]
 729 002a 0B43     		orrs	r3, r3, r1
 692:../emlib/src/em_usart.c ****                    ((uint32_t) init->irFilt << _USART_IRCTRL_IRFILT_SHIFT) |
 730              		.loc 1 692 0
 731 002c 617D     		ldrb	r1, [r4, #21]	@ zero_extendqisi2
 691:../emlib/src/em_usart.c ****                    (uint32_t) init->irPrsSel |
 732              		.loc 1 691 0
 733 002e 43EAC103 		orr	r3, r3, r1, lsl #3
 692:../emlib/src/em_usart.c ****                    ((uint32_t) init->irFilt << _USART_IRCTRL_IRFILT_SHIFT) |
 734              		.loc 1 692 0
 735 0032 1343     		orrs	r3, r3, r2
 693:../emlib/src/em_usart.c ****                    ((uint32_t) init->irPrsEn << _USART_IRCTRL_IRPRSEN_SHIFT);
 736              		.loc 1 693 0
 737 0034 E27D     		ldrb	r2, [r4, #23]	@ zero_extendqisi2
 690:../emlib/src/em_usart.c ****   usart->IRCTRL |= (uint32_t) init->irPw |
 738              		.loc 1 690 0
 739 0036 43EAC213 		orr	r3, r3, r2, lsl #7
 740 003a 0365     		str	r3, [r0, #80]
 696:../emlib/src/em_usart.c ****   usart->IRCTRL |= USART_IRCTRL_IREN;
 741              		.loc 1 696 0
 742 003c 036D     		ldr	r3, [r0, #80]
 743 003e 43F00103 		orr	r3, r3, #1
 744 0042 0365     		str	r3, [r0, #80]
 745 0044 38BD     		pop	{r3, r4, r5, pc}
 746              	.LVL86:
 747              	.L65:
 748 0046 00BF     		.align	2
 749              	.L64:
 750 0048 00C00040 		.word	1073790976
 751              		.cfi_endproc
 752              	.LFE85:
 754              		.section	.text.USART_InitSync,"ax",%progbits
 755              		.align	1
 756              		.global	USART_InitSync
 757              		.thumb
 758              		.thumb_func
 760              	USART_InitSync:
 761              	.LFB84:
 607:../emlib/src/em_usart.c **** {
 762              		.loc 1 607 0
 763              		.cfi_startproc
 764              		@ args = 0, pretend = 0, frame = 0
 765              		@ frame_needed = 0, uses_anonymous_args = 0
 766              	.LVL87:
 767 0000 38B5     		push	{r3, r4, r5, lr}
 768              		.cfi_def_cfa_offset 16
 769              		.cfi_offset 3, -16
 770              		.cfi_offset 4, -12
 771              		.cfi_offset 5, -8
 772              		.cfi_offset 14, -4
 609:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart));
 773              		.loc 1 609 0
 774 0002 194B     		ldr	r3, .L74
 607:../emlib/src/em_usart.c **** {
ARM GAS  /tmp/ccmo25Cu.s 			page 30


 775              		.loc 1 607 0
 776 0004 0446     		mov	r4, r0
 609:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart));
 777              		.loc 1 609 0
 778 0006 9842     		cmp	r0, r3
 607:../emlib/src/em_usart.c **** {
 779              		.loc 1 607 0
 780 0008 0D46     		mov	r5, r1
 609:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart));
 781              		.loc 1 609 0
 782 000a 0CD0     		beq	.L67
 609:../emlib/src/em_usart.c ****   EFM_ASSERT(USART_REF_VALID(usart));
 783              		.loc 1 609 0 is_stmt 0 discriminator 1
 784 000c 03F58063 		add	r3, r3, #1024
 785 0010 9842     		cmp	r0, r3
 786 0012 08D0     		beq	.L67
 787 0014 03F58063 		add	r3, r3, #1024
 788 0018 9842     		cmp	r0, r3
 789 001a 04D0     		beq	.L67
 790 001c 1348     		ldr	r0, .L74+4
 791              	.LVL88:
 792 001e 40F26121 		movw	r1, #609
 793              	.LVL89:
 794 0022 FFF7FEFF 		bl	assertEFM
 795              	.LVL90:
 796              	.L67:
 612:../emlib/src/em_usart.c ****   USART_Reset(usart);
 797              		.loc 1 612 0 is_stmt 1
 798 0026 2046     		mov	r0, r4
 799 0028 FFF7FEFF 		bl	USART_Reset
 800              	.LVL91:
 615:../emlib/src/em_usart.c ****   usart->CTRL |= (USART_CTRL_SYNC) |
 801              		.loc 1 615 0
 802 002c 2B8A     		ldrh	r3, [r5, #16]
 617:../emlib/src/em_usart.c ****                  (init->msbf ? USART_CTRL_MSBF : 0);
 803              		.loc 1 617 0
 804 002e AA7B     		ldrb	r2, [r5, #14]	@ zero_extendqisi2
 615:../emlib/src/em_usart.c ****   usart->CTRL |= (USART_CTRL_SYNC) |
 805              		.loc 1 615 0
 806 0030 2168     		ldr	r1, [r4]
 807 0032 43F00103 		orr	r3, r3, #1
 617:../emlib/src/em_usart.c ****                  (init->msbf ? USART_CTRL_MSBF : 0);
 808              		.loc 1 617 0
 809 0036 002A     		cmp	r2, #0
 615:../emlib/src/em_usart.c ****   usart->CTRL |= (USART_CTRL_SYNC) |
 810              		.loc 1 615 0
 811 0038 9BB2     		uxth	r3, r3
 617:../emlib/src/em_usart.c ****                  (init->msbf ? USART_CTRL_MSBF : 0);
 812              		.loc 1 617 0
 813 003a 0CBF     		ite	eq
 814 003c 0022     		moveq	r2, #0
 815 003e 4FF48062 		movne	r2, #1024
 616:../emlib/src/em_usart.c ****                  ((uint32_t) init->clockMode) |
 816              		.loc 1 616 0
 817 0042 0B43     		orrs	r3, r3, r1
 615:../emlib/src/em_usart.c ****   usart->CTRL |= (USART_CTRL_SYNC) |
 818              		.loc 1 615 0
ARM GAS  /tmp/ccmo25Cu.s 			page 31


 819 0044 1343     		orrs	r3, r3, r2
 820 0046 2360     		str	r3, [r4]
 625:../emlib/src/em_usart.c ****   usart->FRAME = ((uint32_t) (init->databits)) |
 821              		.loc 1 625 0
 822 0048 2B7B     		ldrb	r3, [r5, #12]	@ zero_extendqisi2
 630:../emlib/src/em_usart.c ****   USART_BaudrateSyncSet(usart, init->refFreq, init->baudrate);
 823              		.loc 1 630 0
 824 004a 2046     		mov	r0, r4
 626:../emlib/src/em_usart.c ****                  (USART_FRAME_STOPBITS_DEFAULT) |
 825              		.loc 1 626 0
 826 004c 43F48053 		orr	r3, r3, #4096
 625:../emlib/src/em_usart.c ****   usart->FRAME = ((uint32_t) (init->databits)) |
 827              		.loc 1 625 0
 828 0050 6360     		str	r3, [r4, #4]
 630:../emlib/src/em_usart.c ****   USART_BaudrateSyncSet(usart, init->refFreq, init->baudrate);
 829              		.loc 1 630 0
 830 0052 6968     		ldr	r1, [r5, #4]
 831 0054 AA68     		ldr	r2, [r5, #8]
 832 0056 FFF7FEFF 		bl	USART_BaudrateSyncSet
 833              	.LVL92:
 633:../emlib/src/em_usart.c ****   if (init->master)
 834              		.loc 1 633 0
 835 005a 6B7B     		ldrb	r3, [r5, #13]	@ zero_extendqisi2
 836 005c 0BB1     		cbz	r3, .L69
 635:../emlib/src/em_usart.c ****     usart->CMD = USART_CMD_MASTEREN;
 837              		.loc 1 635 0
 838 005e 1023     		movs	r3, #16
 839 0060 E360     		str	r3, [r4, #12]
 840              	.L69:
 638:../emlib/src/em_usart.c ****   usart->CMD = (uint32_t) (init->enable);
 841              		.loc 1 638 0
 842 0062 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 843 0064 E360     		str	r3, [r4, #12]
 844 0066 38BD     		pop	{r3, r4, r5, pc}
 845              	.LVL93:
 846              	.L75:
 847              		.align	2
 848              	.L74:
 849 0068 00C00040 		.word	1073790976
 850 006c 00000000 		.word	.LC0
 851              		.cfi_endproc
 852              	.LFE84:
 854              		.section	.text.USART_Rx,"ax",%progbits
 855              		.align	1
 856              		.global	USART_Rx
 857              		.thumb
 858              		.thumb_func
 860              	USART_Rx:
 861              	.LFB88:
 829:../emlib/src/em_usart.c ****   }
 830:../emlib/src/em_usart.c **** 
 831:../emlib/src/em_usart.c **** #if defined(_USART_INPUT_RESETVALUE)
 832:../emlib/src/em_usart.c ****   usart->INPUT = _USART_INPUT_RESETVALUE;
 833:../emlib/src/em_usart.c **** #endif
 834:../emlib/src/em_usart.c **** 
 835:../emlib/src/em_usart.c **** #if defined(_USART_I2SCTRL_RESETVALUE)
 836:../emlib/src/em_usart.c ****   if (USART_I2S_VALID(usart))
ARM GAS  /tmp/ccmo25Cu.s 			page 32


 837:../emlib/src/em_usart.c ****   {
 838:../emlib/src/em_usart.c ****     usart->I2SCTRL = _USART_I2SCTRL_RESETVALUE;
 839:../emlib/src/em_usart.c ****   }
 840:../emlib/src/em_usart.c **** #endif
 841:../emlib/src/em_usart.c **** }
 842:../emlib/src/em_usart.c **** 
 843:../emlib/src/em_usart.c **** 
 844:../emlib/src/em_usart.c **** /***************************************************************************//**
 845:../emlib/src/em_usart.c ****  * @brief
 846:../emlib/src/em_usart.c ****  *   Receive one 4-8 bit frame, (or part of 10-16 bit frame).
 847:../emlib/src/em_usart.c ****  *
 848:../emlib/src/em_usart.c ****  * @details
 849:../emlib/src/em_usart.c ****  *   This function is normally used to receive one frame when operating with
 850:../emlib/src/em_usart.c ****  *   frame length 4-8 bits. Please refer to USART_RxExt() for reception of
 851:../emlib/src/em_usart.c ****  *   9 bit frames.
 852:../emlib/src/em_usart.c ****  *
 853:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
 854:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
 855:../emlib/src/em_usart.c ****  *
 856:../emlib/src/em_usart.c ****  * @note
 857:../emlib/src/em_usart.c ****  *   This function will stall if buffer is empty, until data is received.
 858:../emlib/src/em_usart.c ****  *
 859:../emlib/src/em_usart.c ****  * @param[in] usart
 860:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 861:../emlib/src/em_usart.c ****  *
 862:../emlib/src/em_usart.c ****  * @return
 863:../emlib/src/em_usart.c ****  *   Data received.
 864:../emlib/src/em_usart.c ****  ******************************************************************************/
 865:../emlib/src/em_usart.c **** uint8_t USART_Rx(USART_TypeDef *usart)
 866:../emlib/src/em_usart.c **** {
 862              		.loc 1 866 0
 863              		.cfi_startproc
 864              		@ args = 0, pretend = 0, frame = 0
 865              		@ frame_needed = 0, uses_anonymous_args = 0
 866              		@ link register save eliminated.
 867              	.LVL94:
 868              	.L78:
 867:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_RXDATAV))
 869              		.loc 1 867 0 discriminator 1
 870 0000 0369     		ldr	r3, [r0, #16]
 871 0002 1B06     		lsls	r3, r3, #24
 872 0004 FCD5     		bpl	.L78
 868:../emlib/src/em_usart.c ****     ;
 869:../emlib/src/em_usart.c **** 
 870:../emlib/src/em_usart.c ****   return (uint8_t) (usart->RXDATA);
 873              		.loc 1 870 0
 874 0006 C069     		ldr	r0, [r0, #28]
 875              	.LVL95:
 871:../emlib/src/em_usart.c **** }
 876              		.loc 1 871 0
 877 0008 C0B2     		uxtb	r0, r0
 878 000a 7047     		bx	lr
 879              		.cfi_endproc
 880              	.LFE88:
 882              		.section	.text.USART_RxDouble,"ax",%progbits
 883              		.align	1
 884              		.global	USART_RxDouble
ARM GAS  /tmp/ccmo25Cu.s 			page 33


 885              		.thumb
 886              		.thumb_func
 888              	USART_RxDouble:
 889              	.LFB89:
 872:../emlib/src/em_usart.c **** 
 873:../emlib/src/em_usart.c **** 
 874:../emlib/src/em_usart.c **** /***************************************************************************//**
 875:../emlib/src/em_usart.c ****  * @brief
 876:../emlib/src/em_usart.c ****  *   Receive two 4-8 bit frames, or one 10-16 bit frame.
 877:../emlib/src/em_usart.c ****  *
 878:../emlib/src/em_usart.c ****  * @details
 879:../emlib/src/em_usart.c ****  *   This function is normally used to receive one frame when operating with
 880:../emlib/src/em_usart.c ****  *   frame length 10-16 bits. Please refer to USART_RxDoubleExt() for reception
 881:../emlib/src/em_usart.c ****  *   of two 9 bit frames.
 882:../emlib/src/em_usart.c ****  *
 883:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
 884:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
 885:../emlib/src/em_usart.c ****  *
 886:../emlib/src/em_usart.c ****  * @note
 887:../emlib/src/em_usart.c ****  *   This function will stall if buffer is empty, until data is received.
 888:../emlib/src/em_usart.c ****  *
 889:../emlib/src/em_usart.c ****  * @param[in] usart
 890:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 891:../emlib/src/em_usart.c ****  *
 892:../emlib/src/em_usart.c ****  * @return
 893:../emlib/src/em_usart.c ****  *   Data received.
 894:../emlib/src/em_usart.c ****  ******************************************************************************/
 895:../emlib/src/em_usart.c **** uint16_t USART_RxDouble(USART_TypeDef *usart)
 896:../emlib/src/em_usart.c **** {
 890              		.loc 1 896 0
 891              		.cfi_startproc
 892              		@ args = 0, pretend = 0, frame = 0
 893              		@ frame_needed = 0, uses_anonymous_args = 0
 894              		@ link register save eliminated.
 895              	.LVL96:
 896              	.L81:
 897:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_RXFULL))
 897              		.loc 1 897 0 discriminator 1
 898 0000 0369     		ldr	r3, [r0, #16]
 899 0002 DB05     		lsls	r3, r3, #23
 900 0004 FCD5     		bpl	.L81
 898:../emlib/src/em_usart.c ****     ;
 899:../emlib/src/em_usart.c **** 
 900:../emlib/src/em_usart.c ****   return (uint16_t) (usart->RXDOUBLE);
 901              		.loc 1 900 0
 902 0006 406A     		ldr	r0, [r0, #36]
 903              	.LVL97:
 901:../emlib/src/em_usart.c **** }
 904              		.loc 1 901 0
 905 0008 80B2     		uxth	r0, r0
 906 000a 7047     		bx	lr
 907              		.cfi_endproc
 908              	.LFE89:
 910              		.section	.text.USART_RxDoubleExt,"ax",%progbits
 911              		.align	1
 912              		.global	USART_RxDoubleExt
 913              		.thumb
ARM GAS  /tmp/ccmo25Cu.s 			page 34


 914              		.thumb_func
 916              	USART_RxDoubleExt:
 917              	.LFB90:
 902:../emlib/src/em_usart.c **** 
 903:../emlib/src/em_usart.c **** 
 904:../emlib/src/em_usart.c **** /***************************************************************************//**
 905:../emlib/src/em_usart.c ****  * @brief
 906:../emlib/src/em_usart.c ****  *   Receive two 4-9 bit frames, or one 10-16 bit frame with extended
 907:../emlib/src/em_usart.c ****  *   information.
 908:../emlib/src/em_usart.c ****  *
 909:../emlib/src/em_usart.c ****  * @details
 910:../emlib/src/em_usart.c ****  *   This function is normally used to receive one frame when operating with
 911:../emlib/src/em_usart.c ****  *   frame length 10-16 bits and additional RX status information is required.
 912:../emlib/src/em_usart.c ****  *
 913:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
 914:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
 915:../emlib/src/em_usart.c ****  *
 916:../emlib/src/em_usart.c ****  * @note
 917:../emlib/src/em_usart.c ****  *   This function will stall if buffer is empty, until data is received.
 918:../emlib/src/em_usart.c ****  *
 919:../emlib/src/em_usart.c ****  * @param[in] usart
 920:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 921:../emlib/src/em_usart.c ****  *
 922:../emlib/src/em_usart.c ****  * @return
 923:../emlib/src/em_usart.c ****  *   Data received.
 924:../emlib/src/em_usart.c ****  ******************************************************************************/
 925:../emlib/src/em_usart.c **** uint32_t USART_RxDoubleExt(USART_TypeDef *usart)
 926:../emlib/src/em_usart.c **** {
 918              		.loc 1 926 0
 919              		.cfi_startproc
 920              		@ args = 0, pretend = 0, frame = 0
 921              		@ frame_needed = 0, uses_anonymous_args = 0
 922              		@ link register save eliminated.
 923              	.LVL98:
 924              	.L84:
 927:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_RXFULL))
 925              		.loc 1 927 0 discriminator 1
 926 0000 0369     		ldr	r3, [r0, #16]
 927 0002 DB05     		lsls	r3, r3, #23
 928 0004 FCD5     		bpl	.L84
 928:../emlib/src/em_usart.c ****     ;
 929:../emlib/src/em_usart.c **** 
 930:../emlib/src/em_usart.c ****   return usart->RXDOUBLEX;
 929              		.loc 1 930 0
 930 0006 006A     		ldr	r0, [r0, #32]
 931              	.LVL99:
 931:../emlib/src/em_usart.c **** }
 932              		.loc 1 931 0
 933 0008 7047     		bx	lr
 934              		.cfi_endproc
 935              	.LFE90:
 937              		.section	.text.USART_RxExt,"ax",%progbits
 938              		.align	1
 939              		.global	USART_RxExt
 940              		.thumb
 941              		.thumb_func
 943              	USART_RxExt:
ARM GAS  /tmp/ccmo25Cu.s 			page 35


 944              	.LFB91:
 932:../emlib/src/em_usart.c **** 
 933:../emlib/src/em_usart.c **** 
 934:../emlib/src/em_usart.c **** /***************************************************************************//**
 935:../emlib/src/em_usart.c ****  * @brief
 936:../emlib/src/em_usart.c ****  *   Receive one 4-9 bit frame, (or part of 10-16 bit frame) with extended
 937:../emlib/src/em_usart.c ****  *   information.
 938:../emlib/src/em_usart.c ****  *
 939:../emlib/src/em_usart.c ****  * @details
 940:../emlib/src/em_usart.c ****  *   This function is normally used to receive one frame when operating with
 941:../emlib/src/em_usart.c ****  *   frame length 4-9 bits and additional RX status information is required.
 942:../emlib/src/em_usart.c ****  *
 943:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
 944:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
 945:../emlib/src/em_usart.c ****  *
 946:../emlib/src/em_usart.c ****  * @note
 947:../emlib/src/em_usart.c ****  *   This function will stall if buffer is empty, until data is received.
 948:../emlib/src/em_usart.c ****  *
 949:../emlib/src/em_usart.c ****  * @param[in] usart
 950:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
 951:../emlib/src/em_usart.c ****  *
 952:../emlib/src/em_usart.c ****  * @return
 953:../emlib/src/em_usart.c ****  *   Data received.
 954:../emlib/src/em_usart.c ****  ******************************************************************************/
 955:../emlib/src/em_usart.c **** uint16_t USART_RxExt(USART_TypeDef *usart)
 956:../emlib/src/em_usart.c **** {
 945              		.loc 1 956 0
 946              		.cfi_startproc
 947              		@ args = 0, pretend = 0, frame = 0
 948              		@ frame_needed = 0, uses_anonymous_args = 0
 949              		@ link register save eliminated.
 950              	.LVL100:
 951              	.L87:
 957:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_RXDATAV))
 952              		.loc 1 957 0 discriminator 1
 953 0000 0369     		ldr	r3, [r0, #16]
 954 0002 1B06     		lsls	r3, r3, #24
 955 0004 FCD5     		bpl	.L87
 958:../emlib/src/em_usart.c ****     ;
 959:../emlib/src/em_usart.c **** 
 960:../emlib/src/em_usart.c ****   return (uint16_t) (usart->RXDATAX);
 956              		.loc 1 960 0
 957 0006 8069     		ldr	r0, [r0, #24]
 958              	.LVL101:
 961:../emlib/src/em_usart.c **** }
 959              		.loc 1 961 0
 960 0008 80B2     		uxth	r0, r0
 961 000a 7047     		bx	lr
 962              		.cfi_endproc
 963              	.LFE91:
 965              		.section	.text.USART_SpiTransfer,"ax",%progbits
 966              		.align	1
 967              		.global	USART_SpiTransfer
 968              		.thumb
 969              		.thumb_func
 971              	USART_SpiTransfer:
 972              	.LFB92:
ARM GAS  /tmp/ccmo25Cu.s 			page 36


 962:../emlib/src/em_usart.c **** 
 963:../emlib/src/em_usart.c **** 
 964:../emlib/src/em_usart.c **** /***************************************************************************//**
 965:../emlib/src/em_usart.c ****  * @brief
 966:../emlib/src/em_usart.c ****  *   Perform one 8 bit frame SPI transfer.
 967:../emlib/src/em_usart.c ****  *
 968:../emlib/src/em_usart.c ****  * @note
 969:../emlib/src/em_usart.c ****  *   This function will stall if the transmit buffer is full. When a transmit
 970:../emlib/src/em_usart.c ****  *   buffer becomes available, data is written and the function will wait until
 971:../emlib/src/em_usart.c ****  *   the data is fully transmitted. The SPI return value is then read out and
 972:../emlib/src/em_usart.c ****  *   returned.
 973:../emlib/src/em_usart.c ****  *
 974:../emlib/src/em_usart.c ****  * @param[in] usart
 975:../emlib/src/em_usart.c ****  *   Pointer to USART peripheral register block.
 976:../emlib/src/em_usart.c ****  *
 977:../emlib/src/em_usart.c ****  * @param[in] data
 978:../emlib/src/em_usart.c ****  *   Data to transmit.
 979:../emlib/src/em_usart.c ****  *
 980:../emlib/src/em_usart.c ****  * @return
 981:../emlib/src/em_usart.c ****  *   Data received.
 982:../emlib/src/em_usart.c ****  ******************************************************************************/
 983:../emlib/src/em_usart.c **** uint8_t USART_SpiTransfer(USART_TypeDef *usart, uint8_t data)
 984:../emlib/src/em_usart.c **** {
 973              		.loc 1 984 0
 974              		.cfi_startproc
 975              		@ args = 0, pretend = 0, frame = 0
 976              		@ frame_needed = 0, uses_anonymous_args = 0
 977              		@ link register save eliminated.
 978              	.LVL102:
 979              	.L90:
 985:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_TXBL))
 980              		.loc 1 985 0 discriminator 1
 981 0000 0369     		ldr	r3, [r0, #16]
 982 0002 5A06     		lsls	r2, r3, #25
 983 0004 FCD5     		bpl	.L90
 986:../emlib/src/em_usart.c ****     ;
 987:../emlib/src/em_usart.c ****   usart->TXDATA = (uint32_t) data;
 984              		.loc 1 987 0
 985 0006 4163     		str	r1, [r0, #52]
 986              	.L92:
 988:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_TXC))
 987              		.loc 1 988 0 discriminator 1
 988 0008 0369     		ldr	r3, [r0, #16]
 989 000a 9B06     		lsls	r3, r3, #26
 990 000c FCD5     		bpl	.L92
 989:../emlib/src/em_usart.c ****     ;
 990:../emlib/src/em_usart.c ****   return (uint8_t) (usart->RXDATA);
 991              		.loc 1 990 0
 992 000e C069     		ldr	r0, [r0, #28]
 993              	.LVL103:
 991:../emlib/src/em_usart.c **** }
 994              		.loc 1 991 0
 995 0010 C0B2     		uxtb	r0, r0
 996 0012 7047     		bx	lr
 997              		.cfi_endproc
 998              	.LFE92:
 1000              		.section	.text.USART_Tx,"ax",%progbits
ARM GAS  /tmp/ccmo25Cu.s 			page 37


 1001              		.align	1
 1002              		.global	USART_Tx
 1003              		.thumb
 1004              		.thumb_func
 1006              	USART_Tx:
 1007              	.LFB93:
 992:../emlib/src/em_usart.c **** 
 993:../emlib/src/em_usart.c **** 
 994:../emlib/src/em_usart.c **** /***************************************************************************//**
 995:../emlib/src/em_usart.c ****  * @brief
 996:../emlib/src/em_usart.c ****  *   Transmit one 4-9 bit frame.
 997:../emlib/src/em_usart.c ****  *
 998:../emlib/src/em_usart.c ****  * @details
 999:../emlib/src/em_usart.c ****  *   Depending on frame length configuration, 4-8 (least significant) bits from
1000:../emlib/src/em_usart.c ****  *   @p data are transmitted. If frame length is 9, 8 bits are transmitted from
1001:../emlib/src/em_usart.c ****  *   @p data and one bit as specified by CTRL register, BIT8DV field. Please
1002:../emlib/src/em_usart.c ****  *   refer to USART_TxExt() for transmitting 9 bit frame with full control of
1003:../emlib/src/em_usart.c ****  *   all 9 bits.
1004:../emlib/src/em_usart.c ****  *
1005:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
1006:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
1007:../emlib/src/em_usart.c ****  *
1008:../emlib/src/em_usart.c ****  * @note
1009:../emlib/src/em_usart.c ****  *   This function will stall if buffer is full, until buffer becomes available.
1010:../emlib/src/em_usart.c ****  *
1011:../emlib/src/em_usart.c ****  * @param[in] usart
1012:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
1013:../emlib/src/em_usart.c ****  *
1014:../emlib/src/em_usart.c ****  * @param[in] data
1015:../emlib/src/em_usart.c ****  *   Data to transmit. See details above for further info.
1016:../emlib/src/em_usart.c ****  ******************************************************************************/
1017:../emlib/src/em_usart.c **** void USART_Tx(USART_TypeDef *usart, uint8_t data)
1018:../emlib/src/em_usart.c **** {
 1008              		.loc 1 1018 0
 1009              		.cfi_startproc
 1010              		@ args = 0, pretend = 0, frame = 0
 1011              		@ frame_needed = 0, uses_anonymous_args = 0
 1012              		@ link register save eliminated.
 1013              	.LVL104:
 1014              	.L95:
1019:../emlib/src/em_usart.c ****   /* Check that transmit buffer is empty */
1020:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_TXBL))
 1015              		.loc 1 1020 0 discriminator 1
 1016 0000 0369     		ldr	r3, [r0, #16]
 1017 0002 5B06     		lsls	r3, r3, #25
 1018 0004 FCD5     		bpl	.L95
1021:../emlib/src/em_usart.c ****     ;
1022:../emlib/src/em_usart.c ****   usart->TXDATA = (uint32_t) data;
 1019              		.loc 1 1022 0
 1020 0006 4163     		str	r1, [r0, #52]
 1021 0008 7047     		bx	lr
 1022              		.cfi_endproc
 1023              	.LFE93:
 1025              		.section	.text.USART_TxDouble,"ax",%progbits
 1026              		.align	1
 1027              		.global	USART_TxDouble
 1028              		.thumb
ARM GAS  /tmp/ccmo25Cu.s 			page 38


 1029              		.thumb_func
 1031              	USART_TxDouble:
 1032              	.LFB94:
1023:../emlib/src/em_usart.c **** }
1024:../emlib/src/em_usart.c **** 
1025:../emlib/src/em_usart.c **** 
1026:../emlib/src/em_usart.c **** /***************************************************************************//**
1027:../emlib/src/em_usart.c ****  * @brief
1028:../emlib/src/em_usart.c ****  *   Transmit two 4-9 bit frames, or one 10-16 bit frame.
1029:../emlib/src/em_usart.c ****  *
1030:../emlib/src/em_usart.c ****  * @details
1031:../emlib/src/em_usart.c ****  *   Depending on frame length configuration, 4-8 (least significant) bits from
1032:../emlib/src/em_usart.c ****  *   each byte in @p data are transmitted. If frame length is 9, 8 bits are
1033:../emlib/src/em_usart.c ****  *   transmitted from each byte in @p data adding one bit as specified by CTRL
1034:../emlib/src/em_usart.c ****  *   register, BIT8DV field, to each byte. Please refer to USART_TxDoubleExt()
1035:../emlib/src/em_usart.c ****  *   for transmitting two 9 bit frames with full control of all 9 bits.
1036:../emlib/src/em_usart.c ****  *
1037:../emlib/src/em_usart.c ****  *   If frame length is 10-16, 10-16 (least significant) bits from @p data
1038:../emlib/src/em_usart.c ****  *   are transmitted.
1039:../emlib/src/em_usart.c ****  *
1040:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
1041:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
1042:../emlib/src/em_usart.c ****  *
1043:../emlib/src/em_usart.c ****  * @note
1044:../emlib/src/em_usart.c ****  *   This function will stall if buffer is full, until buffer becomes available.
1045:../emlib/src/em_usart.c ****  *
1046:../emlib/src/em_usart.c ****  * @param[in] usart
1047:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
1048:../emlib/src/em_usart.c ****  *
1049:../emlib/src/em_usart.c ****  * @param[in] data
1050:../emlib/src/em_usart.c ****  *   Data to transmit, the least significant byte holds the frame transmitted
1051:../emlib/src/em_usart.c ****  *   first. See details above for further info.
1052:../emlib/src/em_usart.c ****  ******************************************************************************/
1053:../emlib/src/em_usart.c **** void USART_TxDouble(USART_TypeDef *usart, uint16_t data)
1054:../emlib/src/em_usart.c **** {
 1033              		.loc 1 1054 0
 1034              		.cfi_startproc
 1035              		@ args = 0, pretend = 0, frame = 0
 1036              		@ frame_needed = 0, uses_anonymous_args = 0
 1037              		@ link register save eliminated.
 1038              	.LVL105:
 1039              	.L98:
1055:../emlib/src/em_usart.c ****   /* Check that transmit buffer is empty */
1056:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_TXBL))
 1040              		.loc 1 1056 0 discriminator 1
 1041 0000 0369     		ldr	r3, [r0, #16]
 1042 0002 5B06     		lsls	r3, r3, #25
 1043 0004 FCD5     		bpl	.L98
1057:../emlib/src/em_usart.c ****     ;
1058:../emlib/src/em_usart.c ****   usart->TXDOUBLE = (uint32_t) data;
 1044              		.loc 1 1058 0
 1045 0006 C163     		str	r1, [r0, #60]
 1046 0008 7047     		bx	lr
 1047              		.cfi_endproc
 1048              	.LFE94:
 1050              		.section	.text.USART_TxDoubleExt,"ax",%progbits
 1051              		.align	1
ARM GAS  /tmp/ccmo25Cu.s 			page 39


 1052              		.global	USART_TxDoubleExt
 1053              		.thumb
 1054              		.thumb_func
 1056              	USART_TxDoubleExt:
 1057              	.LFB95:
1059:../emlib/src/em_usart.c **** }
1060:../emlib/src/em_usart.c **** 
1061:../emlib/src/em_usart.c **** 
1062:../emlib/src/em_usart.c **** /***************************************************************************//**
1063:../emlib/src/em_usart.c ****  * @brief
1064:../emlib/src/em_usart.c ****  *   Transmit two 4-9 bit frames, or one 10-16 bit frame with extended control.
1065:../emlib/src/em_usart.c ****  *
1066:../emlib/src/em_usart.c ****  * @details
1067:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
1068:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
1069:../emlib/src/em_usart.c ****  *
1070:../emlib/src/em_usart.c ****  * @note
1071:../emlib/src/em_usart.c ****  *   This function will stall if buffer is full, until buffer becomes available.
1072:../emlib/src/em_usart.c ****  *
1073:../emlib/src/em_usart.c ****  * @param[in] usart
1074:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
1075:../emlib/src/em_usart.c ****  *
1076:../emlib/src/em_usart.c ****  * @param[in] data
1077:../emlib/src/em_usart.c ****  *   Data to transmit with extended control. Contains two 16 bit words
1078:../emlib/src/em_usart.c ****  *   concatenated. Least significant word holds frame transitted first. If frame
1079:../emlib/src/em_usart.c ****  *   length is 4-9, two frames with 4-9 least significant bits from each 16 bit
1080:../emlib/src/em_usart.c ****  *   word are transmitted.
1081:../emlib/src/em_usart.c ****  * @par
1082:../emlib/src/em_usart.c ****  *   If frame length is 10-16 bits, 8 data bits are taken from the least
1083:../emlib/src/em_usart.c ****  *   significant 16 bit word, and the remaining bits from the other 16 bit word.
1084:../emlib/src/em_usart.c ****  * @par
1085:../emlib/src/em_usart.c ****  *   Additional control bits are available as documented in the EFM32 reference
1086:../emlib/src/em_usart.c ****  *   manual (set to 0 if not used). For 10-16 bit frame length, these control
1087:../emlib/src/em_usart.c ****  *   bits are taken from the most significant 16 bit word.
1088:../emlib/src/em_usart.c ****  ******************************************************************************/
1089:../emlib/src/em_usart.c **** void USART_TxDoubleExt(USART_TypeDef *usart, uint32_t data)
1090:../emlib/src/em_usart.c **** {
 1058              		.loc 1 1090 0
 1059              		.cfi_startproc
 1060              		@ args = 0, pretend = 0, frame = 0
 1061              		@ frame_needed = 0, uses_anonymous_args = 0
 1062              		@ link register save eliminated.
 1063              	.LVL106:
 1064              	.L101:
1091:../emlib/src/em_usart.c ****   /* Check that transmit buffer is empty */
1092:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_TXBL))
 1065              		.loc 1 1092 0 discriminator 1
 1066 0000 0369     		ldr	r3, [r0, #16]
 1067 0002 5B06     		lsls	r3, r3, #25
 1068 0004 FCD5     		bpl	.L101
1093:../emlib/src/em_usart.c ****     ;
1094:../emlib/src/em_usart.c ****   usart->TXDOUBLEX = data;
 1069              		.loc 1 1094 0
 1070 0006 8163     		str	r1, [r0, #56]
 1071 0008 7047     		bx	lr
 1072              		.cfi_endproc
 1073              	.LFE95:
ARM GAS  /tmp/ccmo25Cu.s 			page 40


 1075              		.section	.text.USART_TxExt,"ax",%progbits
 1076              		.align	1
 1077              		.global	USART_TxExt
 1078              		.thumb
 1079              		.thumb_func
 1081              	USART_TxExt:
 1082              	.LFB96:
1095:../emlib/src/em_usart.c **** }
1096:../emlib/src/em_usart.c **** 
1097:../emlib/src/em_usart.c **** 
1098:../emlib/src/em_usart.c **** /***************************************************************************//**
1099:../emlib/src/em_usart.c ****  * @brief
1100:../emlib/src/em_usart.c ****  *   Transmit one 4-9 bit frame with extended control.
1101:../emlib/src/em_usart.c ****  *
1102:../emlib/src/em_usart.c ****  * @details
1103:../emlib/src/em_usart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
1104:../emlib/src/em_usart.c ****  *   considered part of specified frame bit length.
1105:../emlib/src/em_usart.c ****  *
1106:../emlib/src/em_usart.c ****  * @note
1107:../emlib/src/em_usart.c ****  *   This function will stall if buffer is full, until buffer becomes available.
1108:../emlib/src/em_usart.c ****  *
1109:../emlib/src/em_usart.c ****  * @param[in] usart
1110:../emlib/src/em_usart.c ****  *   Pointer to USART/UART peripheral register block.
1111:../emlib/src/em_usart.c ****  *
1112:../emlib/src/em_usart.c ****  * @param[in] data
1113:../emlib/src/em_usart.c ****  *   Data to transmit with extended control. Least significant bits contains
1114:../emlib/src/em_usart.c ****  *   frame bits, and additional control bits are available as documented in
1115:../emlib/src/em_usart.c ****  *   the EFM32 reference manual (set to 0 if not used).
1116:../emlib/src/em_usart.c ****  ******************************************************************************/
1117:../emlib/src/em_usart.c **** void USART_TxExt(USART_TypeDef *usart, uint16_t data)
1118:../emlib/src/em_usart.c **** {
 1083              		.loc 1 1118 0
 1084              		.cfi_startproc
 1085              		@ args = 0, pretend = 0, frame = 0
 1086              		@ frame_needed = 0, uses_anonymous_args = 0
 1087              		@ link register save eliminated.
 1088              	.LVL107:
 1089              	.L104:
1119:../emlib/src/em_usart.c ****   /* Check that transmit buffer is empty */
1120:../emlib/src/em_usart.c ****   while (!(usart->STATUS & USART_STATUS_TXBL))
 1090              		.loc 1 1120 0 discriminator 1
 1091 0000 0369     		ldr	r3, [r0, #16]
 1092 0002 5B06     		lsls	r3, r3, #25
 1093 0004 FCD5     		bpl	.L104
1121:../emlib/src/em_usart.c ****     ;
1122:../emlib/src/em_usart.c ****   usart->TXDATAX = (uint32_t) data;
 1094              		.loc 1 1122 0
 1095 0006 0163     		str	r1, [r0, #48]
 1096 0008 7047     		bx	lr
 1097              		.cfi_endproc
 1098              	.LFE96:
 1100              		.section	.rodata.str1.1,"aMS",%progbits,1
 1101              	.LC0:
 1102 0000 2E2E2F65 		.ascii	"../emlib/src/em_usart.c\000"
 1102      6D6C6962 
 1102      2F737263 
 1102      2F656D5F 
ARM GAS  /tmp/ccmo25Cu.s 			page 41


 1102      75736172 
 1103              		.text
 1104              	.Letext0:
 1105              		.file 2 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 1106              		.file 3 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 1107              		.file 4 "../Device/EnergyMicro/EFM32G/Include/efm32g_usart.h"
 1108              		.file 5 "../emlib/inc/em_usart.h"
 1109              		.file 6 "../emlib/inc/em_cmu.h"
 1110              		.file 7 "../emlib/inc/em_assert.h"
 1111              		.file 8 "../CMSIS/Include/core_cm3.h"
